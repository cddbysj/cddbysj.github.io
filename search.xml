<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[中国主要木材的三大相关标准]]></title>
    <url>%2Fpassages%2F%E4%B8%AD%E5%9B%BD%E4%B8%BB%E8%A6%81%E6%9C%A8%E6%9D%90%E7%9A%84%E4%B8%89%E5%A4%A7%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[《中国主要木材流通商品名称》WB/T1038-2008、《中国主要木材名称》GB/T16734-1995、《中国主要进口木材名称》GB/T18513-2001 标准出台后，三大标准配套使用，给各类木材企业的生产、经营、进出口等带来便利，也给各类商检、质检、专业机构与院校的执法与教学提供依据。 《中国主要木材名称》 GB/T16734-1997标准简介本标准共收载我国380类(个)木材名称(中、英名)及其树种名称(包括中名、别名、拉丁名)、科别、产地和备注。380类木材名称是由907个树种归纳而来，其归类的原则是以树木学(或植物学)的属为基础，把材性和用途相近木材树种名称统一，以便利木材生产、利用、贸易、造林、营林、科研、教学等的应用。907个树种隶属99科(针叶树材8科、阔叶树材91科)、347属(针叶树材33属、阔叶树材314属)，基本上覆盖了我国重要木材树种。 木材树种名称按科以拉丁学名的字母顺序排列，既保持针、阔叶树材和科的完整性，又便于查找。科的范围，针叶树材参照郑万钧等《中国植物志》第七卷的系统概念，阔叶树材参照哈钦松的《有花植物科志》一书的概念，个别种的处理略有不同。在科内、属内木材树种名称原则上也按属及种以拉丁学名的字母顺序排列。 范围 本标准规定了中国主要木材的名称(中、英名)，树种中名、别名、拉丁名。 本标准适用于木材的科研、教学、木材生产和使用、贸易等部门。 《中国主要进口木材名称》 GB/T18513-2001标准简介本标准为首次发布。本标准共收集世界各国423个(类)木材名称，它们是由1010个树种归纳而来。1010个树种隶366属(针叶树材19属;阔叶树材347属)、84科(针叶树材4科;阔叶树材80科)，基本上包括了世界各国重要商品材树种。 范围 本标准规定了中国主要进口木材的木材名称、树种名称(树种中文名、树种拉丁文名)。 本标准适用于木材生产、贸易、科研及教学等。 《中国主要木材流通商品名称》 WB/T1038-2008标准简介本标准为首次发布。本标准共收集了目前中国市场上流通的主要国内外木材416个树种。按照科学性与实用性相结合的原则，根据树木分类科、属系统归纳成340类(个)。 木材流通商品名称按其所在科、属、种拉丁名字母顺序分级排列，同时介绍了科别、材色及密度和产地。本标准分进口针叶树材、进口阔叶树材和国产针叶树材、国产阔叶树材四部分。 范围 本标准规定了中国主要商品木材的木材名称、树种名称(中文名、拉丁名)、商品名、流通商品名。 本标准适用于木材生产、贸易、科研及教学等。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 问答]]></title>
    <url>%2Fpassages%2Fevent%20loop%20%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[问答 像 V8 这样的 JavaScript 引擎，除了 call stack 和 heap，是否还有一个 callback queue(message queue/task queue)?答：JavaScript 引擎只有一个 call stack 和 一个 heap，callback queue 是由 JavaScript runtime 实现的，比如 Chrome 浏览器或者 NodeJS。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
        <tag>Event loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the V8 engine + 5 tips on how to write optimized code]]></title>
    <url>%2Fpassages%2FInside%20the%20V8%20engine%20%2B%205%20tips%20on%20how%20to%20write%20optimized%20code%2F</url>
    <content type="text"><![CDATA[接上一篇关于 JavaScript 的引擎、运行时、调用栈的技术文章，这篇文章主要集中于 V8 引擎以及写出高性能代码的 5 个小建议。原文链接在这里此外，这里是一篇中文翻译。 The first post of the series focused on providing an overview of the engine, the runtime and the call stack. This second post will be diving into the internal parts of Google’s V8 JavaScript engine. We’ll also provide a few quick tips on how to write better JavaScript code. OverviewA JavaScript engine is a program or an interpreter which executes JavaScript code. A JavaScript engine can be implemented as a standard interpreter, or just-in-time compiler that compiles JavaScript to bytecode in some form. This is a list of popular projects that are implementing a JavaScript engine: V8 — open source, developed by Google, written in C++ Rhino) — managed by the Mozilla Foundation, open source, developed entirely in Java SpiderMonkey — the first JavaScript engine, which back in the days powered Netscape Navigator, and today powers Firefox JavaScriptCore — open source, marketed as Nitro and developed by Apple for Safari KJS) — KDE’s engine originally developed by Harri Porten for the KDE project’s Konqueror web browser Chakra(JScript9)) — Internet Explorer Chakra(JavaScript)) — Microsoft Edge Nashorn) - open source as part of OpenJDK, written by Oracle Java Languages and Tool Group JerryScript — is a lightweight engine for the Internet of Things. Why was the V8 Engine created?The V8 Engine which is built by Google is open source and written in C++. This engine is used inside Google Chrome. Unlike the rest of the engines, however, V8 is also used for the popular Node.js runtime. V8 was first designed to increase the performance of JavaScript execution inside web browsers. In order to obtain speed, V8 translates JavaScript code into more efficient machine code instead of using an interpreter. It compiles JavaScript code into machine code at execution by implementing a JIT (Just-In-Time) compiler like a lot of modern JavaScript engines do such as SpiderMonkey or Rhino (Mozilla). The main difference here is that V8 doesn’t produce bytecode or any intermediate code. V8 used to have two compilersBefore version 5.9 of V8 came out (released earlier this year), the engine used two compilers: full-codegen — a simple and very fast compiler that produced simple and relatively slow machine code. Crankshaft — a more complex (Just-In-Time) optimizing compiler that produced highly-optimized code. The V8 Engine also uses several threads internally: The main thread does what you would expect: fetch your code, compile it and then execute it There’s also a separate thread for compiling, so that the main thread can keep executing while the former is optimizing the code A Profiler thread that will tell the runtime on which methods we spend a lot of time so that Crankshaft can optimize them A few threads to handle Garbage Collector sweeps When first executing the JavaScript code, V8 leverages full-codegen which directly translates the parsed JavaScript into machine code without any transformation. This allows it to start executing machine code very fast. Note that V8 does not use intermediate bytecode representation this way removing the need for an interpreter. When your code has run for some time, the profiler thread has gathered enough data to tell which method should be optimized. Next, Crankshaft optimizations begin in another thread. It translates the JavaScript abstract syntax tree to a high-level static single-assignment (SSA) representation called Hydrogen and tries to optimize that Hydrogen graph. Most optimizations are done at this level. InliningThe first optimization is inlining as much code as possible in advance. Inlining is the process of replacing a call site (the line of code where the function is called) with the body of the called function. This simple step allows following optimizations to be more meaningful. Hidden classJavaScript is a prototype-based language: there are no classes and objects are created using a cloning process. JavaScript is also a dynamic programming language which means that properties can be easily added or removed from an object after its instantiation. Most JavaScript interpreters use dictionary-like structures (hash function based) to store the location of object property values in the memory. This structure makes retrieving the value of a property in JavaScript more computationally expensive than it would be in a non-dynamic programming language like Java or C#. In Java, all of the object properties are determined by a fixed object layout before compilation and cannot be dynamically added or removed at runtime (well, C# has the dynamic type which is another topic). As a result, the values of properties (or pointers to those properties) can be stored as a continuous buffer in the memory with a fixed-offset between each. The length of an offset can easily be determined based on the property type, whereas this is not possible in JavaScript where a property type can change during runtime. Since using dictionaries to find the location of object properties in the memory is very inefficient, V8 uses a different method instead: hidden classes. Hidden classes work similarly to the fixed object layouts (classes) used in languages like Java, except they are created at runtime. Now, let’s see what they actually look like:123456function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2); Once the new Point(1,2) invocation happens, V8 will create a hidden class called C0. No properties have been defined for Point yet, so C0 is empty. Once the first statement this.x = x is executed (inside the Point function), V8 will create a second hidden class called C1 that is based on C0. C1 describes the location in the memory (relative to the object pointer) where the property x can be found. In this case, x is stored at offset 0, which means that when viewing a point object in the memory as a continuous buffer, the first offset will correspond to property x. V8 will also update C0 with a class transition which states that if a property x is added to a point object, the hidden class should switch from C0 to C1. The hidden class for the point object below is now C1. Every time a new property is added to an object, the old hidden class is updated with a transition path to the new hidden class. Hidden class transitions are important because they allow hidden classes to be shared among objects that are created the same way. If two objects share a hidden class and the same property is added to both of them, transitions will ensure that both objects receive the same new hidden class and all the optimized code that comes with it. This process is repeated when the statement this.y = y is executed (again, inside the Point function, after the this.x = x statement). A new hidden class called C2 is created, a class transition is added to C1 stating that if a property y is added to a Point object (that already contains property x) then the hidden class should change to C2, and the point object’s hidden class is updated to C2. Hidden class transitions are dependent on the order in which properties are added to an object. Take a look at the code snippet below:123456789101112function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.b = 7;p2.a = 8; Now, you would assume that for both p1 and p2 the same hidden classes and transitions would be used. Well, not really. For p1, first the property a will be added and then the property b. For p2, however, first b is being assigned, followed by a. Thus, p1 and p2 end up with different hidden classes as a result of the different transition paths. In such cases, it’s much better to initialize dynamic properties in the same order so that the hidden classes can be reused. Inline cachingV8 takes advantage of another technique for optimizing dynamically typed languages called inline caching. Inline caching relies on the observation that repeated calls to the same method tend to occur on the same type of object. An in-depth explanation of inline caching can be found here. We’re going to touch upon the general concept of inline caching (in case you don’t have the time to go through the in-depth explanation above). So how does it work? V8 maintains a cache of the type of objects that were passed as a parameter in recent method calls and uses this information to make an assumption about the type of object that will be passed as a parameter in the future. If V8 is able to make a good assumption about the type of object that will be passed to a method, it can bypass the process of figuring out how to access the object’s properties, and instead, use the stored information from previous lookups to the object’s hidden class. So how are the concepts of hidden classes and inline caching related? Whenever a method is called on a specific object, the V8 engine has to perform a lookup to the hidden class of that object in order to determine the offset for accessing a specific property. After two successful calls of the same method to the same hidden class, V8 omits the hidden class lookup and simply adds the offset of the property to the object pointer itself. For all future calls of that method, the V8 engine assumes that the hidden class hasn’t changed, and jumps directly into the memory address for a specific property using the offsets stored from previous lookups. This greatly increases execution speed. Inline caching is also the reason why it’s so important that objects of the same type share hidden classes. If you create two objects of the same type and with different hidden classes (as we did in the example earlier), V8 won’t be able to use inline caching because even though the two objects are of the same type, their corresponding hidden classes assign different offsets to their properties. The two objects are basically the same but the a and b properties were created in different order. Compilation to machine codeOnce the Hydrogen graph is optimized, Crankshaft lowers it to a lower-level representation called Lithium. Most of the Lithium implementation is architecture-specific. Register allocation happens at this level. In the end, Lithium is compiled into machine code. Then something else happens called OSR: on-stack replacement. Before we started compiling and optimizing an obviously long-running method, we were likely running it. V8 is not going to forget what it just slowly executed to start again with the optimized version. Instead, it will transform all the context we have (stack, registers) so that we can switch to the optimized version in the middle of the execution. This is a very complex task, having in mind that among other optimizations, V8 has inlined the code initially. V8 is not the only engine capable of doing it. There are safeguards called deoptimization to make the opposite transformation and reverts back to the non-optimized code in case an assumption the engine made doesn’t hold true anymore. Garbage collectionFor garbage collection, V8 uses a traditional generational approach of mark-and-sweep to clean the old generation. The marking phase is supposed to stop the JavaScript execution. In order to control GC costs and make the execution more stable, V8 uses incremental marking: instead of walking the whole heap, trying to mark every possible object, it only walk part of the heap, then resumes normal execution. The next GC stop will continue from where the previous heap walk has stopped. This allows for very short pauses during the normal execution. As mentioned before, the sweep phase is handled by separate threads. Ignition and TurboFanWith the release of V8 5.9 earlier in 2017, a new execution pipeline was introduced. This new pipeline achieves even bigger performance improvements and significant memory savings in real-world JavaScript applications. The new execution pipeline is built on top of Ignition, V8’s interpreter, and TurboFan, V8’s newest optimizing compiler. You can check out the blog post from the V8 team about the topic here. Since version 5.9 of V8 came out, full-codegen and Crankshaft (the technologies that have served V8 since 2010) have no longer been used by V8 for JavaScript execution as the V8 team has struggled to keep pace with the new JavaScript language features and the optimizations needed for these features. This means that overall V8 will have much simpler and more maintainable architecture going forward. These improvements are just the start. The new Ignition and TurboFan pipeline pave the way for further optimizations that will boost JavaScript performance and shrink V8’s footprint in both Chrome and Node.js in the coming years. Finally, here are some tips and tricks on how to write well-optimized, better JavaScript. You can easily derive these from the content above, however, here’s a summary for your convenience: How to write optimized JavaScript Order of object properties: always instantiate your object properties in the same order so that hidden classes, and subsequently optimized code, can be shared. Dynamic properties: adding properties to an object after instantiation will force a hidden class change and slow down any methods that were optimized for the previous hidden class. Instead, assign all of an object’s properties in its constructor. Methods: code that executes the same method repeatedly will run faster than code that executes many different methods only once (due to inline caching). Arrays: avoid sparse arrays where keys are not incremental numbers. Sparse arrays which don’t have every element inside them are a hash table. Elements in such arrays are more expensive to access. Also, try to avoid pre-allocating large arrays. It’s better to grow as you go. Finally, don’t delete elements in arrays. It makes the keys sparse. Tagged values: V8 represents objects and numbers with 32 bits. It uses a bit to know if it is an object (flag = 1) or an integer (flag = 0) called SMI (SMall Integer) because of its 31 bits. Then, if a numeric value is bigger than 31 bits, V8 will box the number, turning it into a double and creating a new object to put the number inside. Try to use 31 bit signed numbers whenever possible to avoid the expensive boxing operation into a JS object. Resource https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P--dtDvwXXEeD0/pub https://github.com/thlorenz/v8-perf http://code.google.com/p/v8/wiki/UsingGit http://mrale.ph/v8/resources.html https://www.youtube.com/watch?v=UJPdhx5zTaw https://www.youtube.com/watch?v=hWhMKalEicY]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[an overview of the engine, the runtime, and the call stack]]></title>
    <url>%2Fpassages%2Fan%20overview%20of%20the%20engine%2C%20the%20runtime%2C%20and%20the%20call%20stack%2F</url>
    <content type="text"><![CDATA[转载一篇国外开发者写的技术文章，关于 JavaScript 的引擎、运行时、调用栈。 OverviewAlmost everyone has already heard of the V8 Engine as a concept, and most people know that JavaScript is single-threaded or that it is using a callback queue. In this post, we’ll go through all these concepts in detail and explain how JavaScript actually runs. By knowing these details, you’ll be able to write better, non-blocking apps that are properly leveraging the provided APIs. If you’re relatively new to JavaScript, this blog post will help you understand why JavaScript is so “weird” compared to other languages. And if you’re an experienced JavaScript developer, hopefully, it will give you some fresh insights on how the JavaScript Runtime you’re using every day actually works. The JavaScript EngineA popular example of a JavaScript Engine is Google’s V8 engine. The V8 engine is used inside Chrome and Node.js for example. Here is a very simplified view of what it looks like: The Engine consists of two main components: Memory Heap — this is where the memory allocation happens Call Stack — this is where your stack frames are as your code executes The runtimeThere are APIs in the browser that have been used by almost any JavaScript developer out there (e.g. setTimeout). Those APIs, however, are not provided by the Engine. So, where are they coming from? It turns out that the reality is a bit more complicated. So, we have the Engine but there is actually a lot more. We have those things called Web APIs which are provided by browsers, like the DOM, AJAX, setTimeout and much more. And then, we have the so popular event loop and the callback queue. A runtime environment is the execution environment provided to an application by the operating system. In a runtime environment, the application can send instructions or commands to the processor and access other system resources such as RAM, DISK etc. JS engine, Event queues, Event loop and Web/Dom APIs forms the Runtime Environment. The Call StackJavaScript is a single-threaded programming language, which means it has a single Call Stack. Therefore it can do one thing at a time. The Call Stack is a data structure which records basically where in the program we are. If we step into a function, we put it on the top of the stack. If we return from a function, we pop off the top of the stack. That’s all the stack can do. Let’s see an example. Take a look at the following code:12345678910function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); Running code on a single thread can be quite easy since you don’t have to deal with complicated scenarios that are arising in multi-threaded environments — for example, deadlocks. But running on a single thread is quite limiting as well. Since JavaScript has a single Call Stack, what happens when things are slow? Concurrency &amp; the Event LoopWhat happens when you have function calls in the Call Stack that take a huge amount of time in order to be processed? For example, imagine that you want to do some complex image transformation with JavaScript in the browser. You may ask — why is this even a problem? The problem is that while the Call Stack has functions to execute, the browser can’t actually do anything else — it’s getting blocked. This means that the browser can’t render, it can’t run any other code, it’s just stuck. And this creates problems if you want nice fluid UIs in your app. And that’s not the only problem. Once your browser starts processing so many tasks in the Call Stack, it may stop being responsive for quite a long time. And most browsers take action by raising an error, asking you whether you want to terminate the web page. ow, that’s not the best user experience out there, is it? So, how can we execute heavy code without blocking the UI and making the browser unresponsive? Well, the solution is asynchronous callbacks. This will be explained in greater detail in Part 2 of the “How JavaScript actually works” tutorial: “Inside the V8 engine + 5 tips on how to write optimized code”.]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中的 Event Loop]]></title>
    <url>%2Fpassages%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%20Event%20Loop%2F</url>
    <content type="text"><![CDATA[Event loop 是针对运行时而非引擎首先，我们要弄清楚一点，event loop 是针对 JavaScript runtime environment 的，而非 JavaScript engine。对于 NodeJS 这一 runtime environment 来说，它的 JavaScript engine 是 V8，对于 Chrome 这一 runtime environment 来说，它的 JavaScript engine 是 V8 ；对 Firefox 这一 runtime environment 来说，它的 JavaScript engine 是 SpiderMonkey。event loop 是浏览器和 NodeJS 这两个 JavaScript runtime environment 处理异步的机制，它不属于 JavaScript 引擎的运行机制。另外，浏览器和 NodeJS 的 event loop 是不一样的，这篇文章将集中讨论浏览器这一运行时环境。另外要说明的是，浏览器除了包含 JavaScript runtime environment 之外，还负责 HTML 和 CSS 的解析以及最后渲染图形在屏幕上等工作。 JavaScript Engine负责解析和执行 JavaScript 代码。最开始的时候，JavaScript 的 engine 只是一个解释器，后来以 V8 为代表的现代引擎实现了一种叫做 JIT(just-in-time) 的及时编译技术，拥有更好的性能。 引擎由以下两个主要部分组成： Memory Heap 堆内存，负责内存分配。 Call Stack 调用栈，主要用于记录函数调用的位置。 下图是 Chrome 内的 V8 引擎示意图： JavaScript runtime EnvironmentJavaScript runtime environment 的示意图如下（以 Chrome 为例）： JavaScript Engine - JavaScript 引擎。 Web APIs - 由浏览器提供的 APIs，主要包括 DOM、BOM、AJAX、定时器。 Callback Queue - 回调队列。也叫作 task queue 或者 message queue。 event loop 是 JavaScript runtime 实现异步的一种机制，负责协调调度以上三者。它的工作是不停地查看调用栈和回调队列，一旦调用栈为空，就通知回调队列将下一个回调函数发送到调用栈，等引擎执行完回调函数，它再进行下一轮循环。 为什么需要 event loop?Event loop 的存在，是为了协调事件、用户交互、脚本、UI渲染、网络处理等行为，防止主线程阻塞。注意下面这段话： The event loop, the web APIs and the message queue/task queue are not part of the JavaScript engine, it’s a part of browser’s JavaScript runtime environment or Nodejs JavaScript runtime environment (in case of Nodejs). In Nodejs, the web APIs are replaced by the C/C++ APIs.more ECMAScript 规范主要是写给 JavaScript 这门语言的引擎实现者看的，而引擎的主要工作是解析并执行脚本。所以 event loop 在实现上的标准没有写在 ECMAScript 规范，而是写在 HTML 规范 中，是 Web application APIs 的组成部分，供各大浏览器厂商参考。总而言之，event loop 是 JavaScript runtime environment 对于异步的实现，而非 JavaScript engine。 下面这些都是不属于 JavaScript 语言特性的 Web APIs： setTimeout, setInterval, setImmediate 等定时器，按朴灵的说法，其本质仍然是事件。定时器并不是特例。到达时间点后，会形成一个事件（timeout 事件）。不同的是，一般事件是靠底层系统或者线程池之类的产生事件，但定时器事件是靠事件循环不停检查系统时间来判定是否到达时间点来产生事件。 DOM 网页文档对象模型，主要给 JavaScript 的编程接口。 BOM 浏览器对象模型，主要是一些浏览器的 API。 XMLHttpRequest。 上面提到的这些 APIs，与 DOM 相关的挂载在 document 对象上，与 BOM 相关的挂载在 window 对象上，而 document 对象也被挂载在 window 对象上。另外，属于语言特性的全局属性（包括全局值属性、全局函数属性、全局对象属性）也挂载在 window 对象上，请看下面的代码：123456789// 以下比较都为 truewindow.Infinity === Infinity; // 全局值属性window.parseInt === parseInt; // 全局函数属性window.Array === Array; // 全局对象属性window.setTimeout === setTimeout;window.Promise === window.Promise;window.document === document;window.XMLHttpRequest === XMLHttpRequest;document.location === window.location; Browsing Context即浏览器执行上下文，是一个向用户呈现 Document 对象的环境。通常来说，浏览器的每一个标签页包含一个 browsing context，每一个 &lt;iframe&gt; 标签也包含一个 browsing context。每个 browsing context 具有如下属性： 一个相对应的 WindowProxy 对象。可以理解为一个封装了浏览器全局对象 window 的对象，包含了在浏览器环境执行 JavaScript 代码所需的初始化信息，比如： Infinity, NaN, undefined 等值属性 eval(), isFinite(), isNaN(), parseFloat(), encodeURI() 等函数属性 Array, Date, Object, Function, Error, Promise 等构造器属性 另外，必然还有 DOM 和 setTimeout 等各种 Web API。 一个 opener browsing context 属性，它的值是 null 或者另一个 browsing context。初始值为 null。 一个 disowned 布尔属性，初始值为 false。 一个 is closing 布尔属性，初始值为 false。 一个 session history 属性，可以认为包含的是该标签页的会话历史信息。 每一个 browsing context 都有一个 event loop 在调度各种任务间的协同工作。 详解 Event Loop按照 HTML 规范，Event Loop 有如下 3 种类型： window event loop worker event loop worklet event loop 这里我们主要关注第一种 event loop，即一个浏览器标签页包含一个 event loop 或者一组同源的标签页共享一个 event loop 的情况。下面提到的 event loop 也均指 window event loop。 浏览器的 event loop 至少包含两个队列，macrotask 队列和 microtask 队列。按照 HTML 规范，Event loop 的实现应该至少使用一个队列用于处理 macrotasks，至少一个队列处理 microtasks。Event loop 的实际实现通常分配几个队列用于处理不同类型的 macrotasks 和 microtasks。这使得可以对不同的任务类型进行优先级排序。例如优先考虑一些性能敏感的任务如用户输入。另一方面，因为实际上存在很多 JavaScript 宿主环境，所以有的 event loop 使用一个队列处理这两种任务也不应该感到奇怪。 MacrotaskMacrotasks 包含生成 DOM 对象、解析 HTML、执行主线程 JavaScript 代码、更改当前 URL 还有其他的一些事件如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，macrotask 代表一些离散的独立的工作。当执行完一个 task 后，浏览器可以继续其他的工作如页面重渲染和垃圾回收。 MicrotaskMicrotasks 则是完成一些更新应用程序状态的较小任务，如处理 promise 的回调和 DOM 的修改，这些任务在浏览器重渲染前执行。Microtask 应该以异步的方式尽快执行，其开销比执行一个新的 macrotask 要小。Microtasks 使得我们可以在 UI 重渲染之前执行某些任务，从而避免了不必要的 UI 渲染，这些渲染可能导致显示的应用程序状态不一致。 对于浏览器这个 JavaScript runtime environment 来说，microtask 主要包括以下两项： promise 的回调函数 MutationObserver 的回调函数，DOM 规范指出 step 5 of queuing a mutation record 会将 MutationObserver 的回调函数放置在 microtask 中。 Event Loop TickEvent loop 的每一轮循环称为 tick。如下图所示（图片来自 secrets of javascript ninja 这本书）： 这张图也不错： 如上图所示，在一次 tick 中，event loop 首先检查 macrotask 队列，如果有一个 macrotask 等待执行，那么执行该任务。当该任务执行完毕后（或者 macrotask 队列为空），event loop 继续执行 microtask 队列。如果 microtask 队列有等待执行的任务，那么event loop 就一直取出任务执行直到 microtask 队列为空。这里我们注意到处理 microtask 和 macrotask 的不同之处：在一次 tick 中，一次最多处理一个 macrotask （其他的仍然驻留在队列中），然而会一次性处理完所有的 microtask 直至 microtask 队列为空。 紧接着，当执行完所有 microtask 即 microtask 队列为空时，event loop 检查是否需要执行 UI 重渲染，如果需要则重渲染 UI。这样就结束了当次循环，继续从头开始检查 macrotask 队列。 上图还包含了一些细节： 两个任务队列都放置在 event loop 外，这表明将任务添加和任务处理行为分离。在 event loop 内负责执行任务（并从队列里删除），而在 event loop 外添加任务。如果不是这样，那么在 event loop 里执行代码时，发生的任何事件都被忽略，这显然不是我们想要的，因此我们将添加任务的行为和 event loop 分开进行。 两种类型的任务同时只能执行一个，因为 JavaScript 基于单线程执行模型。任务一直执行到完成而不能被其他任务中断，这一特性叫做 run-to-completion。只有浏览器才能停止任务的执行；例如如果某个任务消耗了太多的内存和时间的话，浏览器可以中断其执行。 所有的 microtasks 都应该在下次渲染前执行完，因为其目的就是在渲染前更新应用状态。 浏览器通常每秒尝试渲染页面 60 次，以达到每秒 60 帧（60 fps），这个帧速率通常被认为是平滑运动的理想选择。这意味着浏览器尝试每 16ms 渲染一帧。上图中update rendering操作在 event loop 中进行，这是因为在呈现页面时，页面内容不应该被另一个任务修改。这意味着如果我们想要实现平滑的 UI 效果，单个 event loop 中不能占据太多时间。单个任务和由该任务生成的所有 microtasks 应该在 16 毫秒内完成。 当浏览器完成页面渲染后，event loop 的下一次 tick 中可能发生三种情况： event loop 在另一个 16ms 之前执行的 is rendering needed 的判断处。因为更新UI是一个复杂的操作，如果没有明确要求渲染页面，浏览器可能在本次迭代中不执行 UI 渲染。 event loop 在上次渲染后约 16ms 处达到 Is rendering needed 判断处。在这种情况下，浏览器更新 UI，用户会认为应用比较流畅。 执行下次任务（及其所有相关的 microtask）花费时间大大超过 16ms。这样浏览器将无法按照目标的帧速率重新渲染页面，UI 也将不会更新。如果运行任务代码不占用太多时间（超过几百毫秒），这种延迟甚至可能感知不到，尤其是对于没有太多动画的页面。另一方面，如果我们花费太多时间，或者页面中含有动画，用户可能认为网页缓慢和没有响应。在最坏的情况下，如果任务执行超过几秒钟，用户的浏览器会显示无响应脚本消息。 处理事件时应注意其发生的频率和处理所需时间。如在处理鼠标移动事件时应该格外小心。移动鼠标会导致大量的事件排队，因此在该鼠标移动处理程序中执行任何复杂的操作都可能导致应用变得很不流畅。 Task Queue (Callback Queue / Message Queue)根据 HTML 规范，event loop 具有一个或多个 task queue，即任务队列。任务队列是一个有序的任务列表，这些任务是指负责以下工作的算法： 事件 解析 HTML 回调 获取网络资源 对 DOM 操作作出反应 每个任务都被定义为来自特定的任务源。来自同一个任务源的所有任务（例如，由文档的定时器生成的回调、由鼠标在文档上移动而触发的事件、为该文档的解析器排队的任务）必须始终添加到同一任务队列中，但是来自不同任务源的任务可以被放置在不同的任务队列中。 Generic task sources以下任务源被本规范和其他规范中许多几乎不相关的特性使用： DOM 操作任务源此任务源用于对 DOM 操作做出反应的功能，例如在将元素插入文档时以非阻塞方式发生的事件。 用户交互任务源此任务源用于对用户交互做出反应的功能，例如键盘或鼠标输入。响应用户输入而发送的事件(例如点击事件)必须使用在用户交互任务源中排队的任务来触发。 网络任务源此任务源用于响应网络活动而触发的功能。 历史遍历任务源这个任务源是用来对 history.back() 及类似的 API 进行排队。 浏览器的异步处理模型目前在网络上找到的一些中文资料无法完全说服自己，而 HTML 规范主要给出的是详实严谨的算法，所以试着按照自己的理解梳理下：通常情况下，每一个浏览器的标签页都有一个独立的 browsing context。这个 browsing context： 有一个 execution context stack 执行上下文栈 至少有一个而且通常只有一个与之关联的 event loop。 而这里 event loop 有一个 microtask queue 和至少一个 task queue。当一个浏览器标签页加载时，通常是做以下几件事情（按照 HTML 规范是 task 任务）： 解析 HTML 当遇到 &lt;script src=&#39;...&#39;&gt;, &lt;link&gt;, &lt;img&gt; 等标签时发起网络请求。如果有 defer 属性浏览器则会并行发起网络请求，并在 HTML 解析完毕后执行脚本；如果有 async 属性浏览器则会并行发起网络请求，在脚本资源加载完成后执行。 当遇到内嵌的 script 脚本时，执行脚本内的代码，即将脚本内的代码会形成若干执行上下文，被压入执行上下文栈 渲染 UI 这里需要注意的是，script 脚本内执行的诸如 setTimeout 定时器的回调、通过 XMLHttpRequest 发起的异步网络请求、onclick 等事件触发的回调、通过脚本动态操作 DOM 等，这些操作或者说任务，实际上与上面提到的 task 任务是平行的。也就是说，我们写在 script 标签内的 author code，如果里面包含 setTimoutout 等非 JavaScript 语言特性的代码，JavaScript 引擎会调用外部的 Web APIs，将这些任务放置到 task queue 中。根据 HTML 规范，一个浏览器标签页至少有一个 task queue；而遇到 Promise 或者 MutationObserver，则浏览器会将其放置到 miscrotask queue 中。 简而言之，对于浏览器来说，event loop 这种机制，将 JavaScript 引擎的执行上下文栈（也叫 call stack 调用栈）、Web APIs、task queue 这三者进行协调。下面是一个浏览器的 event loop 的示意简图： Event loop 实例推荐使用文章末尾参考链接给出的两个将 event loop 在线可视化工具，非常赞。下面的一组图片清晰的展示了如下代码在浏览器的 JavaScript runtime 中是如何运行的（可点击图片以幻灯片形式查看）：1234567console.log("Hi");setTimeout(function() &#123; console.log("there");&#125;, 5000);console.log("Designvelopers"); 初始状态： 执行 console.log(&quot;Hi&quot;);，在控制台打出 Hi 后，该函数的调用帧（执行上下文）从调用栈中弹出。另外，这里的 main() 函数模拟一个 .js 文件的全局调用帧： 执行 setTimeout(...)，调用 Web APIs 中针对 setTimeout() 的接口，开始比对系统时间与定时器设置的延迟时间。接着 setTimeout(...) 从调用栈中弹出。 执行 console.log(&quot;Designvelopers&quot;);，在控制台打出 Designvelopers 后，该函数的调用帧从调用栈中弹出。与此同时，Web APIs 仍在另一个线程中比对时间，显然这时还没有到达定时器所设置的 5 秒延迟时间。 脚本的同步代码都已经执行完，此时调用栈为空。当到达定时器设置的时间后，Web APIs 将定时器的回调函数放入回调队列中排队。 此时调用栈为空，并且回调队列中只有定时器回调函数这一个任务，直接取出定时器回调在调用栈中执行，形成两个调用帧： 执行完 console.log(&quot;there&quot;); 后，该函数的调用帧从调用栈弹出： 定时器的回调函数只有一行代码，所以紧接着，回调函数的调用帧也从调用栈弹出： 完毕。 性能优化从性能优化的角度出发，压倒一切的指导方针是，以下几种情况必须并行执行，否则可能会导致阻塞 event loop，这包括但不限于： 执行繁重的计算； 显示面向用户的提示； 执行可能需要外部系统参与的操作(即退出流程)。 参考链接和外部资料 菲利普·罗伯茨：到底什么是 Event Loop 呢？ | 欧洲 JSConf 2014youtube 上面关于 event loop 播放量最高的一个视频，对 event loop 讲解非常清晰（因为是 2014 年发布的，所以没有涉及到 miscrotask），更可贵的是作者针对这一机制做了可视化。下面的链接是一个将 event loop 可视化的在线网站。 Event loop 在线可视化工具 Jake Archibald: In The Loop - JSConf.Asia 20182018 年发布的有关浏览器的 event loop 机制的视频，涉及到了 miscrotask。作者是一名来自 Google 的开发者。下一个链接也是他的文章。 tasks-microtasks-queues-and-schedules作者是一名来自 Google 的开发者，这篇文章里包含了可视化 event loop 机制的工具，很赞。 The JavaScript Event Loop - Concurrency in the Language of the Web使用 Google 办公套件的 PPT 描述的 event loop，讲述了 JavaScript 这门单线程语言是如何处理异步的。里面有两张对 event loop 的图解，非常赞。 All you need to know about the JavaScript event loop一组关于 Event Loop 的幻灯片 the-javascript-event-loop-explained/写于 2013 年对 event loop 的解释。 how-browsers-work发布于 2011 年 8 月 5 日的一篇深度好文，作者是一名以色列开发者，用了几年收集整理有关浏览器内部原理的资料，同时阅读了非常多的浏览器源码，最终形成了这篇文章，详细讲述了以 Chrome 为主的浏览器的工作原理，你在网络看到绝大多数有关浏览器原理的文章和图片可能都是取材于这篇文章的。 understanding-asynchronous-javascript-the-event-loop 重新认识 script 标签 - HTML specification HTML specification HTML draft Event Loop - MDN JavaScript 中的事件循环 Event Loop JavaScript 运行机制详解：再谈 Event Loop - 阮一峰 【朴灵评注】JavaScript 运行机制详解：再谈Event Loop HTML系列：macrotask和microtask - 知乎专栏]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
        <tag>浏览器原理</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 规范阅读笔记之全局对象]]></title>
    <url>%2Fpassages%2FECMAScript%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ECMAScript 规范中全局对象的阅读笔记。 根据 ECMAScript 的规范，全局对象： 在代码控制流进入任何执行上下文之前，它会被创建。 它没有构造器 [[Constructor]] 这个内部方法；所以不能用 new 操作符创建全局对象的实例。 它没有调用 [[Call]] 这个内部方法；所以不能作为函数调用。 它有一个 [[Prototype]] 内部插槽，其值与各种实现有关。 除了本规范定义的属性，可能还有基于宿主环境定义的属性。 值属性 Infinity NaN undefined 函数属性 eval() isFinite() isNaN() parseFloat() parseInt() URI 专用处理函数 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 构造器属性 Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Init8Array Init16Array Init32rray Map Number Object Promise Proxy RangeError ReferenceError RegExp Set SharedArrayBuffer String Symbol SyntaxError TypeError Uinit8Array Uinit8ClampedArray Uinit16Array Uinit32Array URIError WeakMap WeakSet 其他属性 JSON Math Reflect]]></content>
      <tags>
        <tag>ECMAScript specification</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习资源索引]]></title>
    <url>%2Fpassages%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[这篇文章的目的是为了给自己更清晰地罗列出优秀的前端学习资源，以备日后需要时随时参考。 规范最原始、权威的第一手资料，内容非常详细、严谨。 ECMAScript specification HTML draft HTML specification DOM specification CSSOM specification W3C standards The WHATWG specification index. 权威速查手册适合想要了解某个属性或者方法的详细信息时使用。 Mozilla manual 第三方教程 The Modern JavaScript Tutorial ES6 入门教程 - 阮一峰]]></content>
      <tags>
        <tag>学习资源</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闪电计划]]></title>
    <url>%2Fpassages%2F%E9%97%AA%E7%94%B5%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[为了自身的健康，为了买了个表，我决定开启这项闪电计划，目标只有一个：通过科学合理的方式，将体重从目前的 78 Kg 减轻到 73 Kg。 措施措施主要分两个部分：控制饮食和持续运动。 控制饮食 早餐以燕麦搭配牛奶为主 严格控制晚餐的食物摄入量，一碗饭 晚饭后刷牙，之后除了喝水不吃任何东西 除少量水果外，不吃任何零食 不喝除牛奶、酸奶、咖啡之外的任何饮料 持续运动 工间休息 开合跳 蹲下起立 晚上的运动 热身：平板支撑 有氧运动：跳绳 无氧运动：俯卧撑 战利品华为运动手表]]></content>
      <tags>
        <tag>健身</tag>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：异步编程]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为什么需要异步编程？在我们的程序中，类似下面这样的代码，是由计算机的处理器一次性执行完毕的。代码的运行速度也很大程度上取决于计算机处理器的速度。1234567891011const sumTo = function(n) &#123; let sum = 0; for (let i = 0; i &lt;= n; i++) &#123; sum += i; &#125; return sum;&#125;;sumTo(10000); 但是，还有很多其他程序需要在处理器外面与其他设备交互。比如，有些程序可能需要通过计算机网络进行通信，或者从硬盘读取数据，而这些都比从内存读取代码慢得多了。 当这样的情形发生时，让处理器处于空闲状态是非常浪费资源的，因为可能有不少其他工作需要处理器在这时来处理。某种程度上来说，这取决于你的操作系统，它会切换处理器运行多个不同的程序。但是，当我们在运行单个程序，遇到等待网络请求的情形时，我们没法让处理器去做其他事情。 在同步编程的模型里，事情一件接着一件地执行。当调用一个性能开销很大的函数时，只有当函数内的操作都完成了才会返回。在这个函数运行期间，程序只能原地待命。 异步编程的模型允许多个事情在同一时间发生。当我们开始一项任务（比如从硬盘读取数据），我们的程序可以继续运行。当这个任务完成时，程序会通知我们并返回一个结果。 我们可以用一个小例子来对比同步编程和异步编程：一个程序从网络获取两个资源文件然后组合成需要的结果。 在一个同步的环境里，只有当网络请求全部完成时，请求函数才会返回。执行上面那个例子的最简单方式就是：一个接一个地发出网络请求。这样做的缺点是：第二个网络请求只有在第一个网络请求全部完成时才会开始。那么，完成上述例子的时间将是至少两项网络请求所需时间之和。12345// 先请求第一个资源文件request(resourceOne);// 当上面的网络请求完成，才会继续执行第二个网络请求request(resourceTwo); 针对这类问题的解决方式，在一个同步的环境里就是增加额外的线程。线程是指另一个运行中的程序，它的执行可能通过操作系统与另外的程序交织在一起。鉴于大多数现代计算机都包含多个核心的处理器，多个线程可能同时由不同的处理器核心来运行。对于上面的小例子来说，增加的第二个线程可以用来发起第二个网络请求，接着让两个线程都等待返回的结构，然后两个线程实现同步，再组合成需要的结果。 两个重量级的 JavaScript 平台，浏览器和 NodeJS 都需要进行一些费时的异步操作，而不是依赖于多线程。鉴于多线程编程是众所周知的难，所以这通常被认为是个好事情。 回调 Callback异步编程的其中一种方式是：当函数执行耗时较长的操作时，增加一个额外的参数，即回调函数。当这个耗时的操作开始，等待它结束并返回一个结果时，回调函数以这个结果为参数被调用。 举个例子，在 NodeJS 和浏览器环境中都已实现的 setTimeout 函数，等待一段时间（以毫秒为单位）后再调用回调函数。1setTimeout(() =&gt; console.log("Tick"), 500); 回调实例：加载脚本一个典型的用例：动态加载一个脚本，并在脚本加载完成后使用该脚本。在浏览器的 Web API 中，像 Window，XMLHttpRequest，&lt;script&gt;，&lt;img&gt; 等元素都部署了 onload 事件处理接口，当资源加载完成后被触发。这里以加载 &lt;script&gt; 元素的资源为例：12345678910111213141516171819202122const loadScript = function(src, callback) &#123; const script = document.createElement("script"); // 执行这一行代码，浏览器会发起网络请求获取脚本资源 script.src = src; // 资源加载成功时执行 script.onload = () =&gt; callback(null, script); // 资源加载失败时执行 script.onerror = () =&gt; callback(new Error(`Script load error for $&#123;src&#125;`)); document.head.appendChild(script);&#125;;// 使用loadScript("/my/script.js", (error, script) =&gt; &#123; // “错误优先”风格的回调， 在 NodeJS 生态中被广泛使用 if (error) &#123; // 处理错误 &#125; else &#123; // 脚本加载成功 &#125;&#125;) 回调地狱有的时候，我们需要按照一定的顺序来执行一连串的异步任务。如果使用回调函数的方式来处理，就会形成嵌套的异步任务。假设我们现在要依次获取 3 个脚本资源，那么就会形成下面这样的代码：12345678910111213141516171819202122232425loadScript("one.js", (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; one(); // 继续获取第 2 个脚本 loadScript("two.js", (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; two(); // 继续获取第 3 个脚本 loadScript("three.js", (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; three(); // 获取到所有脚本资源 // ... &#125; &#125;) &#125; &#125;) &#125;&#125;) 上面的代码即构成了回调金字塔，或者称回调地狱。这样的代码不仅不易阅读，后续维护成本也高。 Promise为了解决回调地狱，Promise 诞生了。一个 Promise 的实例，是一个代表着最终会完成或者失败的异步操作的对象。新建一个 Promise 实例的语法如下：123const promise = new Promise((resolve, reject) =&gt; &#123; // executor&#125;); 上面这种新建 Promise 实例的方式，通常只会在封装基于回调处理异步操作的陈旧代码时用到（绝大部分时候，我们是 Promise 实例的使用者）。后面会给出详细例子。 executor传递给 new Promise 的参数是一个叫做 executor 的函数，它会在 promise 被创建的时候自动立即执行。executor 函数接受 2 个参数，resolve 函数 和 reject 函数，它们是由引擎预定义的，我们不必创建它们。我们应当在执行成功时调用 resolve 函数，执行失败时调用 reject 函数。 创建的 Promise 实例具备 2 个内部属性： state 初始值为 pending，之后会转变为 fulfilled 或者 rejected。 result 初始值为 undefined，之后会转变为结果或者错误对象 不可逆过程每个 Promise 实例可能的状态有 3 种：初始状态 pending，完成状态 fulfilled 和 rejected。即一个 Promise 实例要么由 pending 变成 fulfilled，要么由 pending 变成 rejected，并且此过程不可逆，一旦到了完成状态就无法改变。如下图所示： resolve 实例1234const promise = new Promise((resolve, reject) =&gt; &#123; // 模拟一项任务，1 秒后完成，成功并返回结果 "done" setTimeout(() =&gt; resolve("done"), 1000);&#125;); reject 实例1234const promise = new Promise((resolve, reject) =&gt; &#123; // 模拟一项任务，1 秒后完成，失败并返回错误对象 setTimeout(() =&gt; reject(new Error("error occurs")), 1000);&#125;); resolve 与 reject 注意事项resolve 函数或者 reject 函数其中任意一个只会被调用一次，后续的调用都将会忽略：123456const promise = new Promise((resolve, reject) =&gt; &#123; resolve("done"); reject(new Error("…")); // 忽略，不会执行 setTimeout(() =&gt; resolve("…")); // 忽略，不会执行&#125;); resolve 函数或者 reject 函数都只接受一个参数，多余的参数将会忽略。 then本质上，Promise 做的事情是，将一项耗费时间的任务（我们传入的 executor 函数）自动立即执行，然后在任务完成后将这项任务的结果保存到内部属性 result。这个结果可能是我们传入 resolve 函数的任意值，也可能是我们传入 reject 函数的错误对象。并且这个结果一旦形成就不会再改变。 我们可以通过 Promise 实例的 then 方法来获取结果。它可能被成功解决，返回一个结果：12345678const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve("done!"), 1000);&#125;);promise.then( result =&gt; alert(result), // shows "done!" after 1 second error =&gt; alert(error) // doesn't run); 也可能失败，返回错误对象：123456789const promise = new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; reject(new Error("Whoops!")), 1000);&#125;);// reject runs the second function in .thenpromise.then( result =&gt; alert(result), // doesn't run error =&gt; alert(error) // shows "Error: Whoops!" after 1 second); 链式调用Promise 的 then 方法支持链式调用。注意下面代码中 then 方法内的返回值。123456789101112new Promise(resolve =&gt; &#123; resolve(1);&#125;).then(result =&gt; &#123; console.log(result); // 1 return result * 2; // 返回一个基本数据类型的值&#125;).then(result =&gt; &#123; console.log(result); // 2 return new Promise(resolve =&gt; resolve(100)); // 返回一个 Promise 的实例&#125;).then(result =&gt; &#123; console.log(result); // 100 return &#123; a: 1 &#125;; // 返回一个对象&#125;).then(result =&gt; console.log(result); // &#123; a: 1 &#125; thenable事实上，then 方法只要返回一个部署了 then 方法的任意对象，引擎就会将它当做 Promise 的实例来看待。第三方库可以利用这一点来兼容原生的 Promise。12345678910111213141516class Thenable &#123; constructor(num) &#123; this.num = num; &#125; then(resolve, reject) &#123; alert(resolve); // function() &#123; native code &#125; // resolve with this.num*2 after the 1 second setTimeout(() =&gt; resolve(this.num * 2), 1000); // (**) &#125;&#125;new Promise(resolve =&gt; resolve(1)) .then(result =&gt; &#123; return new Thenable(result); // (*) &#125;) .then(alert); // shows 2 after 1000ms catch本质上是基于 then 实现的，只不过专注于错误处理。由于链式调用 then 方法可以传递结果和错误，所以最佳实践通常是这样：123456789new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve("done"), 1000);&#125;).then(result =&gt; &#123; // ....&#125;).then(result =&gt; &#123; // ...&#125;).catch(error =&gt; &#123; // 最后统一处理错误&#125;) finally与 try...catch...finally 类似，主要用于做一些清理扫尾的工作，略。 Promise 实例：加载脚本使用 Promise 改写上面使用回调实现的加载脚本实例：123456789101112131415161718192021const loadScript = function (src) &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement("script"); script.src = src; script.onload = () =&gt; resolve(script); script.onerror = () =&gt; reject(new Error(`error when load script for $&#123;src&#125;`)); document.head.appendChild(script); &#125;)&#125;;// 使用const promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");promise.then( script =&gt; alert(`$&#123;script.src&#125; is loaded!`), error =&gt; alert(`Error: $&#123;error.message&#125;`));promise.then(script =&gt; alert("One more handler to do something else!")); Promise 串行加载资源链式调用 Promise 实例的 then 方法可以规避上面提到的回调地狱。使用 Promise 改写上面的按照顺序获取脚本资源的例子：123456789101112131415// 串行获取资源loadScript("one.js") .then(script =&gt; &#123; one(); return loadScript("two.js"); &#125;) .then(script =&gt; &#123; two(); return loadScript("three.js"); &#125;) .then(script =&gt; &#123; three(); // 获取到了全部脚本 // ... &#125;); 串行执行异步操作可以改写成更聪明简洁的写法：1234567const asyncFn1 = x =&gt; x + 1;const asyncFn2 = x =&gt; x + 10;const asyncFn3 = x =&gt; x + 100;const asyncs = [asyncFn1, asyncFn2, asyncFn3];asyncs.reduce((p, f) =&gt; p.then(f), Promise.resolve(1)) .then(result3 =&gt; console.log("result3:", result3)); // result3: 112 上面的代码等同于：1Promise.resolve(1).then(asyncFn1).then(asyncFn2).then(asyncFn3)。 还可以进一步抽象出一个组合函数，这个组合函数以一组函数为参数，按照参数的顺序依次执行，上一个函数的输出结果作为下一个函数的输入参数。这通常被使用在函数式编程中：1234567const applyAsync = (acc, val) =&gt; acc.then(val);// 尝试从该函数的调用者的角度去思考，更易读懂下面这行代码const composeAsync = (...funcs) =&gt; x =&gt; funcs.reduce(applyAsync, Promise.resolve(x));// 使用const transformData = composeAsync(fn1, fn2, fn3);const result3 = transformData(data); Promise 实例：fetchPromise 通常被用于网络请求。这里我们以 fetch 方法为例，从远程服务器获取用户数据 user.json。fetch 方法的基本用法如下：1const promise = fetch(url); // 返回一个 Promise 的实例 详细的例子如下：12345678910fetch("https://javascript.info/article/promise-chaining/user.json") // 下面的 then 方法在服务器响应时执行 .then(response =&gt; &#123; // 当我们接收到服务器发送的全部响应信息，response.text() 返回一个包含全部响应结果的新的 Promise 实例 return response.text(); &#125;) .then(text =&gt; &#123; // text 即是服务器发送过来的响应内容 alert(text); // &#123;"name": "iliakan", isAdmin: true&#125; &#125;); response 还有一个 response.json() 方法，它会读取服务器的响应内容并将之解析为 JSON。很多时候使用它来代替 response.text() 会更加方便：123fetch("https://javascript.info/article/promise-chaining/user.json") .then(response =&gt; response.json()) .then(user =&gt; alert(user.name)); // iliakan 接着让我们进一步扩展上面的例子，比如使用获取的用户数据做点什么。这里我们用获取到的用户名，查询该用户的 GitHub 信息，然后在网页上显示用户的头像：123456789101112fetch("https://javascript.info/article/promise-chaining/user.json") .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/user/$&#123;user.name&#125;`)) .then(response =&gt; response.json()) // 用户的头像地址在 githubUser.avatar_url .then(githubUser =&gt; &#123; const img = document.createElement("img"); img.src = githubUser.avatar_url; document.body.append(img); setTimeout(() =&gt; img.remove(), 3000); // (*) &#125;) 注意到上面代码中 (*) 这一行，用户头像显示 3 秒后将被移除。为了让代码更具有扩展性，即可以继续往下链式调用，同时传递数据，我们可以让第 4 个 then 方法返回一个新的 Promise 实例：12345678910111213141516fetch("https://javascript.info/article/promise-chaining/user.json") .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/users/$&#123;user.name&#125;`)) .then(response =&gt; response.json()) .then(githubUser =&gt; new Promise((resolve, reject) =&gt; &#123; // (*) const img = document.createElement("img"); img.src = githubUser.avatar_url; document.body.append(img); setTimeout(() =&gt; &#123; // 先移除头像 img.remove(); // 接着往下链式传递之前的数据 resolve(githubUser); // (*) &#125;, 3000) &#125;)) 通常来说，最好让每一个异步操作都返回 Promise 的实例，这样的代码更具扩展性，即使我们现在不需要继续往下链式调用，可能将来会用到。最后，让我们优化上面的代码，将部分代码抽象成可复用的函数：123456789101112131415161718192021222324252627282930313233const loadJson = function(url) &#123; return fetch(url).then(response =&gt; response.json());&#125;;const loadGithubUser(name) &#123; return fetch(`https://api.github.com/users$&#123;name&#125;`).then(response =&gt; response.json());&#125;;const showAvatar(githubUser) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = document.createElement("img"); img.src = githubUser.avatar_url; img.onload = () =&gt; &#123; // 图片加载完成 3 秒后移除图片，并继续往下链式传递该 GitHub 用户数据 setTimeout(() =&gt; &#123; img.remove(); resolve(githubUser); &#125;, 3000); &#125;; document.body.append(img); &#125;)&#125;;// 使用loadJson("https://javascript.info/article/promise-chaining/user.json") .then(user =&gt; loadGithubUser(user.name)) .then(githubUser =&gt; showAvatar(githubUser)) // 可简写为 .then(showAvatar) .then(githubUser =&gt; new Promise(resolve =&gt; &#123; console.log(`Finished showing $&#123;githubUser.name&#125;`); resolve(githubUser); &#125;)); Promise 错误处理Promise 实例的错误可以沿着 then 方法往下链式传递，所以最佳实践通常是在最后统一处理错误，以上面的例子为例可以这样做：12345678loadJson("https://javascript.info/article/promise-chaining/user.json") .then(user =&gt; loadGithubUser(user.name)) .then(githubUser =&gt; showAvatar(githubUser)) // 可简写为 .then(showAvatar) .then(githubUser =&gt; new Promise(resolve =&gt; &#123; console.log(`Finished showing $&#123;githubUser.name&#125;`); resolve(githubUser); &#125;)) .catch(error =&gt; console.log(error.message)); 隐式的 try...catchPromise 实例的 executor 函数和 then 函数内都存在一个隐式的 try...catch。即如果出现错误，后续 .catch 会自动捕获所有错误：123new Promise((resolve, reject) =&gt; &#123; throw new Error("Whoops!");&#125;).catch(alert); // Error: Whoops! 实际上相当于以下代码：123new Promise((resolve, reject) =&gt; &#123; reject(new Error("Whoops!"));&#125;).catch(alert); // Error: Whoops! 在 then 方法内抛出错误，也是一样，会被传递到最近的 .catch：12345new Promise((resolve, reject) =&gt; &#123; resolve("ok");&#125;).then((result) =&gt; &#123; throw new Error("Whoops!"); // rejects the promise&#125;).catch(alert); // Error: Whoops! 不仅是抛出的错误，对于所有错误也是如此：12345new Promise((resolve, reject) =&gt; &#123; resolve("ok");&#125;).then((result) =&gt; &#123; blabla(); // no such function&#125;).catch(alert); // ReferenceError: blabla is not defined 实例以上面的 fetch 方法请求用户数据为例，类似下面的错误处理方式，效果依然很不理想：123456fetch("no-such-user.json") // (*) .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/users/$&#123;user.name&#125;`)) // (**) .then(response =&gt; response.json()) .catch(alert); // SyntaxError: Unexpected token &lt; in JSON at position 0 // ... 最后的 .catch 方法捕获的错误非常宽泛，无法直观的看出究竟是哪里出了错误，以及进一步的错误信息。对于上面的代码而言，可能有如下错误： 请求 no-such-user.json数据，服务器返回的响应是一个 404 或者 500 的错误提示页面。 成功拿到用户数据，但是请求 GitHub 用户信息接口的时候，返回的响应是一个 404 或者 500 的错误提示页面。 我们可以增加一个步骤，检查 response.status 代表的 HTTP 状态码是否为 200。如果不是则抛出一个定制的 HttpError 错误：1234567891011121314151617class HttpError extends Error &#123; constructor(response) &#123; super(`$&#123;response.status&#125; for $&#123;response.url&#125;`); this.name = "HttpError"; this.response = response; &#125;&#125;fetch(".../no-such-user.json") .then(response =&gt; &#123; if (response.status === 200) &#123; return response.json(); &#125; else &#123; throw new HttpError(response); &#125; &#125;) .catch(err =&gt; console.log(err)); // 404 for .../no-such-user.json 再看一个针对特定错误进行处理的例子：12345678910111213141516171819const demoGithubUser = function () &#123; let name = prompt("Enter a name?", "iliakan"); return loadJson(`https://api.github.com/users/$&#123;name&#125;`) .then(user =&gt; &#123; alert(`Full name: $&#123;user.name&#125;.`); return user; &#125;) .catch(err =&gt; &#123; if (err instanceof HttpError &amp;&amp; err.response.status == 404) &#123; // (*) alert("No such user, please reenter."); return demoGithubUser(); &#125; else &#123; throw err; // (*) &#125; &#125;);&#125;demoGithubUser(); 上面的代码，注意 (*) 这一行，当没有查询到对应名字的 GitHub 用户时，弹出没有此用户的信息并让用户重新输入有效的 GitHub 用户名。而对于其他错误，重新抛出。 unhandled rejections对于 Promise 内未处理的错误，比如 catch 重新抛出的错误，或者根本没有 catch 方法，大多数引擎都会追踪到这些未处理错误，并创建一个全局的错误。对于浏览器环境而言，我们可以通过监听全局事件 unhandledrejection 来访问错误并作出处理。NodeJS 环境也有类似的机制离开处理未处理的 Promise 错误。12345678window.addEventListener("unhandledrejection", event =&gt; &#123; alert(event.promise); // [object Promise] - the promise that generated the error alert(event.reason); // Error: Whoops! - the unhandled error object&#125;);new Promise(resolve =&gt; &#123; throw new Error("whoops");&#125;) Promise 静态方法Promise 一共有以下 4 个静态方法： Promise.resolve Promise.reject Promise.all Promise.race Promise.resolve主要使用场景：将一个值封装为 Promise 的实例。举例，下面的代码实现的功能是：假如某个 url 的资源之前已经获取过，可以通过 then 方法直接返回资源。12345678910111213141516171819const loadCached = function (url) &#123; const cache = loadCached.cache || (loadCached.cache = new Map()); if (cache.has(url)) &#123; // 封装缓存结果，保证返回的是 Promise 实例 return Promise.resolve(cache.get(url)); &#125; return fetch(url) .then(response =&gt; response.text()) .then(result =&gt; &#123; cache.set(url, result); return result; &#125;);&#125;;// 使用loadCached("https://example.com/user.json") .then(result =&gt; /* do something with result */) Promise.reject用于创建包含错误对象的 Promise 实例，很少用到。 Promise.all并发执行异步操作，会等待所有异步任务完成，返回的结果是由各项异步任务返回结果组成的数组；如果其中任意一个异步任务出错，直接返回错误作为最终结果，其他异步任务的结果将被忽略。基本用法：12Promise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) =&gt; &#123; /* use result1, result2 and result3 */ &#125;); 考虑如下代码：123456Promise.all([ new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)), // 3 4, // 被自动封装为 Promise.resolve(4)]).then(alert); // 3 秒后，返回的结果是 [1, 2, 3, 4] then 方法返回的结果是一个数组，数组成员为传入 Promise.all 的 Promise 实例 resolve 的结果，顺序也与 Promise.all 的参数顺序一致，而与异步操作的时间无关。 一个常用的技巧是，将一组任务的数据映射为一个成员为 Promise 实例的数组，然后使用 Promise.all 来并发执行异步任务：12345678910111213141516let urls = [ 'https://api.github.com/users/iliakan', 'https://api.github.com/users/remy', 'https://api.github.com/users/jeresig'];// 映射为 Promise 实例const requests = urls.map(url =&gt; fetch(url));// 等待所有异步操作完成// 如果其中有一个异步操作失败，将立即返回对应的错误对象Promise.all(requests) .then(responses =&gt; &#123; responses.forEach(response =&gt; alert(`$&#123;response.url&#125;:$&#123;response.status&#125;`)); return responses; &#125;); 实现容错的并发异步任务Promise.all 方法本身不具备容错性，即一旦有一个异步任务错误便立即返回错误信息。但是，有时候我们希望的结果是这样的：返回一个数组，包含处理成功的异步任务结果和处理失败的异步任务的错误信息。为了实现这一点，需要使用 catch 捕获错误，让错误不被抛出，同时让错误继续往下传递：123456789101112const urls = [ 'https://api.github.com/users/iliakan', 'https://api.github.com/users/remy', 'http://no-such-url'];Promise.all(urls.map(url =&gt; fetch(url).catch(error =&gt; error))) .then(responses =&gt; &#123; // 返回结果的数组包含以下 3 项 // [object Response], [object Response], TypeError: Failed to fetch responses.forEach(response =&gt; alert(response)); &#125;); Promise.race与 Promise.all 类似，不同点在于，Promise.race 不会等待所有异步任务完成，而是只要其中一个完成或者出错，就立即返回处理结果或者错误对象，忽略掉后续的结果或者错误。这点与它的名字 race （赛跑）相契合。12345Promise.race([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error("Whoops!")), 2000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))]).then(alert); // 1 Promisify一些第三方库的遗留代码仍然使用基于回调的方式处理异步，而 Promise 更加方便好用，所以需要一种方式，将接受回调函数作为参数的函数转化为返回值为 Promise 实例的函数。一个典型的例子是 setTimeout() 函数：1setTimeout(() =&gt; alert("At least 3 seconds passed"), 3000); 在之前的一篇有关错误处理的博文中讲到，try...catch 结构无法捕获 setTimeout() 函数内的错误，而这一点正是基于回调的 setTimeout() 函数备受指责的原因。12345678try &#123; setTimeout(() =&gt; &#123; throw new Error("error in setTimeout"); // 脚本在这行直接挂掉了 &#125;, 0);&#125; catch (error) &#123; // 无法捕获错误，因为抛出错误时已经离开了 try...catch 结构体 alert("this line will not be printed");&#125; 让我们使用 Promise 封装它：123const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));// 使用wait(3000).then(() =&gt; alert("At least 3 seconds passed")).catch(failureCallback); 一个更加具体的加载脚本的例子：12345678910111213141516171819202122232425262728293031// 使用 Promise 封装基于回调处理异步的代码// 回调const loadScript = function (src, callback) &#123; const script = document.createElement("script"); script.src = src; script.onload = () =&gt; callback(null, script); script.onerror = () =&gt; callback(new Error(`Load script error for $&#123;src&#125;`)); document.head.append(script);&#125;;// 使用loadScript("path/script.js", (error, result) =&gt; &#123; if (error) alert(error) else alert(result);&#125;)// promisifyconst loadScriptPromise = function (src) &#123; return new Promise((resolve, reject) =&gt; &#123; loadScript(src, (error, result) =&gt; &#123; if (error) reject(error) else resolve(result) &#125;); &#125;)&#125;;// 使用loadScriptPromise("path/script.js").then(res =&gt; alert(res)); 鉴于这是一个常见的需求，可以将其抽象成一个单独的函数 promisify：123456789101112131415161718192021222324const promisify = function (f) &#123; const wrapper = function (...args) &#123; return new Promise((resolve, reject) =&gt; &#123; // 定制 f 的回调函数 const callback = function (error, result) &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(result); &#125; &#125; // 将定制的回调函数添加到 f 参数的末尾 args.push(callback); f.apply(this, args); &#125;) &#125;; return wrapper;&#125;;// 使用const loadScriptPromise = promisify(loadScript);loadScriptPromise("https://api.github.com/users/cddbysj") .then(res =&gt; alert(res)) .catch(err =&gt; alert(err)); 上面的代码存在一个不足，只能接受形式为 (err, result) =&gt; {...} 的回调函数，即回调只能接受两个参数，一个代表错误，另一个代表结果。如果遇到类似(err, result1, result2, ...) =&gt; {...} 这样的回调函数则无法正常运行。针对这一问题的改进如下：12345678910111213141516171819202122232425262728293031323334// 回调const loadScript = function (src, callback) &#123; const script = document.createElement("script"); script.src = src; script.onload = () =&gt; callback(null, script, "test1", "test2"); script.onerror = () =&gt; callback(new Error(`Load script error for $&#123;src&#125;`)); document.head.append(script);&#125;;// promisifyconst promisify = function (f) &#123; const wrapper = function (...args) &#123; return new Promise((resolve, reject) =&gt; &#123; const callback = function (error, ...result) &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(result.length === 1 ? result[0] : result); // (*) &#125; &#125;; args.push(callback); f.apply(this, args); &#125;); &#125;; return wrapper;&#125;;// 使用const loadScriptPromise = promisify(loadScript);loadScriptPromise("https://api.github.com/users/cddbysj") .then(res =&gt; alert(res)) // [script, "test1", "test2"] .catch(err =&gt; alert(err)); 参考链接及外部资料JavaScript.info - promise-basics Using promise - MDN Promise - MDN]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：错误处理]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[通常，对于 JavaScript 脚本而言，如果运行脚本时出现错误会挂掉，即引擎会在错误代码处停下来，不会继续执行后续代码，而是将错误信息打印到控制台。比如：1234let a = 1;console.log(b); (*)console.log(a);// Uncaught ReferenceError: b is not defined 上面的代码中，执行到 (*) 这一行便会停下来，将错误信息打印到控制台。 try…catch 结构但是，有一种语法结构 try...catch 允许我们捕获错误并作出相应的处理，这样脚本在出现错误时不会挂掉，而是执行我们设定的错误处理代码。我们来看两个例子：123456789101112131415try &#123; alert('Start of try runs'); // (1) &lt;-- // ...no errors here alert('End of try runs'); // (2) &lt;--&#125; catch(err) &#123; alert('Catch is ignored, because there are no errors'); // (3)&#125;alert("...Then the execution continues"); 上面的代码中，因为 try 语句块没有错误，所以 catch 语句块内的代码会被忽略，不会执行。 123456789101112131415try &#123; alert('Start of try runs'); // (1) &lt;-- lalala; // error, variable is not defined! alert('End of try (never reached)'); // (2)&#125; catch(err) &#123; alert(`Error has occured!`); // (3) &lt;--&#125;alert("...Then the execution continues"); 上面的代码中，由于 try 语句块内存在错误：变量未定义，所以 try 语句块内这一行之后的代码都不会执行，直接跳转到 catch 语句块内执行错误处理代码。 try…catch 只能捕获运行时错误所谓运行时错误 runtime-error，是指有效的 JavaScript 代码，即 JavaScript 引擎可以正确解析的代码。对于一个 JavaScript 脚本，引擎首先会解析它，接着执行它。如果出现解析时错误，通常是语法错误，引擎会直接报错，因为引擎这时无法读懂代码，自然地，try..catch 结构不可能捕获到解析错误。比如：12345try &#123; &#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#125; catch(e) &#123; alert("The engine can't understand this code, it's invalid");&#125; try…catch 是同步执行的在诸如定时器 setTimeout 等异步代码中发生错误，try...catch 结构无法捕获错误。比如：1234567try &#123; setTimeout(function() &#123; noSuchVariable; // script will die here &#125;, 1000);&#125; catch (e) &#123; alert( "won't work" );&#125; 原因在于，setTimeout 的回调函数在执行时，引擎实际上已经离开了 try...catch 结构体。要捕获类似这样的错误，需要这样做：1234567setTimeout(function() &#123; try &#123; noSuchVariable; // try..catch handles the error! &#125; catch (e) &#123; alert( "error is caught here!"); &#125;&#125;) 错误对象当发生运行时错误时，引擎会创建一个错误对象，里面包含了有关这次错误的信息。该错误对象会被当作参数传递给 catch 语句：1234567891011try &#123; lalala; // error, variable is not defined!&#125; catch(err) &#123; // &lt;-- the "error object", could use another word instead of err alert(err.name); // ReferenceError alert(err.message); // lalala is not defined alert(err.stack); // ReferenceError: lalala is not defined at ... // Can also show an error as a whole // The error is converted to string as "name: message" alert(err); // ReferenceError: lalala is not defined&#125; 错误对象主要有 2 个属性： name 错误的名称，对于未定义的变量而言，是引用错误 ReferenceError。 message 有关错误详情的文本信息。 还有一个非标准但是被广泛采用的属性： stack 主要用作调试，包含了导致错误的调用栈跟踪。 实例让我们来看一个实际的例子：解析从服务器获取的 JSON 数据。正常的情况下，应该是这样的：1234567const json = '&#123;"name":"John", "age": 30&#125;'; // data from the serverconst user = JSON.parse(json); // convert the text representation to JS object// now user is an object with properties from the stringalert( user.name ); // Johnalert( user.age ); // 30 JSON 格式错误但是实际情况往往复杂多变，首先考虑一种情况，假如 JSON 数据不合法（格式错误，无法被正确解析），那么脚本运行到解析 JSON 数据时将会直接挂掉。这显然不是我们想要的结果，这也会让用户非常困惑。我们可以使用 try...catch 来进行错误处理：12345678910111213const json = "&#123; bad json &#125;";try &#123; let user = JSON.parse(json); // &lt;-- when an error occurs... alert( user.name ); // doesn't work&#125; catch (e) &#123; // ...the execution jumps here alert( "Our apologies, the data has errors, we'll try to request it one more time." ); alert( e.name ); alert( e.message );&#125; 抛出错误再考虑另一种情况：JSON 格式是对的，但是不包含我们需要的字段，在这里是 name 字段：12345678910const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; let user = JSON.parse(json); // &lt;-- no errors alert( user.name ); // no name!&#125; catch (e) &#123; alert( "doesn't execute" );&#125; 对于这种情况，我们可以使用 throw 操作符来抛出错误：123456789101112131415const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); // (*) &#125; alert( user.name );&#125; catch(e) &#123; alert( "JSON Error: " + e.message ); // JSON Error: Incomplete data: no name&#125; 重新抛出错误接着考虑更复杂的情况，除了 JSON 数据字段缺失的错误，假如 try 语句块内还有其他的错误，比如未定义的变量，如何在 catch 语句块内处理这种情况？接着上面的例子：1234567891011121314151617const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors lalala; // (*) undefined variable if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); // &#125; alert( user.name );&#125; catch(e) &#123; alert( "JSON Error: " + e.message ); // JSON Error: lalala is not defined&#125; 上面代码标有 (*) 的一行有一个未定义的变量，于是引擎会创建错误对象并跳转到 catch 语句块。需要明确的一点是，catch 会从 try 中捕获所有的错误。对于类似上面的例子，解决思路很简单：catch 语句块应该只处理它知道的错误并重新抛出其他错误。 这一过程大致如下： catch 会捕获 try 内的所有错误。 在 catch 语句块内，我们通过错误对象的 name 属性来分析错误。 只处理我们知道如何处理的错误，重新抛出其他错误。 针对上面的提到的同时存在未定义变量错误和 JSON 语法错误，我们只需要处理 JSON 语法错误，而将其他错误重新抛出：123456789101112131415161718192021const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors lalala; // (*) undefined variable if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); &#125; alert( user.name );&#125; catch(e) &#123; if (e.name === 'SyntaxError) &#123; alert( "JSON Error: " + e.message ); &#125; else &#123; throw e; // rethrow (*) &#125;&#125; 上面代码中，try...catch 只处理了它关心的 JSON 语法错误，而将其他错误重新抛出。那么其他错误最终到哪里去了呢？ 两种可能：如果外部代码没有使用 try...catch 来捕获错误，那么会导致脚本挂掉；如果外部代码使用了 try...catch 结构，则会捕获重新抛出的错误。如下面代码所示：12345678910111213141516171819function readData() &#123; const json = '&#123; "age": 30 &#125;'; try &#123; // ... blabla(); // error! &#125; catch (e) &#123; // ... if (e.name != 'SyntaxError') &#123; throw e; // rethrow (don't know how to deal with it) &#125; &#125;&#125;try &#123; readData();&#125; catch (e) &#123; alert( "External catch got: " + e ); // caught it!&#125; 上面的代码中，内层的 try...catch 只处理了语法错误，其他的错误都由外层的 try...catch 来处理。 注意事项 在 try...catch...finally 语句块内声明的变量只在该语句块没可见。 123456789101112131415161718192021222324let num = +prompt("Enter a positive integer number?", 35)let diff, result; // 注意这里变量都声明在 try...catch...finally 语句块之外function fib(n) &#123; if (n &lt; 0 || Math.trunc(n) != n) &#123; throw new Error("Must not be negative, and also an integer."); &#125; return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);&#125;let start = Date.now();try &#123; result = fib(num);&#125; catch (e) &#123; result = 0;&#125; finally &#123; diff = Date.now() - start;&#125;alert(result || "error occured");alert( `execution took $&#123;diff&#125;ms` ); finally 语句块总是会执行，即使 try 语句块内有显式的返回： 12345678910111213function func() &#123; try &#123; return 1; &#125; catch (e) &#123; /* ... */ &#125; finally &#123; alert( "finally" ); &#125;&#125;alert( func() ); // first works alert from finally, and then this one 全局捕获错误有一个不属于语言规范，但是各大浏览器都实现了的全局捕获错误的回调函数 window.onerror。它的主要作用不是为了让脚本可以继续执行，而是通常用作错误报告，即将错误信息发送给开发者。在页面中插入下面的脚本，即可实现错误报告的效果：123456789101112&lt;script&gt; window.onerror = function(message, url, line, col, error) &#123; const err = `$&#123;message&#125;\n At $&#123;line&#125;:$&#123;col&#125; of $&#123;url&#125;`; sendToDevelop(err); // 发送给开发者 &#125;; function readData() &#123; badFunc(); // 此处发生错误 &#125; readData();&lt;/script&gt; 定制和扩展错误在实际开发中，语言内置的几个标准错误类，比如 Error，SyntaxError，TypeError，ReferenceError 等，可能不足以满足我们在特定情况下的需要。比如在进行网络请求操作时我们可能需要 HttpError，在进行数据库操作时我们可能需要 DbError，对于搜索操作可能需要 NotFoundError 等。我们可以通过继承通用错误类 Error 来定制我们需要的错误类，这被认为是最佳实践。有以下优点： 可以继承 message，name，stack 这些基础的错误属性。 可以使用 inctanceof 运算符来判断错误类型。 便于之后的多级错误类型继承的形成。 当然，对于不同的错误类，我们可以添加额外所需的属性，比如对于 HttpError，可以添加 statusCode 属性，它的值可能是 404，500 等。 扩展错误实例让我们来看一个读取 JSON 格式的用户数据的例子。假定我们期望的用户数据是这样的：1const json = `&#123; "name": "John", "age": 30 &#125;`; 先做一点铺垫，内置的通用错误类 Error 的伪代码可能是这样的：12345678// The "pseudocode" for the built-in Error class defined by JavaScript itselfclass Error &#123; constructor(message) &#123; this.message = message; this.name = "Error"; // (different names for different built-in error classes) this.stack = &lt;nested calls&gt;; // non-standard, but most environments support it &#125;&#125; 为了将 JSON 数据字段缺失的错误单独处理，我们定制一个单独的 ValidationError 错误类：12345678910111213141516171819class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "ValidationError" &#125;&#125;// 模拟一个错误const test = function() &#123; throw new ValidationError("Whoops!");&#125;try &#123; test();&#125; catch(err) &#123; alert(err.message); // Whoops! alert(err.name); // ValidationError alert(err.stack); // a list of nested calls with line numbers for each&#125; 接着我们将它用在读取用户数据的例子上：123456789101112131415161718192021222324252627282930313233343536class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "Validation"; &#125;&#125;// Usageconst readUser = function (json) &#123; const user = JSON.parse(json); if (!user.name) &#123; throw new ValidationError("no field: name"); &#125; if (!user.age) &#123; throw new ValidationError("no field: age"); &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;// Working example with try..catchtry &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof ValidationError) &#123; console.log(`Invalid data: $&#123;error.message&#125;`); // Invalid data: No field: name &#125; else if (error instanceof SyntaxError) &#123; console.log(`JSON syntax error: $&#123;error.message&#125;`); &#125; else &#123; throw error; // unknown error, rethrow it &#125;&#125; 注意上面代码使用 instanceof 运算符来判断错误类型的做法。 进一步扩展错误类上面的 ValidationError 错误类还是过于通用，我们在它的基础上继续扩展一个更具体的属性缺失错误类 PropertyRequireError:1234567891011121314151617181920212223242526272829303132333435363738394041424344class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "Validation"; &#125;&#125;class PropertyRequireError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; this.name = "PropertyRequireError"; &#125;&#125;// Usageconst readUser = function (json) &#123; const user = JSON.parse(json); if (!user.name) &#123; throw new PropertyRequireError("name"); &#125; if (!user.age) &#123; throw new PropertyRequireError("age"); &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;// Working example with try..catchtry &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof PropertyRequireError) &#123; console.log(`Invalid data: $&#123;error.message&#125;`); &#125; else if (error instanceof SyntaxError) &#123; console.log(`JSON syntax error: $&#123;error.message&#125;`); &#125; else &#123; throw error; // unknown error, rethrow it &#125;&#125; 现在，我们在抛出属性错误的时候只需要传入缺失的属性就可以了。还有一个地方可以优化，每次扩展一个类都需要设置 this.name = ...，可以增加一个继承的层级来专门完成这个任务：123456789101112131415161718class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = this.constructor.name; &#125;&#125;class ValidationError extends MyError &#123; &#125;class PropertyRequiredError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; &#125;&#125;// name is correctalert( new PropertyRequiredError("field").name ); // PropertyRequiredError 包装异常让我们思考一下，readUser 这个函数的任务是从 JSON 数据读取到我们所需要的用户数据字段。让我们站在 readUser 函数的调用者的角度来思考，我们希望得到的错误信息应该简单清晰，是一个类似 ReadError 这样的错误类。至于错误的具体细节应该封装在这个错误类内部，可能是 JSON 格式错误，可能是属性缺失错误，以及将来可能出现的其他错误。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = this.constructor.name; &#125;&#125;class ReadError extends MyError &#123; constructor(message, cause) &#123; super(message); this.cause = cause; &#125;&#125;class ValidationError extends MyError &#123; constructor(message) &#123; super(message); &#125;&#125;class PropertyRequireError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; &#125;&#125;// 验证用户数据是否缺失属性const validateUser = function (user) &#123; if (!user.name) &#123; throw new PropertyRequireError("name"); &#125; if (!user.age) &#123; throw new PropertyRequireError("age"); &#125;&#125;const readUser = function (json) &#123; let user; try &#123; user = JSON.parse(json); &#125; catch (error) &#123; if (error instanceof SyntaxError) &#123; throw new ReadError("SyntaxError", error); &#125; else &#123; throw error; &#125; &#125; try &#123; validateUser(user); &#125; catch (error) &#123; if (error instanceof ValidationError) &#123; throw new ReadError("ValidationError", error); &#125; else &#123; throw error; &#125; &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;try &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof ReadError) &#123; // readUser 调用者关心的错误 console.log(error); // 原始错误信息 console.log(error.cause); &#125; else &#123; throw error; &#125;&#125; 上面代码所使用的方式叫做包装异常 Wrapping Exceptions，是一种在面向对象编程中广泛使用的技巧。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：面向对象之混入]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%B7%B7%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在 JavaScript 中，基于原型的继承是不支持多继承的。但是，在有些时候我们希望有类似的机制。一个非常的典型的例子是事件。有很多的对象，都应该含有对事件处理的方法。而这些针对事件处理的方法不适合被放在原型链中。在 JavaScript 中，实现混入mixin的方式非常简单：将这些方法放在一个对象中，然后通过 Object.assign 将该对象内的方法添加到类中。 实例：事件混入许多对象的一个重要特性是对事件的处理。下面的代码，通过混入的方式扩展了类的行为。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//事件混入：const eventMixin = &#123; /** * 订阅事件 * @param &#123;String&#125; eventName 订阅的事件名称 * @param &#123;Function&#125; handler 订阅的事件处理的回调函数 */ on(eventName, handler) &#123; if (!this._eventHandlers) &#123; this._eventHandlers = &#123;&#125;; &#125; if (!this._eventHandlers[eventName]) &#123; this._eventHandlers[eventName] = []; &#125; this._eventHandlers[eventName].push(handler); &#125;, /** * 取消订阅事件 * @param &#123;String&#125; eventName 要取消订阅的事件名称 * @param &#123;Function&#125; handler 要取消订阅的事件处理回调函数 */ off(eventName, handler) &#123; const handlers = this._eventHandlers &amp;&amp; this._eventHandlers[eventName]; if (!handlers) return; for (let i = 0; i &lt; handlers.length; i++) &#123; if (handlers[i] === handler) &#123; handlers.splice(i--, 1); &#125; &#125; &#125;, /** * 触发事件 * @param &#123;String&#125; eventName 事件名称 * @param &#123;any&#125; args 事件处理回调函数的参数 */ trigger(eventName, ...args) &#123; if (!this._eventHandlers || !this._eventHandlers[eventName]) &#123; return; &#125; this._eventHandlers[eventName].forEach(handler =&gt; handler.apply(this, args)); &#125;&#125;;class Menu &#123; choose(value) &#123; this.trigger("select", value); &#125;&#125;// 将事件混入 Menu 对象的原型Object.assign(Menu.prototype, eventMixin);const menu = new Menu();// 订阅 select 事件menu.on("select", value =&gt; alert(value));// 触发 select 事件menu.choose("apple");]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记：class语法糖]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aclass%20%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[在前面一篇原型与继承的学习笔记中，最后使用基于原型的范式实现了继承。而 ES6 引入的 class 关键字则提供了更加漂亮的语法，与 Java 等语言有点类似。还是以 Rabbit 继承 Animal 为例，使用 class 关键字的写法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Animal &#123; constructor(name, speed) &#123; this.name = name; this.speed = speed; &#125; // 静态方法是从属于 class 本身的，而非其原型。静态属性同理。 // 等同于： // Animale.compare = function(animalA, animalB) &#123; ... &#125; static compare(animalA, animalB) &#123; return animalA.speed - animalB.speed; &#125; // 成员方法是从属于 class 的原型的 // 等同于： // Animal.prototype.run = function(speed) &#123; ... &#125; run(speed) &#123; this.speed += speed; console.log(`$&#123;this.name&#125; run with speed $&#123;this.speed&#125;`); &#125; stop() &#123; this.speed = 0; console.log(`$&#123;this.name&#125; stopped`); &#125;&#125;class Rabbit extends Animal &#123; constructor(name, speed, earLength) &#123; super(name, speed); // 必须使用 super 调用父级构造器，然后才能访问 this this.earLength = earLength; &#125; hide() &#123; console.log(`$&#123;this.name&#125; hide`); &#125; stop() &#123; // 通过 super.method() 可以调用父类的方法 super.stop(); this.hide(); &#125;&#125;console.log(typeof Animal); // functionconsole.log(typeof Rabbit); // function 需要注意的几点： class 只是语法糖，在语言层面并未引入新的基本单元，从 typeof Animal 的结果 function 可以看到，本质上依然是函数。 子类的构造器 constructor 在访问 this 之前必须先调用父类构造器，即调用 super(...)。 为了更多地复用代码，在子类中可以使用 super.method() 调用父类的方法。 声明的成员方法 run，stop， hide 都是定义在其原型上。以 stop 方法为例，等同于： Animal.prototype = function () {...}。 声明的静态方法则是定义在 class 函数本身上，而非其原型上。 extends 关键字实际上做了以下工作： 将 Rabbit.prototype 的原型设为 Animal.prototype，使得 Rabbit 的实例可以继承 Animal 的实例属性 将 Rabbit 的原型设为 Animal，使得 Rabbit 本身可以继承 Animal 的静态属性 class 内声明的方法之间没有逗号 ,。 静态属性与实例属性在 JavaScript 中，结合 class 关键字，用类似 Java 中面向对象的思想来理解静态属性与实例属性。静态属性是挂载在 class 本身上的，而实例属性是挂载在原型 prototype 上的。我们以内置的 Object 和 Date 这两个对象为例来说明，如下图所示： 从上图可以清晰的看到：Object 和 Date 两者本身是不存在继承关系的，它们只是通过彼此的原型实现继承关系，仅此而已。 Object 的静态属性 Object.name Object.length Object.prototype Object.assign Object.getOwnPropertyDescriptor Object.getOwnPropertyDescriptors Object.getOwnPropertyNames Object.getOwnPropertySymbols Object.is Object.preventExtensions Object.seal Object.create Object.defineProperties Object.defineProperty Object.freeze Object.getPrototypeOf Object.setPrototypeOf Object.isExtensible Object.isFrozen Object.isSealed Object.keys Object.entries Object.values Object 的实例属性 constructor __defineGetter__ __defineSetter__ hasOwnProperty __lookupGetter__ __lookupSetter__ isPrototypeOf propertyIsEnumerable toString valueOf __proto__ toLocaleString Date 的静态属性 Date.length Date.name Date.prototype Date.now Date.parse Date.UTC Date 的实例属性 constructor toString toDateString toTimeString toISOString toUTCString toGMTString getDate setDate getDay getFullYear setFullYear getHours setHours getMilliseconds setMilliseconds getMinutes setMinutes getMonth setMonth getSeconds setSeconds getTime setTime getTimezoneOffset getUTCDate setUTCDate getUTCDay getUTCFullYear setUTCFullYear getUTCHours setUTCHours getUTCMilliseconds setUTCMilliseconds getUTCMinutes setUTCMinutes getUTCMonth setUTCMonth getUTCSeconds setUTCSeconds valueOf getYear setYear toJSON toLocaleString toLocaleDateString toLocaleTimeString. Symbol.toPrimitive. instanceof 运算符instanceof 运算符的语法如下：1obj instanceof Class 这一运算符的本质其实是判断 Class.prototype 是否在 obj 对象的原型链上。除此之外，对于那些部署了 Symbol.hasInstance 静态方法的类，还要额外考虑。obj instanceof Class 这一算法的工作过程大致如下： 如果某个类部署了 Symbol.hasInstance 静态方法，那么直接使用该方法。比如下面这样： 123456789// assume anything that canEat is an animalclass Animal &#123; static [Symbol.hasInstance](obj) &#123; if (obj.canEat) return true; &#125;&#125;let obj = &#123; canEat: true &#125;;alert(obj instanceof Animal); // true: Animal[Symbol.hasInstance](obj) is called 如果某个类没有部署 Symbol.hasInstance 静态方法（大多数类都没有部署）。那么开始检查这个类的原型链，看 Class.prototype 是否等于原型链上的某个原型，即做如下比较： 1234obj.__proto__ === Class.prototypeobj.__proto__.__proto__ === Class.prototypeobj.__proto__.__proto__.__proto__ === Class.prototype... 还是以 Rabbit 继承 Animal 为例，来看看 instanceof 的工作过程：1234567class Animal &#123;&#125;class Rabbit extends Animal &#123;&#125;let rabbit = new Rabbit();alert(rabbit instanceof Animal); // true// rabbit.__proto__ === Rabbit.prototype// rabbit.__proto__.__proto__ === Animal.prototype (match!) 上面的代码中，rabbit 实例的原型链是这样的：1rabbit -&gt; Rabbit.prototpye -&gt; Animal.prototype -&gt; Object.prototype -&gt; null rabbit instanceof Animal 执行的操作是在上面的原型链中查找，看 Animal.prototype 是否出现在原型链中，如果是则返回 true，否则返回 false。 类型检查在 JavaScript 中，主要有 3 种方法可以用来做类型检查： typeof 主要用于检查基本数据类型，返回一个说明了所属类型的字符串。比如： 1alert(typeof 1); // number {}.toString 用于检查基本数据类型，内置对象，以及部署了 Symbol.toStringTag 属性的对象。可以看做是增强版的 typeof 。示例： 1234567891011121314151617181920// 对于基本数据类型let s = Object.prototype.toString;alert( s.call(123) ); // [object Number]alert( s.call(null) ); // [object Null]alert( s.call(alert) ); // [object Function]// 对于部署了 Symbol.toStringTag 的对象let user = &#123; [Symbol.toStringTag]: "User"&#125;;alert( &#123;&#125;.toString.call(user) ); // [object User]// 对于特定环境的内置对象和类alert( window[Symbol.toStringTag]); // windowalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequestalert( &#123;&#125;.toString.call(window) ); // [object Window]alert( &#123;&#125;.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest] instanceof 用于对检查对象数据类型，尤其用于检查对象继承关系。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家具木材指南]]></title>
    <url>%2Fpassages%2F%E5%AE%B6%E5%85%B7%E6%9C%A8%E6%9D%90%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[a guide to furniture woodmaple, cherry, oak or other hardwood plywood.there is a lot of advantage to using plywood instead of solid lumber.in the US at least. it is fairly inexpensive. plywood is very strong and stable. You don’t have to worry about expansion and contraction, it won’t warp.and it’s a great option for large surfaces such as tabletop.it’s equally strong in either direction. so you don’t need to worry about the grain direction besides what look best.There’s a few disadvantages to using plywood.For one, a four by eight sheet of plywood is heavy and difficult to move around manage alone.However most home centers are able to cut it down to smaller pieces for you.Second,while the face of plywood looks great, the edges can be a little bit of an eyesore medium density fiberboard - MDFmedium density fiberboard is commonly used in knockdown furniture, like what you might assemble from IKEA or other retailers. It’s usually covered with a laminate or a veneer.The material itself is super easy to machine and work with, it cut like butter, and edge profiles rout out easily. It’s a great option for decorative interior projects that you’re gonna paint, and you don’t have to worry about it splintering the way wood or plywood can.MDF can be a bit fragile especially near edges where it can be collapes like cardboard if you’re not careful. 译文家具木材指南家具上使用的木材，主要可以分为 3 个大类： 实心木材 胶合板 密度板 你当然可以选择枫木，樱桃木，橡木或其他硬木胶合板。使用胶合板代替实心木材有很多优点。至少在美国。它相当便宜。胶合板非常坚固稳定。您不必担心膨胀和收缩，它不会翘曲。对于桌面等大型表面来说，它是一个很好的选择。它在任何一个方向都同样强大。所以除了看起来最好的外，你不需要担心纹理方向。使用胶合板有一些缺点。例如，一张四到八张的胶合板很重，很难单独移动。但是大多数家具中心都可以为你剪裁成小块。其次，虽然胶合板的表面看起来很棒，但边缘可能会有点辣眼睛 中密度纤维板 - MDF中密度纤维板通常用于击倒式家具，就像您可能从宜家或其他零售商处组装的那样。它通常用层压板或单板覆盖。材料本身非常容易加工和加工，切割它就像切割黄油一样，很容易切割出你想要的轮廓。对于您要涂漆的装饰性室内工程来说，这是一个很好的选择，您不必担心 MDF 会像木材或胶合板那样开裂。MDF可能有点脆弱，特别是在边缘附近，如果你不小心它可以像纸板一样折叠。 参考链接 美国工程木材协会 提供工程木材方面的信息 craft wood products 做的很漂亮的一个有关木制品设计的网站 中国林业科学院木材工业研究所网站 如何购买实木复合地板 《中国人造板》杂志 网站现在已经没有运营了 阅木 木材的特点 关于中国主要木材的三大相关标准 如何选择家具的木材 youtube 上的一个木匠 家具木材科普 - HowStuffWorks 几种适合现代家具的实心木材]]></content>
      <tags>
        <tag>木材</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：原型与继承]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型每个 JavaScript 中的对象都有一个特殊的内部隐藏属性 [[prototype]]，它要么指向 null，要么指向另一个对象，我们称之为原型。当我们从一个对象上读取某个属性，如果在对象本身上没有找到，那么 JavaScript 引擎会尝试从它的原型中去寻找。 原型属性 [[prototype]] 虽然是内部隐藏的属性，但是有一些方法可以获取到它。 __proto__其中之一是 __proto__，但是 __proto__ 并不完全等同于原型，只是由于历史原因，各个浏览器包括 NodeJS 都部署了这一属性，实际开发中应该使用 ES 规范中的更现代的设置原型的方法，后面会提到。考虑如下代码：12345678910111213// 代码片段 1const animal = &#123; eats: true&#125;;const rabbit = &#123; jumps: true&#125;;rabbit.__proto__ = animal;console.log(rabbit.jumps); // trueconsole.log(rabbit.eats); // true rabbit 对象本身没有 eats 属性，但是因为让它的原型指向了 animal 对象，这时我们可以说 animal 是 rabbit 的原型。所以引擎会在 rabbit 没有某个属性时从其原型 animal 上获取。 因此，我们可以将许多有用，但是更加通用的属性放到抽象程度更高的对象中，显然，在这里是 animal：123456789101112131415// 代码片段 2const animal = &#123; eats: true, walk() &#123; alert("Animal walk"); &#125;&#125;;const rabbit = &#123; jumps: true, __proto__: animal&#125;;// walk is taken from the prototyperabbit.walk(); // Animal walk 现在 rabbit 通过原型，继承了 animal 的共同属性 eats 和 walk。原型链 prototype chain 还可以更长：123456789101112131415161718192021// 代码片段 3const animal = &#123; eats: true, walk() &#123; alert("Animal walk"); &#125;&#125;;const rabbit = &#123; jumps: true, __proto__: animal&#125;;const longEar = &#123; earLength: 10, __proto__: rabbit&#125;;// walk is taken from the prototype chainlongEar.walk(); // Animal walkalert(longEar.jumps); // true (from rabbit) 现在，按照抽象程度由低到高形成了一条原型链：longEar -&gt; rabbit -&gt; animal。 原型链的限制对于原型链来说主要由下面 3 条限制： 原型链不能构成环，否则引擎将会抛出错误，在上面的例子中，即不能再将 animal 的原型指向 longEar。 __proto__ 的值类型要么是 null，要么是 Object，即另一个对象。所有基本类型的值会被忽略。 一个对象只能有一个原型，即不能继承两个父级。 this 的值当对象调用原型的方法时，this 的值是指代原型还是对象本身呢？下面的代码清晰的说明了这一问题：123456789101112131415161718192021const user = &#123; name: "John", surname: "Smith", get fullname() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set fullname(value) &#123; [this.name, this.surname] = value.split(" "); &#125;&#125;;const admin = &#123; name: "Norah", surname: "Jones", isAdmin: true, __proto__: user&#125;;console.log(admin.fullname); // Nora Jonesadmin.fullname = "Michael Jackson";console.log(admin.fullname); // Michael Jackson 不管某个方法是在对象本身上，还是在其原型上，this 永远指向 . 运算符前面的对象。 F.prototype我们知道，对象除了可以使用字面量创建，还可以使用 new F() 形式的构造函数来创建。请注意，构造函数本质上依然是函数，JavaScript 中的每个函数都具有一个特殊的 prototype 属性。默认情况下，它是一个仅包含 constructor 属性的对象（不包括每个对象的隐藏属性 [[prototype]]，因为函数也是对象），其中 constructor 指向函数本身：1234const F = function () &#123; &#125;;console.log(F.prototype); // &#123; constructor: f &#125;console.log(F.prototype.constructor === F); // true 如果我们让 F.prototype 指向一个对象，那么在使用 new 操作符调用构造函数 F 时，新创建的实例的原型 [[prototype]] 都将被指向这个对象。示例：12345678910111213141516const animal = &#123; eats: true&#125;;const Rabbit = function(name) &#123; this.name = name;&#125;;Rabbit.prototype = animal; // 设置所有 Rabbit 创建的实例的原型为 animalRabbit.prototype.construtor = Rabbit; // 修正 Rabbit 原型的 constructor 的指向 (*)const rabbit = new Rabbit('white rabbit');console.log(rabbit.eats); // trueconsole.log(rabbit.__proto__ === animal); // trueconsole.log(rabbit.constructor === Rabbit); // true 上面的代码中，另一个需要注意的问题是 F.prototype.constructor 的值。改变构造函数 F.prototype 的默认指向，如果接下来（之前创建的实例不会受到影响）使用到其新创建的实例的 construtor 属性，会导致意想不到的错误。拿上面的例子来说，如果没有 (*) 这一行代码，rabbit.constructor 的值将会指向 animal，显然这在人意料之外，也不合理。所以，普遍的共识是：不要依赖 constructor 这一属性，因为它能被任意修改。 有时候，我们需要使用某个实例的构造函数来创建一个实例，但是却不知道它的构造函数。这时可以这样做，但是需要小心：1234567const User = function(name) &#123; this.name = name;&#125;;const user = new User('Bill');const user2 = new user.constructor('Sunny');alert(user2.name); // Sunny 上面的代码可以如正常运行，因为构造函数 User 的 prototype 的指向是默认的，指向其自身。假如修改一下代码，改变其指向：12345678const User = function(name) &#123; this.name = name;&#125;User.prototype = &#123;&#125;;const user = new User('Bill');const user2 = new user.constructor('Sunny'); // (*)alert(user2.name); // undifined 我们来看看 (*) 这一行发生了什么： 首先引擎会在 user 对象上查找 constructor 属性，没有找到。 接着引擎会沿着原型链查找，user 的原型是 User.prototype，它是一个空对象 {}，没有找到。 空对象 {} 的原型是 Object.prototype，而 Object.prototype.constructor === Object。所以实际执行的是 new Object(&#39;Sunny&#39;)，而内置的对象构造函数会忽略所有参数，所以得到如上结果。 Object.prototype让我们来看下面的代码：12const obj = &#123;&#125;;alert(obj); // [object Object] 为什么会有以上的输出？我们定义的对象是空的，是哪里来的代码生成了 [object Object] 这样的字符串信息？答案是内置的 toString 方法。通过字面量创建对象等同于使用对象构造函数 new Object()。而 Object 构造函数就像所有函数一样，也有一个 prototype 属性，它指向了一个很大的对象，上面部署了 constructor, toString, valueOf 等一系列所有对象通用的方法和属性。 以下代码可以检查上面所说：1234const obj = &#123;&#125;;alert(obj.__proto__ === Object.prototype); // true// obj.toString === obj.__proto__.toString == Object.prototype.toString 另外，Object.prototype 这个内置的原型的 [[prototype]] 指向了谁呢？答案是 null:1alert(Object.prototype.__proto__); // null 其他抽象程度稍低的一些内置对象，比如 Function，Array，Date 等，也部署了一些方法在其原型上。这样每一个函数实例，数组实例或者日期实例，都可以使用一些内置于其原型上的方法了。这样设计的目的非常利于节省内存。下面这张图局部地说明了这种关系。 我们可以手动地验证一下：12345678910const arr = [1, 2, 3];alert(arr.__proto__ === Array.prototype); // truealert(arr.__proto__.__proto__ === Object.prototype); // truealert(arr.__proto__.__proto__.__proto__); // nullconst f = function() &#123;&#125;;alert(f.__proto__ === Function.prototype); // truealert(f.__proto__.__proto__ === Object.prototype); // true 基本类型的原型对于 String, Number, Boolean 这 3 种基本类型而言，当访问它们的属性时，会使用内置的构造函数（比如 Number()）创建一个临时的封装对象，然后访问这个临时封装对象原型上的属性或者方法，访问完成后临时对象就消失了，这一过程对我们来说都是不可见的。 对于 null 和 undefined 而言，不会有自动创建临时封装对象这一过程，因为它们没有可用的属性或者方法，也就没有内置的原型。 设置原型的现代方法我们应该只考虑以下 3 种现代的设置原型的方法： Object.create(proto[, descriptors]) - 以给定的 proto 作为原型，创建一个新的空对象，descriptors 是可选参数，代表属性描述符。 Object.getPrototypeOf(obj) - 返回对象的原型。 Object.setPrototypeOf(obj, proto) - 将 obj 的原型设为 proto。 让我们用更标准、现代的方法改写前面的例子：1234567891011121314const animal = &#123; eats: true&#125;;const rabbit = Object.create(animal, &#123; jumps: &#123; value: true &#125;&#125;);alert(rabbit.eats); // truealert(Object.getPrototypeOf(rabbit) === animal); // trueObject.setPrototypeof(rabbit, &#123;&#125;); // 改变 rabbit 的原型，使其原型为一个空对象 使用原型方法进行浅拷贝123const origin = &#123;...&#125;;const clone = Object.create(Object.getPrototypeOf(origin), Object.getOwnPropertyDescriptors(origin)); 上面的代码，以源对象的原型为原型，加上源对象的所有属性描述符选项，复制了所有源对象的属性，不管是可枚举属性还是不可枚举属性，数据属性还是访问属性，也包括了 Symbol 属性；同时有着相同的原型。 让我们看一个详细的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 源对象const origin = Object.create(null, &#123; 'name': &#123; value: 'Sheldon', writable: true, enumerable: true, configurable: true &#125;, 'surname': &#123; value: 'Cooper', writable: true, enumerable: true, configurable: true &#125;, 'fullname': &#123; get() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set(value) &#123; [this.name, this.surname] = value.split(' '); &#125; &#125;, [Symbol('id')]: &#123; value: 9527, writable: false, configurable: true, enumerable: true &#125;, 'toString': &#123; value: function () &#123; return 'custom toString!' &#125;, writable: true, enumerable: false, configurable: true &#125;&#125;)// 浅拷贝const clone = Object.create(Object.getPrototypeOf(origin), Object.getOwnPropertyDescriptors(origin));// 可枚举属性和 Symbol 属性复制成功console.log(clone); // &#123; name: 'Sheldon', surname: 'Cooper', [Symbol(id)]: 9527 &#125;// 不可枚举属性复制成功console.log(clone.toString()); // custom toString!// 访问属性复制成功console.log(clone.fullname); // Sheldon Cooper// 原型复制成功console.log(Object.getPrototypeOf(clone) === null); // true 上面代码的源对象是一个出于演示目的而定制的，包含了可枚举属性和不可枚举属性，数据属性和访问属性，以及 Symbol 属性，从最后的打印结果可以看到，拷贝对象全部成功地复制了过来。 不要轻易在初始化更改原型设置以上面的代码为例，如果我们在一开始让 rabbit 以 animal 为原型，接下来不要轻易更改 rabbit 的原型，因为引擎会对已有的原型继承做很多属性读取之类的优化，更改原型会破坏这些已有的优化，导致运行速度变慢。 纯字典对象假设我们想要实现一个纯字典对象，即包含一切合法字符串为键的键值对，使用通常的字面量对象会有一个问题：有一个特殊的字符串 __proto__ 无法如预期般奏效。123456const dictionary = &#123; '__proto__': 'some value'&#125;;alert(dictionary.__proto__); // [object Object]alert(dictionary.__proto__ === Object.prototype); // true 上面的属性读取无法得到预期的 some value 结果，因为通常字面量创建的对象，默认原型是 Object.prototype ，而因为历史原因 __proto__ 这一特殊属性被当做访问原型的途径。如果将其赋值为基本类型值，赋值操作将会被忽略。 如何解决上面的问题？有两种方式： 使用 Map，通常这是更加推荐的做法。 使用 Object.create(null) 从所有原型的顶端 null 继承，这样创建的对象是一个真正的纯对象，不会包含一般对象内置的 toString，valueOf，__proto__ 等属性。 属性遍历方法比较 Object.keys(obj) / Object.values(obj) / Object.entries(obj) – 返回一个包含对象自身的可枚举字符串属性的键 / 值 / 键值对的数组。不包含继承属性，不包含 Symbol 属性。 Object.getOwnPropertySymbols(obj) – 返回一个包含自身所有 Symbol 属性的数组。 Object.getOwnPropertyNames(obj) – 返回一个包含自身所有字符串属性的数组。 Reflect.ownKeys(obj) – 返回一个包含自身所有属性的数组。 obj.hasOwnProperty(key) - 如果自身（非继承）包含该属性，返回真。 for...in 循环 - 遍历所有可枚举的字符串属性，包括自身属性和继承属性。不包括不可枚举属性，不包括 Symbol 属性。 基于原型实现继承虽然 ES6 引入了 class 关键字，但那只是一种语法糖。JavaScript 中继承的实现本质上是基于原型的。原型继承的实现参考以下代码：12345678910111213141516171819202122232425262728function Animal(name) &#123; this.name = name;&#125;Animal.prototype.eat = function () &#123; console.log(`$&#123;this.name&#125; eats`);&#125;;Animal.prototype.walk = function () &#123; console.log(`$&#123;this.name&#125; walks`);&#125;;function Rabbit(name) &#123; this.name = name;&#125;Rabbit.prototype.walk = function () &#123; console.log(`$&#123;this.name&#125; bounces`);&#125;;// 让 Rabbit 继承 AnimalObject.setPrototypeOf(Rabbit.prototype, Animal.prototype);// 或者这样写： Rabbit.prototype = Object.create(Animal.prototype);// 不推荐写法： Rabbit.prototype.__proto__ = Object.prototypeconst rabbit = new Rabbit('white rabbit');rabbit.walk(); // white rabbit bouncesrabbit.eat(); // white rabbit eats]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：对象的属性描述符]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 中的对象属性，并不只是简单的键值对，通过属性描述符 property descriptor ，我们可以更加灵活的配置对象属性以控制属性的行为，包括是否可枚举、是否可写、是否可配置，实现更强大的功能。实际上，对于对象而言，一共有 2 种属性： 数据属性 data property 访问属性 accessor property 数据属性通常我们见到的属性都是这样的：12345// 代码片段 1const user = &#123; name: 'Sheldon', age: 29&#125;; 上面的 name 和 age 都是数据属性。 访问属性还有另一种形式，比如：123456789101112131415// 代码片段 2const user = &#123; name: 'Bill', surname: 'Gates', get fullname() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set fullname(value) &#123; [this.name, this.surname] = value.split(','); &#125;&#125;;user.fullname // Bill Gatesuser.fullname = 'Sheldon Cooper';user.name // Sheldon 上面的 name 和 surname 是数据属性，fullname 则是访问属性。即凡是使用 get prop() 或者 set prop() 定义的属性，都是访问属性，不再是数据属性。 数据属性的描述符对于数据属性而言，其描述符由 4 个 flag 组成： value 属性的值 writable 是否可写 enumerable 是否可枚举，在类似 for...in 遍历中是否忽略 configurable 是否可配置，即是否可以编辑描述符的 flag 对于使用字面量声明的对象属性而言，除了 value 之外的 3 个 flag 的默认值都为 true。使用 Object.getOwnPropertyDescriptor(obj, prop) 方法可以获取对象上某属性的描述符。比如获取上面代码片段 1 中 user 对象 name 属性的描述符：12345678// 代码片段 3const descriptor = Object.getOwnPropertyDescriptor(user, 'name');// &#123;// "value": "Sheldon",// "writable": true,// "enumerable": true,// "configurable": true// &#125; 如果想要精确地控制属性的行为，使用 Object.defineProperty(obj, prop, descriptor) 方法。使用这种方式，如果属性的某个 flag 没有显式指定，则默认值将是 false 。123456789101112131415// 代码片段 4const user = &#123;&#125;;Object.defineProperty(user, 'name', &#123; value: 'Sheldon', writable: true&#125;)const descriptor = Object.getOwnPropertyDescriptor(user, 'name');console.log(JSON.stringify(descriptor, null, 2));// &#123;// "value": "Sheldon",// "writable": true,// "enumerable": false,// "configurable": false// &#125; 可以看到，除了显式指定的 writable ，其他未指定的 flag 的都是默认为 false。 可枚举性描述符的 enumerable 属性，称为“可枚举性”，如果该属性为 false，就表示某些操作会忽略当前属性。目前，有四个操作会忽略 enumerable 为 false 的属性。 for...in 循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。 可配置性描述符的 configurable 属性，表示该属性的 flag 是否可配置，一旦设为 false 不可逆。用的很少。 访问属性的描述符访问属性的描述符不同于数据属性的描述符，没有 value 和 writable 这 2 个 flag，多了 get 和 set，所以一个访问属性的描述符可能有如下组成： get – 无参数函数，当属性被读取时被调用 set – 单参数函数，当属性被设置时被调用 enumerable – 与数据属性一致 configurable – 与数据属性一致 访问属性的 getter/setter 可以直接使用字面量声明（如上面的代码片段 2 所示），也可以使用 Object.defineProperty，如下：1234567891011121314// 代码片段 5const user = &#123; name: 'Bill', surname: 'Gates'&#125;;Object.defineProperty(user, 'fullname', &#123; get() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set(value) &#123; [this.name, this.surname] = value.split(','); &#125;&#125;) getter/setter 应用使用 get 和 set 访问属性描述符，我们可以更加灵活控制属性的读写行为。比如对于 user 对象而言，可以限制 name 的长度：12345678910111213// 代码片段 6const user = &#123; get name() &#123; return this._name; &#125;, set name(value) &#123; if (value.length &gt; 4) &#123; alert('用户名长度不能超过 4 位'); return; &#125; this._name = value; // 这里使用 this._name 是一种广泛的通用约定 &#125;&#125; 数据属性或访问属性需要注意的是，一个属性要么是数据属性，要么是访问属性，不能两者皆是。相应地，如果同时给属性设置 value 和 get 这 2 个 flag 会报错。123456789// 代码片段 7// Error: Invalid property descriptor. Cannot both specify accessors and a value or writable attributeObject.defineProperty(&#123;&#125;, 'prop', &#123; get() &#123; return 1 &#125;, value: 1&#125;); 参考链接 ES6 入门 - 阮一峰 Modern Javascript Tutorial]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么 0.1 + 0.2 !== 0.3]]></title>
    <url>%2Fpassages%2F%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3%2F</url>
    <content type="text"><![CDATA[JavaScript 中的数字以 64 位浮点数的格式表示，遵从IEEE 754-1985这一用二进制表示数字的工业标准。其中的 52 位用于分数部分，即存储精度；11 位用于指数部分，即表示小数点的位置；1 位用于符号位，表示正负。如下图所示： 对于 64 位双精度数字而言，维基百科上给出了如下信息： Width: 64 bits Range at full precision: ±2.23×10e308 to ±1.80×10e308 Precision: Approximately 16 decimal digits 即在保证精度不丢失的前提下，64 位浮点数最多能表示 16 位的十进制数，超出这一限制则导致精度丢失。回到标题抛出的问题：0.1 + 0.2 !== 0.3，我们可以试着运行以下代码：123456console.log(0.1.toFixed(16));// 0.1000000000000000console.log(0.1.toFixed(17));// 0.10000000000000001console.log(0.1.toFixed(20));// 0.10000000000000000555 这进一步说明超过 16 位的十进制数，使用 64 位浮点数的二进制表示会产生精度丢失。与此同时，我们注意到：十进制数 0.1 是无法用二进制来精确表示的，这正如 1 / 3 无法在十进制下用有限位数来精确表示，是一样的道理。这里引出了一个问题，什么样的数字在十进制下无法精确表示？什么样的数字在二进制下无法精确表示？ 个人对进制的思考进制即进位计数制，十进制即逢十进一，二进制即逢二进一，N 进制即逢 N 进一；从相反的一面来看，N 也是基数，即在 N 进制下如果要产生小数，便是用 N 为基数去分割。为了方便说明，这里以十进制为例。在十进制下，要产生可以精确表示的小数就是用基数 10 去分割，所以 1 / 10 是可以精确表示的，又由于 10 本身并非素数，可以由 2 x 5 得来，所以十进制下，只有分母表述成如下方式的小数才能精确表示：122**x * 5**y// x 和 y 为 非负整数 考虑常见的 1 / 2 到 1 / 10:1234567891 / 2 -&gt; 2**1 * 5**01 / 3 -&gt; fail1 / 4 -&gt; 2**2 * 5**01 / 5 -&gt; 2**0 * 5**11 / 6 -&gt; fail1 / 7 -&gt; fail1 / 8 -&gt; 2**3 * 5**01 / 9 -&gt; fail1 / 10 -&gt; 2**1 * 5**1 引申到二进制的环境下，只有分母表述成如下方式的二进制小数才能精确表示：122**x// x 为非负整数 所以对于十进制数 0.1, 0.2, 0.3都无法用二进制来精确表示，当两个数字求和时，它们丢失的精度会加起来，这便是 0.1 + 0.2 !== 0.3 的原因。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>精度丢失</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Bash 常用命令集锦]]></title>
    <url>%2Fpassages%2FGit%20Bash%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[Git Bash 是将 GNU 开源软件下的命令移植到了 Windows 下面。同时不仅可以使用大部分常用的 linux shell 命令，也集成了部分 Windows 下的命令。比如显示当前目录下的文件和文件夹，ls以及dir都是可用的。下面列出了我在 linux shell 下的常用命令。 路径查找和切换1234567891011121314151617181920212223242526pwd# print working directory, 打印当前工作目录ls# list,查看当前目录下的文件，不包括隐藏文件，仅显示文件名称ls -a# list all, 查看当前目录下的所有文件，包括隐藏文件ll(ls -l)# 查看当前目录下的文件详细信息，包括时间、读写权限等cd &lt;path&gt;# change directory, 改变目录，后面尖括号内是目标目录的路径cd# 当不加参数时，跳转到设定的默认启动目录cd ~# 在 Linux 下面，~ 表示当前用户账户的根目录cd ..# 跳转到上一级目录cd ./project/static# 跳转到当前目录的下一级目录project/static 文件操作类1234567891011121314151617181920212223rm path/to/file.ext# remove,删除 path/to 目录下的 file.ext 文件，注意： rm 命令只能用于删除文件rm -r path/to/folder# 删除 path/to/folder 文件夹， -r 必须要加，表示recursive,即递归的删除mv path/to/file.ext different/path/file.ext# move,移动文件mv old-filename.ext new-filename.ext# mv 命令同样可以用来重命名文件cp file-to-copy.ext# copy,复制文件mkdir new-folder# make directory,新建文件夹touch file.ext# 新建文件，默认在当前目录touch path/to/file.ext# 在指定的目录下新建文件 产生输入类12345678echo text-will-be-echo# echo 的意思是回音，这条指令相当于打开了一条读写流echo text-will-be-written-to-file &gt; file.ext# 将内容写入到文件中，后面写入的内容将覆盖之前的内容echo text-will-be-written-to-file &gt;&gt; file.ext# 将内容写入到文件中，后面写入的内容将追加到之前的内容末尾 产生输出类1234567cat file.ext# 查看文件内容，一次性显示全部内容。less file.ext# 查看文件内容，显示当前命令行窗口可以展示的内容。# 接着每按下一次 回车键 ，继续显示一行信息。# 按下空格键显示下一页信息，按下 b 键显示上一页信息，按下 q 键退出显示。 网络类1234curl name=bill&amp;age=18 https://example.com:8080# 发送 GET 请求到 https://example.com:8080,第二个参数是可选的 GET 请求参数curl -d name=bill&amp;age=18 https://example.com:8080# 发送 POST 请求到 https://example.com:8080,这里的 -d 表示的 POST 请求,第三个参数是可选的 POST 请求参数 增强开发体验类123456789101112131415clear# 清屏alias# 别名，相当于给一个命令设置快捷方式。比如 alias ll='ls -l' Tab 键位# 神奇的键位，在命令行主要用作自动补全，比如自动补全路径Arrow 键位# 命令行保存了你之前输入过的命令，上下箭头分别向前和向后显示你输入过的命令Ctrl 键位# Ctrl + A 将光标定位到当前行的开头， Ctrl + E 将光标定位到当前行的末尾# 在 Windows下，你也可以用 Home键 和 End键 实现相同功能 其他参考链接Linux Commands 集合]]></content>
      <tags>
        <tag>Git Bash</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['=='与'===']]></title>
    <url>%2Fpassages%2F%E2%80%98%3D%3D%E2%80%99%E4%B8%8E'%3D%3D%3D'%2F</url>
    <content type="text"><![CDATA[JavaScript中有两个用于判断两个值相等的符号：== 和 === 。分两种情况来考虑：基本数据类型和对象。 基本数据类型对于基本数据类型而言，=== 直接比较两个基本数据类型的值是否相等，不做类型转换，== 会试图进行类型转换再比较。123456789101112131415const s1 = '1';const s2 = '1';const n1 = 1;const n2 = 1.0;const b = true;console.log(s1 === s2); // trueconsole.log(s1 === n1); // falseconsole.log(s1 == n1); // trueconsole.log(n1 === n2); // trueconsole.log(n1 === b); // falseconsole.log(s1 == b); // trueconsole.log(n1 == b); // true 对象对于对象而言， == 和 === 效果完全一样，都是用于判断两个对象是否是同一个对象。1234567const o1 = &#123;&#125;;const o2 = &#123;&#125;;const o3 = o1; // 此时 o1 和 o3 指向堆内存中的同一个对象console.log(o1 == o2); // falseconsole.log(o1 === o2); // falseconsole.log(o1 === o3); // true 总结对于对象而言，== 和 === 效果是一样的，而且是比较两个对象变量是否指向内存中的同一块区域。对于基本数据类型而言，== 在面对两个不同类型的数据时，会试图进行类型转换再比较，而===则不会，直接比较值是否相等。 图片测试]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>宽松相等与严格相等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的求值策略]]></title>
    <url>%2Fpassages%2FJavaScript%20%E4%B8%AD%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[计算机科学中有个概念，叫做求值策略 Evaluation Strategy。它决定了变量之间，函数的实参与形参之间，值是如何传递的。求值策略主要有以下两种：按值传递和按引用传递。 按值传递与按引用传递 按值传递（call by value）是最常用的求值策略，函数的形参是被调用时函数实参的副本，修改函数的形参不会影响实参。 按引用传递（call by reference）是另一种求值策略，函数的形参是被调用时函数实参的隐式引用，不再是函数实参的副本，修改函数的形参会相应地影响到实参，因为函数实参传递给函数形参是引用本身。 按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。首先明确一点，在 JavaScript 中，不存在按引用传递。那么，是不是 JavaScript 中，变量之间，函数形参与实参之间都是按值传递呢？这是一个有些争议的问题，可以近似认为，JavaScript 中的值都是按值传递。下面分基本类型的值和引用类型的值两种情况来看。 基本类型的值对于基本类型的值，情况非常简单清晰，考虑以下代码：12345678// 示例1let name = 'Bill';const f = function (name) &#123; name = 'Sunny'&#125;;f(name);console.log(name); // Bill 上面代码说明，基本类型按照值传递，函数实参只是函数形参的一个副本。也就是说，函数被调用时，引擎会分配一块新的内存来存放从函数实参复制来的函数形参，所以接下来函数内部对形参所做的所有操作都是基于这块新的内存，函数实参自然不会受到影响。 引用类型的值对于引用类型的值，也就是对象，情况有些不一样。考虑以下代码：12345678910// 示例2let user = &#123; name: 'Bill'&#125;;const f = function (user) &#123; user.name = 'Sunny'&#125;;f(user);console.log(user.name); // Sunny 上面的代码说明，传入的对象 user 被函数 f 改变了，那么是否说明对于引用类型的值，是按照引用传递的吗？再考虑以下代码：12345678910111213// 示例3let user = &#123; name: 'Bill'&#125;;const f = function (user) &#123; user = &#123; name: 'Sunny' &#125;; // user = null, 结果一样&#125;;f(user);console.log(user.name); // Bill 如果 JavaScript 中的对象确实是按引用传递，传入的对象 user 的指向将被改变，那么上面代码最后一行应该打印 Sunny 。然而，实际打印出的仍然是 Bill ，这说明 JavaScript 中对象的值也不是按照引用传递的。事实上，对于对象而言，JavaScript 中函数实参传递给函数形参的是对象地址的一个副本，此时函数实参和形参都指向内存中同一块区域。所以在示例2中，修改 user.name 的值才会影响到原 user 对象。 总结对于这种求值策略，一种观点认为本质上仍然是按值传递，另一种观点认为是按共享传递。叫什么术语其实不重要，重要是理解其内在机制，即调用函数传参时，函数实参传递给函数形参的，是对象的内存地址的副本，既不是按值传递的对象副本，也不是按引用传递的内存地址本身。 参考链接Evaluation Strategy Call by value Call by reference Call by sharing http://dmitrysoshnikov.com/-Evaluation Strategy http://www.cnblogs.com/bosnma/p/4256108.html]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>求值策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源政策与跨域问题]]></title>
    <url>%2Fpassages%2F%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同源政策与跨域问题什么是浏览器的同源政策？维基百科对同源政策的定义。简单来说，为了保护用户的数据安全，浏览器规定，对于不同源的网页，它们之间以下的资源交互行为是被禁止的： 持久化数据无法获取，包括 Cookie, LocakStorage, IndexDB DOM 无法获取 AJAX 请求不能发送 仔细想想，以上3种行为对于用户安全来说，都是非常危险的。持久化数据通常含有用户的身份信息、登录态信息；至于 DOM 和 AJAX 这两者的权限都可能导致网页被植入恶意代码。 同源的严格定义如果说两个网页同源，是指以下 3 个部分都相同： 协议 主机 端口 举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是 80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 不受同源政策限制的资源交互行为需要明确的一点是，同源政策对于 HTML 标签是没有限制的，这使得网页可以从远程服务器获取资源文件，主要有以下标签： script 标签用来获取远程脚本文件，JSONP 跨域方式就是利用了这一点 link 标签用来获取远程 CSS 文件 image 标签用来获取远程图片文件 audio 标签用来获取远程音频文件 video 标签用来获取远程视频文件 如何规避同源政策来实现数据获取？在实际开发中，需要突破同源政策的限制来获取数据，主要是在使用 AJAX 向非同源服务器发送请求的场合。主要使用下面的几种方式来规避同源政策获取数据： 跨域资源共享 JSONP 服务器代理转发 跨文档通信 Cross-document messaging。这是 HTML5 为了解决跨文档通信引入的新 API：window.postMessage，但是这种方式能获取的内容是作了严格限制的，原因仍然是出于安全考虑。 WebSocket 跨域资源共享即Cross-Origin Resource Sharing。这是一个很大的话题，而且基本由后端实现 CORS 的支持，详情见参考链接 3 和 4，两篇文章讲的非常清晰。 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。123foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。此外， JSONP 的方式仅限于 GET 方法的网络请求。 架设代理服务器，转发请求架设一个同源的服务器，浏览器向该同源服务器发送 AJAX 请求，再由该服务器转发请求到外部非同源服务器。 跨文档通信WebSocket参考链接 同源政策及其规避方法 Same-origin policy 跨域资源共享 CORS 详解 - 阮一峰 CORS - MDN]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>同源政策</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass 快速入门]]></title>
    <url>%2Fpassages%2FSass%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Sass快速入门What is Sass?Sass 是 CSS 的一个扩展，它使得 CSS 的使用更加优雅和强大 Why Sass?Sass 的以下特性使得 Sass 成为一个成熟、稳定、强大的 CSS 扩展语言解析器。 变量变量声明在 Sass 中，使用 $ 前缀符号来表明这是一个变量。同时，变量是存在作用域的。123456789101112$highlight-color: #f90;nav &#123; $width: 100px; width: $width; color: $highlight-color;&#125;/* 编译后 */nav &#123; width: 100px; color: #f90;&#125; 变量引用变量可以引用另一个变量1234$highlight-color: #f90;.selected &#123; bodrer: 1px solid $highlight-color;&#125; CSS规则嵌套选择器嵌套123456789101112131415/* sass */#content &#123; background: #555; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background: #eee &#125;&#125;/* 编译后 */#content &#123; background: #555 &#125;#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background: #eee &#125; 父选择器的标识符&amp;Sass 提供父选择器的标识符 &amp; 主要是为了解决例如 :hover 等伪类的特殊情况。考虑下面这个情况：12345678article a &#123; color: blue; :hover &#123; color: red &#125;&#125;/* 编译后，这与我们预期不符 */article a &#123; color: blue &#125;article a :hover &#123; color: red &#125; 使用父选择器的标识符 &amp; 可以解决这个情况，&amp; 指代父选择器本身。12345678article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125;/* 编译后 */article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 群组选择器的嵌套1234567891011/* sass */.container &#123; h1, h2, h3 &#123; margin-bottom: .8em &#125;&#125;nav, aside &#123; a &#123; color: blue &#125;&#125;/* 编译后的css */.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125;nav a, aside a &#123; color: blue &#125; 属性嵌套123456789101112131415/* sass */nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125;/* 编译后的css */nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125; 属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。 导入在原生 CSS 中，有一个不常用的特性是 @import 规则，它允许在 .css 文件中导入其他的 .css 文件，但是这种导入的运行机制是：只有当执行到@import 语句时，浏览器才会去下载指定导入的 .css 文件，这导致页面加载起来会特别慢。 Sass 中实现的 @import 规则在生成 .css 文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个 CSS 文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。 嵌套导入12345678/* blue-theme.scss文件 */aside &#123; color: blue; background: white;&#125;/* base.css文件 */.blue-theme &#123; @import "blue-theme" &#125; 静默注释CSS 的标准注释会被保存在网页内，大多数时候这不是我们想要的结果。Sass 提供了另一种类似 C 语言风格的注释，称之为静默注释，因为这类注释不会被保存在网页内，即浏览网页的用户看不到它们。123456body &#123; color: #999; /* 这是CSS的标准注释 */ background: white; // 这是Sass提供的静默注释&#125; 混合器mixinSass 提供了混合器来实现多组样式规则的复用。比如下面定义了一个简单的混合器，目的是添加跨浏览器的圆角边框。12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后你可以使用 @include 来使用混合器：1234567891011121314.notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass 最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 何时使用混合器利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式（严谨的描述是：几条样式规则），那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。 判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个简洁的名字来描述这些属性修饰的样式，比如 rounded-corners, fancy-font, 或者 no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。 混合器在某些方面跟 CSS 类选择器很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在 html 文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述 html 元素的含义而不是 html 元素的外观。而另一方面，混合器是展示性的描述，用来描述一条 CSS 规则应用之后会产生怎样的效果。 在之前的例子中，.notice 是一个有语义的类名。如果一个 html 元素有一个 notice 的类名，就表明了这个 html 元素的用途：向用户展示提醒信息。rounded-corners 混合器是展示性的，它描述了包含它的 CSS 规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用可以写出整洁的 HTML和 CSS，因为使用语义化的类名也可以帮你避免重复使用混合器。为了保持你的 HTML 和 CSS 的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 有时候仅仅把属性放在混合器中还远远不够，可喜的是，Sass 同样允许你把 CSS 规则放在混合器中。 混合器中的 CSS 规则混合器中不仅可以包含属性，也可以包含 CSS 规则，即包含选择器和选择器中的属性：123456789101112131415161718192021222324252627// 定义一个混合器@mixin no-bullets &#123; list-style: none; li &#123; list-style-type: none; list-style-image: none; margin-left: 0; &#125;&#125;// 引用这个混合器ul.plain &#123; color: #444; @include no-bullets;&#125;// 编译后的 cssul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-type: none; list-style-image: none; margin-left: 0;&#125; 给混合器传参数，定制样式当 @include 混合器时，参数其实就是可以赋值给 CSS 属性值的变量。如果你写过 JavaScript，这种方式跟 JavaScrip t的 function 很像：1234567891011121314151617@mixin link-colors ($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;// 引入混合器a &#123; @include link-colors(blue, red, green);&#125;// 编译后的CSSa &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 给混合器设置默认参数值为了在 @include 混合器时不必传入所有的参数值，可以给参数指定一个默认值。这个默认值可以是任何有效的 CSS 属性值，甚至是其他参数的引用。比如：1234567891011121314151617181920212223242526272829303132// 定义指定参数默认值的混合器// 类似JavaScript中的函数@mixin link-colors ( $normal, $hover: $normal, $visited: gray )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;// 引用混合器a &#123; @include link-colors(red);&#125;// 编译后的CSSa &#123; color: red;&#125;a:hover &#123; color: red;&#125;a:visited &#123; color: gray;&#125; 选择器的继承选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过 @extend 语法实现，如下代码:123456789.error &#123; border: 1px red; background-color: #fdd;&#125;.serious-error &#123; extend .error; border-width: 3px;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
</search>
