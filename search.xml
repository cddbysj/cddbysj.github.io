<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[批量处理音频格式转换]]></title>
    <url>%2Fpassages%2F%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[之前，由于需要批量对不少音频文件做格式转换，以及批量对文件进行重命名等，所以在网上找了不少教程，最后汇总成了这边文章。 针对以上需求，主要包括两方面的操作： 使用 FFmpeg 这个强大的命令行工具，来实现音视频文件的录制和转换。 Windows 平台上针对文件的批处理任务，可以通过命令行的形式，也可以通过编写脚本的形式。 FFmpeg 的简单使用FFmpeg 功能非常强大，命令也较多，这里先简单以对话体的形式，给出一些常见的基本命令。 如何将 music.wav 音频文件转换为 music.mp3 音频文件？ 1ffmpeg -i music.wav music.mp3 如何将 music.wav 音频文件转换为指定比特率的 music.mp3 音频文件？ 12345# 转换为 192kbps 的 mp3 格式音频文件ffmpeg -i music.wav -b:a 192K music.mp3# 转换为 320kbps 的 mp3 格式音频文件ffmpeg -i music.wav -b:a 320K music.mp3 如何截取某段多媒体文件的部分片段，比如一段 30 分钟的音频？ 12# 截取从 mp3 文件从第 30 秒开始的 1 分钟片段ffmpeg -i input.mp3 -ss 00:00:30 -t 60 -b:a 320K output.mp3 如何提取某段视频文件内的音频？ 12# -vn 表示 disable videoffmpeg -i input.mp4 -vn audio_only.mp3 Windows 平台的批处理任务假设现在有一个目录，名字叫做 directory，需要进行处理的文件都放在这个目录内，包含 2 个 .wav 音频文件，2 个 .txt 文本文件，以及一个子目录 subdir，子目录内有一个 .txt 文本文件和一个 .wav 音频文件。目录树结构如下： 12345678directory -subdir -file_in_sub_dir.txt -song_in_sub_dir.wav -file01.txt -file02.txt -song01.wav -song02.wav 预备知识，一个完全合格的路径名，在 Windows 系统下包含 4 个部分：盘符、路径、文件名、扩展名。以下面这个文件为例，E:\path\to\file.txt： E: 是盘符 \path\to\ 是路径 file 是文件名 .txt 是扩展名 for in 是批处理脚本或者命令行中用来循环的语句，% 开头用来指代一个变量，通常只有一个字母，比如 %i 或者 %f。in 后面接 * 或者 *.* 表示匹配任意扩展名的文件，接 .mp3 表示匹配 .mp3 音频文件。do 后面接的命令表示对循环内的文件的操作。~ 是一个增强符号，后面跟特定的修饰符，假如 %i 这个变量指代的文件是 file.txt，那么： %~fi 表示将 %i 这个变量指代的文件扩展到一个完全合格的路径名：E:\path\to\file.txt，依次包含盘符、路径、文件名、扩展名。 %~di 仅将 %i 扩充到盘符：E: %~pi 仅将 %i 扩充到路径：\path\to\ %~ni 仅将 %i 扩充到文件名：file %~xi 仅将 %i 扩充到文件扩展名：.txt %~ti 仅将 %i 扩充到文件的日期和时间：2020\12\11 周五 14:15 %~zi 仅将 %i 扩充到文件的大小：38101292，单位是 bit 以上修饰符可以自由组合 12345678910111213141516171819202122# 打印目录内任意扩展名的直接子文件名（包含扩展名，不包含路径和盘符，比如这里的 song01.wav），即不包括子目录，也不包括子目录内的文件for %i in (*) do echo %i# 打印目录内扩展名为 wav 的直接子文件名（包含扩展名，不包含路径和盘符，比如这里的 song01.wav），即不包括子目录，也不包括子目录内的文件for %i in (*.wav) do echo %i # song01.wav song02.wav# 打印目录内扩展名为 wav 的直接子文件的文件名（不包含扩展名）for %i in (*.wav) do echo %~ni # song01 song02# 打印目录内扩展名为 wav 的直接子文件的路径和文件名（不包含扩展名）for %i in (*.wav) do echo %~pni # song01 song02# %~dpnxi 结合使用，等同于 %~fifor %i in (*.wav) do echo %~dpnxi# 与上面的命令效果相同for %i in (*.wav) do echo %~fi# 递归地打印目录内扩展名为 txt 的文件名for /r %i in (*.txt) do echo %i# 如果写在脚本内，用 %% 代替 % 来指代变量for %%i in (*) do echo %%i 下面进行模拟实践： 如何将一个目录内的所有 .wav 文件批量转换为比特率为 320kbps 的 .mp3 文件？ 12for %i in (*.wav) do ffmpeg -i %i -b:a 320K %~ni.mp3# song01.wav song02.wav 将转换为 song01.mp3 song02.mp3 如何将一个目录内的所有 .txt 文件批量转换为 .lrc 文件？ 12for %i in (*.txt) do ren %~ni.lrc# file01.txt file02.txt 将转换为 file01.lrc file02.lrc 如何写入脚本，方便以后复用？ 123for %%i in (*.wav) do ( ffmpeg -i %%i -b:a 320K %%~ni.mp3) 如何将其他格式的音频文件，比如 flac 转换为 .mp3 文件？ 12345# %%1 指代运行脚本时输入的第一个参数# 比如 task.bat flacfor %%i in (*.%%1) do ( ffmpeg -i %%i -b:a 320K %%~ni.mp3) 如何实现从命令行输入参数，源文件扩展名、转换后文件扩展名、转换后文件比特率，来实现特定格式和比特率的转换？ 12345# 将 wav 文件转换为 192kbps 比特率的 mp3 文件# task.bat wav mp3 192Kfor %%i in (*.%1) do ( ffmpeg -i %%i -b:a %3 %%~ni.%2) 如何将目录内的 txt 文件转换为同名的 lrc 文件（文件内容保持不变）？ 123for %%i in (*.txt) do ( ren %%i %%~ni.lrc) 参考链接 Windows 批处理 (cmd/bat) 常用命令小结 A quick guide to using FFmpeg to convert media files]]></content>
      <tags>
        <tag>编程</tag>
        <tag>音频格式转换</tag>
        <tag>多媒体</tag>
        <tag>ffmpeg</tag>
        <tag>工具软件</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写一个 Redux（二）]]></title>
    <url>%2Fpassages%2F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%20Redux%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这个系列分为 3 个部分（这篇文章是第 2 部分）： 最基本简单的 Redux 实现，以及如何与 React 结合使用 实现 React-Redux 增强 Redux 的实现，包括拆分合并 reducer，中间件等 react-redux 是 Redux 官方的 React 绑定库。 一个 UI 组件如果需要使用 Redux 来进行状态管理，需要做以下几件事： 在组件初始化时内获取 store 中的状态 订阅 store 内状态的改变，状态有更新则刷新组件状态 在组件卸载时移除对 store 状态的订阅 上面的逻辑，是每个组件与 Redux 结合使用时都需要的。react-redux 将上面的逻辑以高阶组件的形式复用了。 connectreact-redux 的一个基本核心是 connect 函数，它的作用是将一个感知不到 Redux 存在的展示型组件进行包装，将 store 中的状态以及改变状态的能力（dispatch(action)），注入到组件中。它可能是类似下面形式的函数： 12345const connect = wrappedComponent =&gt; &#123; return &#123; /* component with state and dispatch */ &#125;;&#125;; 加入上面提到的重复逻辑后： 12345678910111213141516171819202122232425262728import React from 'react';import store from './store'; // fake pathconst connect = () =&gt; WrappedComponent =&gt; &#123; return class Connect extends React.Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); this.dispatch = store.dispatch; &#125; componentDidMount() &#123; this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(store.getState()); &#125;); &#125; componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; &#123;...this.dispatch&#125; /&gt; ); &#125; &#125;;&#125;; 同时，考虑到组件可能只需要 store 中的部分 state 和 dispatch，或者多个组件使用同一个 store，但是所需的 state 和 dispatch 是不一样的，所以可以提供选项给组件来定制使用。为了简明易懂，新增的参数是名为 mapStateToProps mapDispatchToProps 的 2 个函数。光看函数名字就知道它的作用是什么： mapStateToProps 选择 store 中的哪些状态传入给组件 mapDispatchToProps 选择 store 中的哪些派发动作传入给组件 这里将这 2 个参数定义为函数，是为了获得 wrappedComponent 的作用域，以便访问到 store 实例。以 mapStateToProps 函数为例，它的用法如下： 123456789// state 在被包装组件的作用域内通过 store.getState() 获得// 假如 state = &#123; users, products &#125;const mapStateToProps = state =&gt; &#123; const &#123; users &#125; = state; return &#123; // 只返回需要的状态：users users, &#125;;&#125;; 类似地，mapDispatchToProps 函数的使用如下： 1234567// dispatch 即在被包装组件作用域内访问到的 store.dispatchconst mapDispatchToProps = dispatch =&gt; &#123; return &#123; // 只返回需要的派发动作：addUser addUser: user =&gt; dispatch(&#123; type: 'ADD_USER', user &#125;), &#125;;&#125;; 那么 connect 函数则变成： 1234567891011121314151617181920212223242526272829303132// connect.jsimport React from 'react';import store from './store'; // fake pathconst connect = (mapStateToProps, mapDispatchToProps) =&gt; WrappedComponent =&gt; &#123; const mappedState = mapStateToProps(store.getState()); const mappedDispatch = mapDispatchToProps(store.dispatch); return class Connect extends React.Component &#123; constructor(props) &#123; super(props); this.state = mappedState; this.dispatch = mappedDispatch; &#125; componentDidMount() &#123; this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(mapStateToProps(store.getState())); &#125;); &#125; componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; &#123;...this.dispatch&#125; /&gt; ); &#125; &#125;;&#125;; 注意上面的 connect.js 文件，存在一个问题：store 是由 Redux 的使用者（同时也是 React-Redux 的使用者）创建的，因此 connect.js 源码文件不可能提前引入 store。所以我们需要换一种方式，让 Redux 和 React-Redux 的使用者给我们传入 store 这个参数。React 中的数据传递有 2 种方式： 通过 props 传递 通过 Context API 传递 我们使用 Context API 将 store 进行传递，这样组件树上的每个组件都可以获取到 store。 Provider这里使用旧版本的 Context API 来写一个 Provider 组件。 Provider 组件接收一个 store 属性，也就是使用 createStore() 创建的 store。借助 Context API，Provider 的子孙组件可以访问到 store 属性。一般的做法是将应用程序的根组件用 Provider 组件包裹起来： 123456ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('root')); 这样，由于 connect 函数处在被包裹组件的作用域内，自然也可以通过 Context API 访问到 store。 1234567891011121314151617181920212223242526// Provider.jsimport React from 'react';import PropTypes from 'prop-types';export default class Provider extends React.Component &#123; static childContextTypes = &#123; store: PropTypes.shape(&#123; getState: PropTypes.func.isRequired, subscribe: PropTypes.func.isRequired, dispatch: PropTypes.func.isRequired, &#125;).isRequired, &#125;; constructor(props) &#123; super(props); this.store = props.store; &#125; getChildContext() &#123; return &#123; store: this.store, &#125;; &#125; render() &#123; return this.props.children; &#125;&#125; 借助 Context API，更新后的 connect.js： 12345678910111213141516171819202122232425262728293031323334353637// connect.jsimport React from 'react';const connect = (mapStateToProps, mapDispatchToProps) =&gt; WrappedComponent =&gt; &#123; return class Connect extends React.Component &#123; static contextTypes = &#123; store: PropTypes.shape(&#123; subscribe: PropTypes.func.isRequired, dispatch: PropTypes.func.isRequired, getState: PropTypes.func.isRequired, &#125;).isRequired, &#125;; constructor(props, context) &#123; super(props, context); this.store = context.store; this.state = mapStateToProps(this.store.getState()); this.dispatch = mapDispatchToProps(this.store.dispatch); &#125; componentDidMount() &#123; this.unsubscribe = this.store.subscribe(() =&gt; &#123; this.setState(mapStateToProps(this.store.getState())); &#125;); &#125; componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; &#123;...this.dispatch&#125; /&gt; ); &#125; &#125;;&#125;; 上面我们实现的 React-Redux 其实还很不完善，这里先根据实际的使用场景，做以下几点简单的改进： mapStateToProps 和 mapDispatchToProps 都应该提供缺省值，因为有的时候某个组件可能只需要 store 的部分状态而不需要派发动作，或者反过来只需要派发动作而不需要状态，这些都是可能的使用场景。我们将参数 mapStateToProps 的默认值设为：state =&gt; ({})，这样当用户不需要 store 中的状态时，可以缺省该参数；将参数 mapDispatchToProps 的默认值设为 dispatch =&gt; ({dispatch})，这样当用户不需要 store 中的派发动作时，可以缺省该参数。 connect 和 Provider 中的 store 的 PropType 规则可以提取出来，避免代码的冗余。 目前 connect 返回的组件名都是Connect，为方便调试，调整组件的静态属性 displayName。 目前，我们仅传递了 store.getState() 给 mapStateToProps，但是很可能在筛选过滤需要的状态时，需要依据组件自身的属性进行处理。因此，可以将组件自身的属性以第 2 个参数 ownProps 传递给 mapStateToProps，同样的原因，也将自身属性传递给 mapDispatchToProps。 在组件内订阅选中的 store 状态时，加入浅比较以优化性能。 简易 React-Redux 代码需要说明的是，这里的代码，很多的细节和边缘情况没有处理，性能也没有做优化。不过了解 React-Redux 的基本的内部原理应该差不多了。这里为了方便，所有文件都放在同一文件夹里面。核心代码在 connect.js 与 Provider.js 这两个文件内，此外还有 2 个工具属性的文件：浅比较和 store 类型校验。 storeShape.js1234567891011import PropTypes from 'prop-types';const storeShape = &#123; store: PropTypes.shape(&#123; subscribe: PropTypes.func.isRequired, dispatch: PropTypes.func.isRequired, getState: PropTypes.func.isRequired, &#125;).isRequired,&#125;;export default storeShape; shallowEqual.js123456789101112131415161718192021222324const shallowEqual = (objA, objB) =&gt; &#123; if (objA === objB) &#123; return true; &#125; const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) &#123; return false; &#125; // Test for A's keys different from B. const hasOwn = Object.prototype.hasOwnProperty; for (let i = 0; i &lt; keysA.length; i++) &#123; if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) &#123; return false; &#125; &#125; return true;&#125;;export default shallowEqual; connect.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React from 'react';import shallowEqual from './shallowEqual';import storeShape from './storeShape';const defaultMapStateToProps = (state, ownProps) =&gt; (&#123;&#125;);const defaultMapDispatchToProps = (dispatch, ownProps) =&gt; (&#123; dispatch &#125;);const getDisplayName = WrappedComponent =&gt; WrappedComponent.displayName || WrappedComponent.name || 'Component';const connect = (mapStateToProps, mapDispatchToProps) =&gt; WrappedComponent =&gt; &#123; // 1. 状态和派发动作的缺省处理 if (!mapStateToProps) &#123; mapStateToProps = defaultMapStateToProps; &#125; if (!mapDispatchToProps) &#123; mapDispatchToProps = defaultMapDispatchToProps; &#125; return class Connect extends React.Component &#123; // 2. 提取 store 类型校验的代码到 storeShape.js 文件 static contextTypes = storeShape; // 3. 为方便调试，调整组件的静态属性 displayName static displayName = `Connect($&#123;getDisplayName(WrappedComponent)&#125;)`; constructor(props, context) &#123; super(props, context); this.store = context.store; // 4. 提供组件自身属性作为第 2 个参数，以便基于此做筛选需要的状态和派发动作 this.state = mapStateToProps(this.store.getState(), this.props); this.dispatch = mapDispatchToProps(this.store.dispatch, this.props); &#125; componentDidMount() &#123; this.unsubscribe = this.store.subscribe(() =&gt; &#123; const mappedState = mapStateToProps(this.store.getState(), this.props); // 5. 在组件内订阅选中的 store 状态时，加入浅比较以优化性能。 if (shallowEqual(this.state, mappedState)) &#123; return; &#125; this.setState(mappedState); &#125;); &#125; componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; &#123;...this.dispatch&#125; /&gt; ); &#125; &#125;;&#125;;export default connect; Provider.js12345678910111213141516171819import React from 'react';import storeShape from './storeShape';export default class Provider extends React.Component &#123; static childContextTypes = storeShape; constructor(props) &#123; super(props); this.store = props.store; &#125; getChildContext() &#123; return &#123; store: this.store, &#125;; &#125; render() &#123; return this.props.children; &#125;&#125; 参考链接： Build Yourself a Redux 【重学 React】动手实现一个 react-redux 完全理解 redux（从零实现一个 redux）]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Redux</tag>
        <tag>造轮子</tag>
        <tag>React-Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写一个 Redux（一）]]></title>
    <url>%2Fpassages%2F%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%20Redux%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[实现 Redux这个系列分为 3 个部分（这篇文章是第 1 部分）： 最基本简单的 Redux 实现，以及如何与 React 结合使用 实现 React-Redux 增强 Redux 的实现，包括拆分合并 reducer，中间件等 Redux 的三大原则：单一状态树单一状态树，意味着只有一个 store 对象来保存应用程序的状态。这样的好处包括：易于 debug，实现数据持久化，实现诸如时间旅行等功能。 状态是只读的状态只能通过触发 action 来改变，action 可以理解为一种改变状态的意图，它是一个类似这样的 JavaScript 对象： 1234&#123; type: 'ADD_TODO', text: 'Learn Redux'&#125; 其中的 type 属性是必须要有的，其他的是可选属性。 通过这种形式，所有能改变状态的情形都被集中管理了，并且严格按照一定的顺序来执行。 As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes. 状态只能通过纯函数来改变action 是指意图，那么意图的具体内容是什么，则是由 reducer 来指定的。 reducer 是一个纯函数。入参是应用程序的前一个状态，我们不应该修改入参，而是应该返回一个新的状态。一个纯函数必须满足以下两个条件： 相同的输入，每次都得到相同的输出。 不应该产生副作用，包括但不限于：更改入参，修改局部状态，发起网络请求，读写数据库，触发事件，打印日志等。 纯函数与非纯函数举例： 12345678910111213141516// 非纯函数，由于 Math.random() 存在，每次得到的输出是不一样的const getRandomNum = x =&gt; x + Math.random();// 非纯函数，每次得到的输出是不一样的const getTime = () =&gt; Date.now();// 非纯函数，依赖外部变量 baselet base = 9;const getNumber = x =&gt; base + x;// 非纯函数const getUsers = async id =&gt; &#123; const response = await fetch(`https://example.com/user?id=$&#123;id&#125;`); const json = await response.json(); return json;&#125;;// 纯函数const square = x =&gt; x * x; 基本实现，不考虑视图层先不考虑拆分 reducer，中间件，以及一些边缘情况，只考虑最常见的使用情形，Redux 的核心是下面的几个函数： createStore(reducer) 入参是 reducer，返回一个 store 对象。该对象包含以下 3 个方法 getState() 返回一个新的状态对象 subscribe(callback) 订阅一个回调函数，当状态变化时，该回调会被执行 dispatch(action) 分发 action Redux 的使用者编写的代码主要是 reducer，来看看 reducer 函数的签名： 1234567891011121314151617181920212223const reducer = (state = &#123; todos: [] &#125;, action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; todos: [ &#123; id: action.id, text: action.text, completed: false &#125;, ...state.todos, ], &#125;; case 'REMOVE_TODO': return &#123; todos: state.todos.filter(todo =&gt; todo.id !== action.id), &#125;; case 'TOGGLE_TODO': return &#123; todos: state.todos.map(todo =&gt; todo.id === action.id ? &#123; ...todo, completed: !todo.completed &#125; : todo ), &#125;; default: return state; &#125;&#125;; 我们试着使用一下上面定义的 reducer： 12345const state0 = reducer(undefined, &#123; type: 'ADD_TODO', id: 1, text: 'Learn JavaScript',&#125;); 现在 state0 的状态如下： 123&#123; todos: [&#123; id: 1, text: 'Learn JavaScript', completed: false &#125;];&#125; 再来一次： 1234const state1 = reducer(state0, &#123; type: 'TOGGLE_TODO', id: 1,&#125;); 现在 state1 的状态如下： 123&#123; todos: [&#123; id: 1, text: 'Learn JavaScript', completed: true &#125;];&#125; 当然，持续的创建这么多变量来存储某个中间状态没有必要，上面的两步可以用下面的方式实现： 123456const actions = [ &#123; type: 'ADD_TODO', id: 1, text: 'Learn JavaScript' &#125;, &#123; type: 'TOGGLE_TODO', id: 1 &#125;,];const state = actions.reduce(reducer, undefined); 注意上面的 reduce 函数的使用，这也是 reducer 被叫做 reducer 的原因。 可以想象，createStore(reducer) 函数的雏形大致如下： 12345678910// v0.0const createStore = reducer =&gt; &#123; let state = undefined; return &#123; getState: () =&gt; state, dispatch: action =&gt; &#123; state = reducer(state, action); &#125;, &#125;;&#125;; 尝试下使用我们的 createStore，传入之前定义的 reducer： 1234567const store = createStore(reducer);store.dispatch(&#123; type: 'ADD_TODO', id: 1, text: 'Learn React' &#125;);store.getState();// state -&gt; todos: [&#123; id: 1, text: 'Learn React', completed: false &#125;]store.dispatch(&#123; type: 'TOGGLE_TODO', id: 1 &#125;);store.getState();// state -&gt; todos: [&#123; id: 1, text: 'Learn React', completed: true &#125;] 按照上面的代码，我们创建的 store 已经可以如预期般运行了，但是还有 2 点需要改进： 第 1 点是每次分发 action 改变了状态后，我们需要手动调用 getState() 才能得到更新后的状态，所以可以考虑在返回的对象中，添加一个订阅函数，每当状态更新后即触发该订阅函数自动执行。 第 2 点是需要对 action 做一些验证，比如 action 必须是一个对象，并且必须包含一个 type 属性等。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109///////////////////////////////// Mini Redux implementation /////////////////////////////////const validateAction = action =&gt; &#123; if (!action || typeof action !== 'object' || Array.isArray(action)) &#123; throw new Error('Action must be an object'); &#125; if (typeof action.type === 'undefined') &#123; throw new Error('Action must hava a type'); &#125;&#125;;const createStore = reducer =&gt; &#123; let state = undefined; let subscribers = []; const store = &#123; getState: () =&gt; state, subscribe: handler =&gt; &#123; subscribers.push(handler); return () =&gt; &#123; const index = subscribers.findIndex(handler); if (index &gt; -1) &#123; subscribers.splice(index, 1); &#125; &#125;; &#125;, dispatch: action =&gt; &#123; validateAction(action); subscribers.forEach(sub =&gt; sub()); state = reducer(state, action); &#125;, &#125;; store.dispatch(&#123; type: '@@redux/INIT' &#125;); return store;&#125;;//////////////////////// Our action types ////////////////////////const ADD_TODO = 'ADD_TODO';const TOGGLE_TODO = 'TOGGLE_TODO';const REMOVE_TODO = 'REMOVE_TODO';/////////////////// Our reducer ///////////////////const initialState = &#123; todos: [], nextTodoId: 1 &#125;;const reducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case ADD_TODO: return &#123; ...state, todos: [ &#123; id: state.nextTodoId, text: action.text, completed: false &#125;, ...state.todos, ], nextTodoId: state.nextTodoId + 1, &#125;; case TOGGLE_TODO: return &#123; ...state, todos: state.todos.map(todo =&gt; todo.id === action.id ? &#123; ...todo, completed: !todo.completed &#125; : todo ), &#125;; case REMOVE_TODO: return &#123; ...state, todos: state.todos.filter(todo =&gt; todo.id !== action.id), &#125;; default: return state; &#125;&#125;;///////////////// Our store /////////////////const store = createStore(reducer);///////////////////////////////////////////////// Render our app whenever the store changes /////////////////////////////////////////////////store.subscribe(() =&gt; &#123; ReactDOM.render( &lt;pre&gt;&#123;JSON.stringify(store.getState(), null, 2)&#125;&lt;/pre&gt;, document.getElementById('root') );&#125;);//////////////////////// Dispatch actions ////////////////////////store.dispatch(&#123; type: ADD_TODO, text: 'Hello Redux',&#125;);store.dispatch(&#123; type: TOGGLE_TODO, id: 1,&#125;);store.dispatch(&#123; type: REMOVE_TODO, id: 1,&#125;); 与 React 结合使用上面的代码订阅了 () =&gt; ReactDOM.render()，每当状态发生变化时，会在页面上重新渲染更新后的状态内容。接着我们更进一步，将 React 组件与上面实现的 Mini Redux 一起使用。另外，Redux 并非只能与 React 一同使用，其他视图库也能与 Redux 结合使用。比如 Vue 自己实现的状态管理库 Vuex 其实跟 Redux 基本是一个东西。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990////////////////////////////////// Mini Redux work with React //////////////////////////////////import React from 'react';import ReactDOM from 'react-dom';// 此处省略上面的 createStore 及 reducer 这 2 个函数的代码const store = createStore(reducer);// 这里为了方便，没有做组件拆分class TodoApp extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; ...props.store.getState(), newTodoText: '', &#125;; &#125; componentDidMount() &#123; this.unsubscribe = this.props.store.subscribe(() =&gt; this.setState(this.props.store.getState()) ); &#125; componentWillUnmount() &#123; this.unsubscribe(); &#125; addTodo = () =&gt; &#123; this.props.store.dispatch(&#123; type: ADD_TODO, text: this.state.newTodoText, &#125;); &#125;; toggleTodo = id =&gt; &#123; this.props.store.dispatch(&#123; type: TOGGLE_TODO, id, &#125;); &#125;; removeTodo = id =&gt; &#123; this.props.store.dispatch(&#123; type: REMOVE_TODO, id, &#125;); &#125;; render() &#123; const &#123; newTodoText, todos &#125; = this.state; return ( &lt;div&gt; &lt;input value=&#123;newTodoText&#125; onChange=&#123;event =&gt; this.setState(&#123; newTodoText: event.target.value &#125;)&#125; type="text" /&gt; &lt;button onClick=&#123;this.addTodo&#125;&gt;Add todo&lt;/button&gt; &lt;ul&gt; &#123;todos.map(todo =&gt; ( &lt;li key=&#123;todo.id&#125; style=&#123;&#123; display: 'flex', width: '500px', margin: '20px', borderBottom: '1px solid #ccc', &#125;&#125; &gt; &lt;span onClick=&#123;() =&gt; this.toggleTodo(todo.id)&#125; style=&#123;&#123; textDecoration: todo.completed ? 'line-through' : 'none', flex: 1, &#125;&#125; &gt; &#123;todo.text&#125; &lt;/span&gt; &lt;span onClick=&#123;() =&gt; this.removeTodo(todo.id)&#125;&gt;×&lt;/span&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;TodoApp /&gt;, document.getElementById('root')); 好了，一个最简单原始的 Mini Redux 实现了，借助 create-react-app 脚手架，上面的代码应该可以与 React 相结合并正常运行。 但是可以看出，Redux 本身只专注于状态层，负责以可预测的方式集中管理状态。如果需要和视图层绑定，则还有不少工作要做。 以上面的代码为例，我们需要做几件事： 在组件初始化时，将组件所依赖的状态（在这里是 todos 和 nextTodoId 这两个属性）注入（通过 props 属性的方式传入）到组件本身的状态里。 在组件加载后，订阅 store 状态的变化，每当状态更新，就会调用 this.setState(this.props.store.getState())，使得组件状态与 store 状态同步。与此同时，将订阅的返回值保存为一个实例 this.unsubscribe，方便取消订阅。 每当组件内由于用户交互等方式，需要更新状态时，调用 this.props.dispatch(action) 更新 store 内的状态。由于第 2 步的订阅，组件的状态也相应地更新。 在组件卸载时，取消订阅。 这些逻辑应该可以被抽取成更加通用的代码以便复用。实际上，React-Redux 这个库就是提供了一套更加通用的方法来实现 Redux 和 React 的绑定。手动实现 React-Redux 见下一篇。 参考链接： Build Yourself a Redux 【重学 React】动手实现一个 react-redux 完全理解 redux（从零实现一个 redux）]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Redux</tag>
        <tag>造轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金属表面处理]]></title>
    <url>%2Fpassages%2F%E9%87%91%E5%B1%9E%E8%A1%A8%E9%9D%A2%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[在钢、铁、合金为代表的现代工业社会，金属材料在各类产品上的运用非常广泛。金属材料以其优良的力学性能、加工性能和独特的表面特性，成为现代设计中的一大主流材质。也因多数金属材料有着易加工、视觉效果好、呈现出的设计感强烈、表面处理手段丰富，首当其冲也受到了设计师们的喜爱。 金属表面的预处理在对金属材料进行表面处理之前，金属材料的表面有一些瑕疵，这些瑕疵的处理就需要用到预处理工序，以使物件达到可进行表面处理的状态。 预处理的工艺和方法很多，常用工艺主要为：机械处理、化学处理、电化学处理。 机械处理：如切削、研磨、喷砂等加工清理物件表面的鏽蚀和氧化皮等，将表面加工成平滑、或具有凹凸模样； 化学处理：清理物件表面的油污、鏽蚀、及氧化皮等。 电化学处理：则主要用于强化化学除油、浸蚀的过程，有时也用于弱浸蚀时活化金属製品的表面状态。 金属表面的处理技术表面处理技术是产品美观的必备手段，对物件（产品）起到保护和美化产品外观的作用，主要分：着色工艺和肌理工艺。 表面着色工艺金属材料的表面着色工艺是采用热处理、机械、化学、电解等方法，为物件表面镀上各种色泽的表面层。 化学着色：将经过氧化处理过后的金属材料，浸入到有机或无机染料溶液中，染料渗入金属表面氧化膜的空隙中，发生化学、或物理作用从而实现着色。 电解着色：在特定的溶液中，通过电解处理方法，使金属表面发生反应而生成带有颜色的膜层。过程中，金属阳离子会渗入到金属表面的氧化膜空隙中，从而使氧化膜产生不同的色系。而色系根据所用材料的调配而定，常见的是红、青、蓝，以及青铜色系、棕色系、灰色系等。 阳极氧化着色：英文名叫 Anodizing。在特定的溶液中，以化学或电解的方法进行处理，生成吸附染料的膜层，在染料的作用下着色。阳极氧化的染色色彩艳丽，色域宽广，但目前应用范围仅限于铝、锌、镉、镍等几种金属材料。 微弧氧化着色：英文名叫 Microarc oxidation，简称 MAO。是在电解质溶液中施加高电压，在材料表面原位生长陶瓷氧化膜的过程。由于氧化液大多采用硷性溶液，对环境污染小。微弧化膜具备了阳极氧化膜和陶瓷喷涂层两者的优点，这项技术工艺被认为是阳极氧化的替代技术。目前应用范围仅限于铝、镁、钛等几种金属材料。 镀覆着色：采用电镀、化学镀、物理镀等方法，在金属表面沉积金属、金属氧化物或合金等，形成具有金属特性的均匀膜层。 涂覆着色：在金属表面上采用浸涂、刷涂、喷涂等方法涂覆有机涂层。 发蓝着色：发蓝又叫珐琅。将经过粉碎、研磨的珐琅釉料涂覆在金属製品表面，经乾燥、高温烧制等製作过程后形成膜层。 热处理着色：将金属物件置于氧化环境中进行加热处理，时期表面形成黛色氧化膜。热处理时会随着加热时间的不同、氧化膜厚度的不同，表面处理后的颜色会有所不同。 传统着色技术：包括做假锈、热浸镀锡、鎏金、鎏银以及生成色斑等。 表面肌理工艺表面锻打使用不同形状的锤头对金属物件进行锻打，从而形成不同形状的肌理，具有层次感、装饰性。 表面抛光利用软性抛光工具，或磨料颗粒，或其他抛光介质对物件表面进行装饰加工，常见手法有电解抛光、喷砂抛光、机械抛光、手工抛光等。抛光仅能得到光滑表面、或具有镜面光泽的表面，并不能提高物件的精度、耐用性、抗腐蚀等功能。 表面研磨拉丝利用研磨材料通过研磨器具对物件表面进行加工，在物件表面形成类似线纹，体现出「金属质感」的装饰效果。根据拉丝后纹路的不同可分为：直纹拉丝、乱纹拉丝、波纹、旋纹。 技术特点：拉丝处理可使金属表面获得非镜面般金属光泽，同时拉丝处理也可以消除金属表面细微的瑕疵。 表面喷砂是采用压缩空气为动力，以形成高速喷射束，将喷料高速喷射到需处理工件表面，使工件表面的外表或形状发生变化，获得一定的清洁度和不同的粗糙度的一种工艺。 技术特点: 实现不同的反光或亚光。 能清理工件表面的微小毛刺，并使工件表面更加平整，消除了毛刺的危害，提高了工件的档次。 清除预处理时遗留的残污，提高工件的光洁度，能使工件露出均匀一致的金属本色，使工件外表更美观，好看。 表面镶嵌在金属表面刻画出阴纹，嵌入金银丝或金银片等质地较软的金属材料，然后打磨平整，呈现出华美的装饰效果。如中国传统工艺乌铜走银，清朝的铜嵌银丝高足鬲式炉。 表面蚀刻使用化学酸进行腐蚀而得到的一种斑驳、沧桑的装饰效果，丰富了设计的细节。常用工艺是：在金属物件表面涂上一层沥青，接着在沥青的表面上刻画纹饰，将需要腐蚀部分的金属露出，腐蚀时根据纹饰要求的大小，选择浸入化学酸溶液，或喷刷溶液腐蚀。 参考 金屬材料及表面處理技術]]></content>
      <tags>
        <tag>金属表面处理</tag>
        <tag>着色</tag>
        <tag>制造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 的生命周期方法]]></title>
    <url>%2Fpassages%2FReact%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是生命周期方法可以这样理解，生命周期方法是 React 提供的钩子函数，使得我们可以介入组件的生命周期，比如组件的挂载过程（组件实例被创建并被插入到 DOM 中）和更新（组件的 state 或者 props 改变）过程。 总的来说，组件的挂载过程有 4 个钩子函数，并按照下面的顺序依次调用： constructor(props)创建组件实例并将其插入 DOM 时调用。通常在此钩子函数内设置组件的初始状态以及绑定类方法。 static getDerivedStateAndProps(props, state)组件在初始挂载以及后续每次更新时，该钩子函数都会在 render() 函数之前被调用。此外，由于这是一个静态方法，无法访问组件实例。 render()对于类组件而言，这是一个必须声明的钩子函数，该函数返回一个 React 元素，以作为组件的渲染结果输出。此钩子函数必须为纯函数，不应该在这里更改组件的 state 和 props。 componentDidMount()当组件挂载过程完成，会被调用一次。一般做法是，在此钩子函数内获取异步数据并保存到组件的状态。 组件的更新过程有 5 个钩子函数，并按照下面的顺序依次调用： static getDerivedStateFromProps(prop, state)同上面的挂载过程 shouldComponentUpdate(nextProps, nextState)当组件的 state 或者 props 发生改变时被调用，返回一个布尔值以告诉 React 是否执行此次更新。通常的用例是：在大型应用程序中被用作性能优化。 render()同上面的挂载过程 getSnapshotBeforeUpdate(prevProps, prevState, snapshot)在最近的一次渲染结果被提交到 DOM 之前被调用。 componentDidUpdate()更新之后被立即调用，不包括初始渲染。通常用来做 DOM 操作或者异步获取数据。 此外，组件的卸载过程也有 1 个钩子函数： componentWillUnmount()在组件被销毁之前调用，通常在此钩子函数内做一些清理工作。 最后，componentDidCatch(error, info) 被用来进行错误处理，可以将捕获的错误信息保存到组件状态，以进行相应的处理。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式 Web 设计原则]]></title>
    <url>%2Fpassages%2F%E5%93%8D%E5%BA%94%E5%BC%8F%20Web%20%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[媒体查询媒体查询是 CSS3 中引入的一项新技术，它可以根据不同的可视窗口大小显示不同的布局。可视窗口是用户在网页上的可见区域，根据访问网站的设备不同而不同。 媒体查询由媒体类型组成，如果媒体类型与展示网页的设备类型匹配，则应用对应的样式。你可以在媒体查询中用上你想用的选择器和样式。 下面是一个媒体查询的例子，当设备宽度小于或等于 100px 时返回内容：1@media (max-width: 100px) &#123; /* CSS Rules */ &#125; 图片自适应用 CSS 来让图片自适应其实很简单。不要使用绝对单位：1img &#123; width: 720px; &#125; 你应该使用：12345img &#123; max-width: 100%; display: block; height: auto;&#125; max-width 属性能让图片以 100% 的最大宽度适应其父容器的宽度，但图片不会拉伸得比原始宽度还宽。将 display 属性设置为 block 可以让 &lt;image&gt; 标签从内联元素（默认值）更改为块级元素。设置 height 属性为 auto保持图片的原始宽高比。 针对高分辨率屏幕应使用视网膜图片为优化图片在高分辨率设备下的显示效果，最简单的方式是定义它们的 width 和 height 值为源文件宽高的一半。 这是一个图片宽高设置为源文件一半的例子：1234&lt;style&gt; img &#123; height: 250px; width: 250px; &#125;&lt;/style&gt;&lt;img src="coolPic500x500" alt="一张高质量的图片"&gt; 使排版根据设备尺寸自如响应除了用 em 或 px 去设置文本大小, 你还可以用视窗单位来做响应式排版。视窗单位还有百分比，它们都是相对单位，但却基于不同的参照物。视窗单位相对于设备的视窗尺寸 (宽度或高度) ，百分比是相对于父级元素的大小。 四个不同的视窗单位分别是： vw：如 10vw 的意思是视窗宽度的 10%。 vh： 如 3vh 的意思是视窗高度的 3%。 vmin： 如 70vmin 的意思是视窗中较小尺寸的 70% (高度 VS 宽度)。 vmax： 如 100vmax 的意思是视窗中较大尺寸的 100% (高度 VS 宽度)。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>响应式 Web 设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语丝]]></title>
    <url>%2Fpassages%2F%E8%AF%AD%E4%B8%9D%2F</url>
    <content type="text"><![CDATA[日剧《女王的教室》中天海佑希的一段话告诉你人为什么要读书:“如果有活到老学到老的想法，那就有无限的可能性。失去好奇心的一瞬间，人就死了。” 更高的教育，给了我们脱离原生家庭的影响建立自己价值观的可能。 龙应台对儿子说过:“我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。” 对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。所有其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧。 -赫尔曼•黑塞]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端框架 Vue 学习笔记之 Reactivity]]></title>
    <url>%2Fpassages%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%20Vue%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%20Reactivity%2F</url>
    <content type="text"><![CDATA[这一篇笔记的重点在于探究 Vue 的响应式特性，并动手实现一个简易的响应系统。 什么是响应式在前端框架这个语境下是指，状态的改变引起相应的 DOM 随之改变。 我们先从一个最简单的情形说起，假如有 2 个变量 a 和 b，我们要实现的需求是，让变量 b 的值总是变量 a 的 10 倍。 123456let a = 3;let b = a * 10;console.log(b); // 30a = 4;b = a * 10;console.log(b); // 40 上面代码中，每次变量 a 发生变化，必须手动更新变量 b 的值，才能使得两者始终保持 10 倍的关系。如何声明式地表示这种关系呢？ 在 Excel 中，我们是通过函数来实现类似效果的： No. A B 1 4 40(fx = A1 * 10) 在程序语言中，我们想要的是一个类似这样的函数： 123onAChanged(() =&gt; &#123; b = a * 10;&#125;); 每当变量 a 的值发生改变，作为回调函数参数的这个更新函数便执行（即上面代码中的箭头函数），这样问题就解决了。那么如何实现这样一个函数？ 先将前面问题稍微转化一下，使之更符合 Web 开发的实际情况。 我们现在有一个 &lt;span&gt; 标签 b1，它的值是状态变量 a 的 10 倍： 1&lt;span class="cell b1" /&gt; 123onStateChanged(() =&gt; &#123; document.querySelector(".cell.b1").textContent() = state.a * 10;&#125;); 上面的代码实际上声明式地表达了状态与 DOM 之间的关系，不过我们可以更进一步抽象成这样： 1&lt;span class="cell b1"&gt; &#123;&#123; state.a * 10 &#125;&#125; &lt;/span&gt; 123onStateChanged((state) =&gt; &#123; view = render(state);&#125;); 从上面的代码我们隐约看到了一个 UI 库的雏形，最关键的是这行代码：view = render(state)，它实际上高度抽象地概括了现代前端框架存在的根本原因：通过一种映射，将应用程序的 UI 与状态同步。这里面涉及到很多虚拟 DOM 和原生 DOM 的细节，所以我们这里先关注外面的回调函数即 onStateChanged 是如何实现的。 它可能是这样实现的： 123456789let update;const onStateChanged = (_update) =&gt; &#123; update = _update;&#125;;const setState = (newState) =&gt; &#123; state = newState; update();&#125;; 上面代码中，我们将 update 函数保存在某处，同时要求用户总是通过调用一个函数 setState 来更新状态，而不是任意地操作状态。setState 函数所做的工作如下：将旧状态替换为新状态，然后调用 update 函数。这一过程与 React 的响应式系统很像，在应用状态改变时要求用户手动调用 setState 函数： 12345onStateChanged(() =&gt; &#123; view = render(state);&#125;);setState(&#123; a: 5 &#125;); 而在 Vue 中，用户可以直接操作状态，状态改变会自动触发 onStateChanged 内更新函数的执行，不再需要用户手动调用 setState。这是通过 ES5 的全局 API Object.defineProperty() 来使得状态具有响应特性。 Getter / Setter先热下身，利用 Object.defineProperty() 动手实现一个 convert() 函数，需求如下： 接受一个对象类型的参数 将该对象的属性就地转化为 getter/setter 该对象应该保持原有的行为，同时在被访问和修改时打印 get/set 操作 123456789101112131415161718192021222324252627// 实现function convert(obj) &#123; Object.keys(obj).forEach((key) =&gt; &#123; let internalValue = obj[key]; Object.defineProperty(obj, key, &#123; get() &#123; console.log(`get key "$&#123;key&#125;": $&#123;internalValue&#125;`); return internalValue; &#125;, set(newValue) &#123; console.log(`set key "$&#123;key&#125;" to: $&#123;newValue&#125;`); internalValue = newValue; &#125;, &#125;); &#125;);&#125;// 用例const obj = &#123; foo: 0,&#125;;convert(obj);obj.foo; // get key "foo": 0obj.foo = 99; // set key "foo" to: 99obj.foo; // get key "foo": 99 Dependency Tracking很明显，以上所做的还不能实现预期的效果，我们还需要利用发布/订阅模式实现 Dependency Tracking 依赖追踪。 需求如下： 创建一个 Dep 类，这个类有两个方法 depend() 和 notify 创建一个 autorun 函数，它接受一个 update 更新函数作为参数 在 update 更新函数内部，你可以通过调用 dep.depend() 显式地依赖一个 Dep 类的实例 在这之后，你可以通过调用 dep.notify() 使得 update 更新函数再次触发被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 实现class Dep &#123; constructor() &#123; this.subscribers = new Set(); &#125; depend() &#123; if (activeUpdate) &#123; // register the current active update as a subscriber this.subscribers.add(activeUpdate); &#125; &#125; notify() &#123; // run all subscriber functions this.subscribers.forEach((sub) =&gt; sub()); &#125;&#125;// 注意 autorun 函数的实现// activeUpdate 这个全局变量标记了 update 函数当前是否被执行let activeUpdate;function autorun(update) &#123; function wrappedUpdate() &#123; activeUpdate = wrappedUpdate; update(); activeUpdate = null; &#125; wrappedUpdate();&#125;// 用例const dep = new Dep();autorun(() =&gt; &#123; // 调用 dep.depend() // 使得 update 函数被添加到 dep 的订阅列表 subscribers 中 dep.depend(); // 此处我们在 update 函数内只做了一件事即打印 "updated" console.log("updated");&#125;);// 应该打印: "updated"// 因为前面 autorun 的执行// 使得 update 函数被 dep 订阅// 在其他任何地方调用 dep.notify() 方法都将再次触发 update 函数的执行dep.notify();// 应该打印: "updated" Mini Data Observer将前面实现的 convert() 和 autorun() 这 2 个函数结合起来，同时将 convert() 函数重命名为 observe()。实现的需求如下： observe 函数接受一个对象类型的参数，并将该对象的所有属性转化成响应式的。每个被转化的属性都被分配到一个 Dep 实例，该实例跟踪着一个订阅了更新函数的列表，每当某个属性的 setter 被调用，就重新调用订阅的更新函数。 autorun 函数接受一个 update 函数作为参数，同时在 update 函数所订阅的属性被修改时，update 函数将被触发执行。如果 update 更新函数在执行期间依赖于某个属性，则该更新函数订阅了该属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;div&gt; &lt;button onclick="down()"&gt;-&lt;/button&gt; &lt;span class="count"&gt;&lt;/span&gt; &lt;button onclick="up()"&gt;+&lt;/button&gt;&lt;/div&gt;&lt;script&gt; // 实现 class Dep &#123; constructor() &#123; this.subscribers = new Set(); &#125; depend() &#123; if (activeUpdate) &#123; this.subscribers.add(activeUpdate); &#125; &#125; notify() &#123; this.subscribers.forEach((sub) =&gt; sub()); &#125; &#125; function observe(obj) &#123; Object.keys(obj).forEach((key) =&gt; &#123; let internalValue = obj[key]; let dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; dep.depend(); return internalValue; &#125;, set(newValue) &#123; const isChanged = internalValue !== newValue; if (isChanged) &#123; internalValue = newValue; dep.notify(); &#125; &#125;, &#125;); &#125;); &#125; let activeUpdate; function autorun(update) &#123; function wrappedUpdate() &#123; activeUpdate = wrappedUpdate; update(); activeUpdate = null; &#125; wrappedUpdate(); &#125; // 用例 const state = &#123; count: 0, &#125;; const $count = document.querySelector(".count"); $count.textContent = state.count; observe(state); autorun(() =&gt; &#123; console.log(`"state.count" updated: $&#123;state.count&#125;`); // 每当 state.count 值改变，触发 DOM 更新 $count.textContent = state.count; &#125;); function up() &#123; state.count++; &#125; function down() &#123; state.count--; &#125;&lt;/script&gt; 上面的代码实现了一个简单的 Data Observer，同时需要指出，有一些边缘情况没有考虑在内，比如清除陈旧的依赖、对数组的处理、对新添加属性的处理。]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[icon 设计分享]]></title>
    <url>%2Fpassages%2Ficon%20%E8%AE%BE%E8%AE%A1%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[分享 3 个 icon 是如何制作出来的。 eye heart location]]></content>
      <tags>
        <tag>设计</tag>
        <tag>icon</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高质量在线网站集合]]></title>
    <url>%2Fpassages%2F%E9%AB%98%E8%B4%A8%E9%87%8F%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[资源聚合导航NiceTool+在线实用工具聚合网站。涵盖以下各方面： 生活常用 教育学习 办公辅助 图片视频 网络工具 程序开发 NeetsNeets 是你的追剧管家，你可以把目前追的各种影视、综艺等记录下来，做追剧清单，更新永不落。Neets 本身不提供观看渠道，只是各种来源的搬运工，并且一般会有几个观看源可以选择。 虫部落资源搜索网站。 仿知网仿知网是一个完全可以代替知网的精品网站；是一个非常强大的论文搜索网站。首先这个网站的论文检索结果和知网的搜索结果基本一样，而且这个网站每个账号前期免费提供论文下载，当你的下载次数没了，你完全可以用其它邮箱再注册其它账号使用；当然，如果你不想再注册账号，这个网站提供一块钱随意下载论文一天，也是非常值得尝试。总体而已，如果需要下载论文，这个网站是一个非常好的选择。 全球电视直播全国电视直播是一个功能非常强大的电视直播网站，真的是十分良心；电脑推荐使用 edge 浏览器打开或者使用其它浏览器打开，然后右键复制视频地址，potplayer 打开链接也可以播放；注意：电脑直接用浏览器打开可能播放不了，手机可以正常播放。它支持几百个电视直播的网站，几乎拥有一般电视直播网站拥有的所有频道，它还支持港澳台卫视，国外电视等等。它还有的特点就是电视直播播放速度和加载速度非常之快，画质也是十分高清；最后，网站界面简洁，没有任何广告；总体体验非常不错的一个网站。 医学微视医学微视是一个以视频的方式分享各种医学知识的良心网站，强烈推荐。它是中国医学科学院健康科普研究中心监制的一个网站，并且不提供销售任何产品，它以短视频的形式帮助你了解各种疾病，通俗易懂，让你轻松了解各种医学知识；当我们遇到不懂的医学知识或者健康问题，直接利用这个网站，找到对应的疾病，就可以轻松找到对应的视频。 Bookset是一个质量很高的精品电子书籍网站。首先，它提供了丰富的书籍，并且网站的电子书籍的更新频率非常快，网站的电子书籍你也都可以直接下载。它还提供强大的电子书籍搜索功能，让你轻松可以找到你需要的电子书籍。它的书单功能和排名功能可以让你发现很多高质量的电子书籍，它的书单功能提供了豆瓣 2018 年度读书榜单，香港大学推荐的 50 本经典书籍，亚马逊推荐 100 本必读书，它的排名功能也把电子书籍按照豆瓣评分精心排列。最后，网站的标签分类功能让你可以按照电子书籍的种类查找电子书籍，网站的书籍合集列表会让你发现更多高质量的书籍合集。 第一 PPT第一 PPT 是一个完全免费的 PPT 模板搜索网站，网站提供的各种素材和 PPT 模板都不需要保存到网盘，可以直接在网站免费下载。它不仅提供 PPT 模板，还提供 PPT 背景，PPT 素材，PPT 图表，PPT 课件，Office 教程，字体下载；它还对 PPT 模板进行了精心分类：通用 PPT 模板，行业 PPT 模板，优秀 PPT 模板，节日 PPT 模板，PPT 课件，PPT 颜色分类，网站还提供强大的搜索功能，相信你可以轻松找到你需要的 PPT 模板。 疯狂影视搜索疯狂影视搜索是一个界面简洁但是功能强大的电影搜索网站。它首先界面也是十分简洁，十分清新；但是它的功能十分强大；直接输入你要搜索的影视的名字，它会出来很多不同的搜索结果，然后你点击任意结果，它会跳转到不同的影视网站直接观看或者下载；这样子，你就轻松的找到了你需要的影视。 MixkitMixkit 是一个完全免费并且可商用的高质量视频网站，网站免费提供了丰富的视频和动画素材，并且网站提供的都是高质量高清视频，网站还会每周更新 10 个新的免费视频。它提供的视频素材不仅质量很高而且十分丰富，它还帮助你进行了精心分类：商业与科技，音乐，生活方式，抽象，户外，自然，城市等等；点击任意一个视频，你就可以直接下载并且免费使用。 [WikiHow(https://zh.wikihow.com)]wikihow 是一个综合技能搜索网站，不管生活中，工作中，遇到不会的东西，你都可以利用这个网站搜索。它上面还免费提供了很多生活，工作小技巧，并且包含不同的专业，不同的方面；总之，各种不会的技能，先用这个网站搜索。例如：如何将图片转换成 PDF，如何清洁电脑显示器，如何给 iPhone 添加铃声，如何在忘记密码的情况下打开电脑，如何在 Excel 中制作工资表等等技巧；这个网站全部提供。 在线工具/软件福昕云编辑福昕云编辑是一个在线 PDF 编辑网站，让你不需要下载软件，直接在网站上面就可以完成 PDF 基本编辑操作，非常实用良心。它支持在线 PDF 编辑操作包括：编辑文本，添加文本，图像标注，旋转 PDF，文本高亮，区域高亮，插入文本框，插入箭头、椭圆、长方形，丰富的注释功能，添加图章功能，PDF 签名、密码保护功能；每一个 PDF 编辑操作都是简单实用。 稿定设计 x Photopea 在线 PS 工具在线 PS 是稿定设计联合 Photopea 打造的最强在线 PS 工具，是一个完全免费在线 PS 网站，是一个与 PS 电脑软件相似度非常高的在线 PS 网站，让你无需下载软件，也可以拥有和 PS 电脑软件一样的操作和体验。它是中文界面，让你操作起来非常轻松，并且支持打开 PSD，XCF，SKetch，XD，CAD 文件。它的具体操作基本和 PS 一样，并且网站打开速度非常快，操作非常流畅；你可以利用这个网站直接实现 PS 的所有功能，包括：轻松实现抠图、轻松实现去除图片多余的物体、制作精美的海报等等操作；而且这个网站是支持手机打开操作的。 Onlinedoctranslator是一个功能强大的办公网站，它最主要的功能就是在线文档翻译，对整个文档进行翻译，不仅可以对全英文文档翻译成全中文文档或者其它语言文档，它还支持多达 104 种不同语言文档任意转换。它支持翻译任意文档格式为任意语言，你可以转换 PDF 文档，也可以转换 Word 文档和其它任意文档格式；它还支持对翻译的文档保持排版不变；而且网站无需注册，无需安装，完全免费。它的操作方法也是很简单，直接上传文档就可以翻译，网站还支持将 PDF 转换为 Word，分割 PDF，文字计数器。最后，这个网站的文档翻译效果在免费文档翻译网站中是非常不错的。 在线文件转换导航在线文件转换导航是一款支持 200 多种格式的在线转换工具，并且完全免费。它支持视频格式，音频格式，图片格式，常见文档，表格格式，演示用文档格式，电子书格式，压缩格式；总之，只要你需要转换的任意文件，就可以用这个工具试试。 PDF 派是一个实用的综合 PDF 编辑转换导航网站。它支持的功能包括：PDF 转换为 Word ，Excel ，PPT ，图片，Pages ，Keynote ，EPUB ；Word ，Excel ，PPT ，图片转化为 PDF ；它还支持 PDF 加密，合并，添加水印，解锁，拆分，旋转，压缩。最后，它的 20 个实用的 PDF 在线工具，完全免费。 临时邮箱临时邮箱是一款帮助我们解决某些网站需要使用到我们自己的真实邮箱，但是我们又不想暴露我们的邮箱的工具。它不需要注册，并且它的邮箱持续 24 小时，比十分钟邮箱保持时间更长，可以任意设置邮箱名，随时更换邮箱；一款个人认为十分实用的工具。 Toolfk 在线工具箱在线工具箱是一款程序员工具箱，包含几十个实用的工具。它包括的工具有：在线生成二维码 Qrcode，Linux 常用命令大全，在线思维导图工具，在线数据库设计工具，PHP 代码在线运行，Python 代码在线运行，JavaScript 在线工具箱，CSS 在线工具箱，JSON 在线工具箱，Markdown 在线工具箱，在线 SQL 转换工具，在线加密工具箱，进制在线转换等等。 Firefox SendFirefox 推出的简单私密的文件分享服务。端到端加密分享文件，链接到期即焚。 AI 人工智能图片放大Bigjpg 是一个可以无损放大图片的网站，它通过神经网络，针对放大图片的线条、颜色、网点等特点，做特殊的算法调整，放大效果非常出色, 色彩保留较好, 图片边缘也不会有毛刺和重影 半色像素效果生成器将图片自动转换成复古的半调风格。这个神器最大的亮点在于可以导出 SVG 矢量格式！ 双色调图片生成器Duotones 是一款功能强大、操作简单的双色调生成器，不但可以一键生成双色调风格，还能调整图片的色调、明暗等基本参数，堪称双色调最强神器！ 萌萌的图表生成器它可以让使用者轻松建立好看的统计图表，支持各种图形，包括：直方图、条形图、饼图、甜甜圈图、漏斗图、金字塔图、径向图和维恩图等等 地图可视化生成器一个地图数据可视化神器。导入数据一键生成酷炸的数据地图，分分钟做出科幻的效果 unDraw如果你觉得阿里巴巴图标库 iconfont 已经很强大了，那这个 unDraw 必定能够把你的设计工作推向新高度。iconfont 提供小图标，unDraw 提供大图标，图形，人物，也是一个开源的矢量图标库。用法就像 iconfont 一样，搜索你想要的矢量图，随意修改颜色等等。 autodrawGoogle 旗下的 AI 画图工具 百度脑图百度出品的在线思维导图编辑工具。百度脑图是开源项目，地址在这里。 [HiPDF(https://www.hipdf.com/)]HiPDF 打的口号是“All-In-One Online PDF Solution”，一站式解决所有 pdf 相关的问题。 链接 你用过的最让你震惊的网站有哪些？为什么？ - 知乎]]></content>
      <tags>
        <tag>软件</tag>
        <tag>在线工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能手环如何监测睡眠]]></title>
    <url>%2Fpassages%2F%E6%99%BA%E8%83%BD%E6%89%8B%E7%8E%AF%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E7%9D%A1%E7%9C%A0%2F</url>
    <content type="text"><![CDATA[最近看到小米手环 3 的一些介绍，宣传可以监测睡眠情况，同时可以统计深度睡眠和浅度睡眠的时长。 在网上查询一番之后，基本可以得出如下结论： 小米手环 3 用来监测睡眠的唯一传感器是三轴加速度传感器，通过该传感器采集睡眠过程中特殊频率的移动，经过一些算法，得出睡眠质量结果。使用这种方式，对于睡眠没有大问题的健康成年人来说，判断觉醒和睡眠这两个状态是没有太大偏差的，所以睡眠的时间段信息（比如晚上10：50到早上7：29）是基本可信的结果。 但是，对于睡眠质量结果中的浅度睡眠和深度睡眠，可以认为这个数据是不可靠的。当今睡眠监测的金标准，是 PSG（多导睡眠描记法），多导睡眠描记法主要记录三种活动：脑电波活动 EEG，眼前后电位差 EOG，肌电图 EMG。此外，PSG需要贴很多电极，绑设备，连续监测7天以上，成本非常高昂，通常用于临床上诊断睡眠障碍（睡眠呼吸暂停，发作性睡病，睡眠腿动征等）。可以看到，PSG 这种方式测量的都是神经层面的活动，并非加速器能测量的运动。 所以，各类智能手环/智能手表/利用手机加速度传感器的睡眠监测APP，这些设备或软件并不能准确地区分睡眠阶段，因为睡眠阶段需要依靠监测脑活动来区分，而它们只是通过加速度传感器来监测特定频率的运动。大多数的验证实验对采用加速度传感器监测人体活动产生的加速度来辨别睡眠/觉醒的准确性是持肯定态度的，而在深度睡眠和浅度睡眠的时长这些结果上与 PSG 的一致性低。 另外，手环上的PPG 心率传感器并不是像 apple watch 上的那样24小时实时检测，而是需要用户主动开启检测或者在运动模式下适时地开启（这当然是为了保证续航）。所以，在默认情况下，睡眠时心率传感器是没有开启的。 总结目前监测睡眠质量的手环/手表/手机APP，其实是 Wrist Actigraphy（腕式活动记录仪，佩戴在非惯用手手腕的加速度计，由于人在入睡后上肢活动明显减少而被利用起来的技术）的衍生产物，基于加速度传感器测量人体运动的数据来判断人体处于觉醒还是睡眠的状态。对于没有较大睡眠问题的健康成年人来说，其总体睡眠时长是值得参考的，而深度睡眠时长和浅度睡眠时长则基本不可信。 参考链接 监测睡眠质量软件是用什么算法来计算睡眠质量的？ - 知乎]]></content>
      <tags>
        <tag>智能手环</tag>
        <tag>睡眠</tag>
        <tag>数码科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 年中国居民人均可支配收入]]></title>
    <url>%2Fpassages%2F2018%20%E5%B9%B4%E4%B8%AD%E5%9B%BD%E5%B1%85%E6%B0%91%E4%BA%BA%E5%9D%87%E5%8F%AF%E6%94%AF%E9%85%8D%E6%94%B6%E5%85%A5%2F</url>
    <content type="text"><![CDATA[居民收入情况2018 年，全国居民人均可支配收入 28228 元，比上年名义增长 8.7%，扣除价格因素，实际增长 6.5%。其中，城镇居民人均可支配收入 39251 元，增长（以下如无特别说明，均为同比名义增长）7.8%，扣除价格因素，实际增长 5.6%；农村居民人均可支配收入 14617 元，增长 8.8%，扣除价格因素，实际增长 6.6%。 全年全国居民人均可支配收入中位数 24336 元，比上年增长 8.6%，中位数是平均数的 86.2%。其中，城镇居民人均可支配收入中位数 36413 元，增长 7.6%，是平均数的 92.8%；农村居民人均可支配收入中位数 13066 元，增长 9.2%，是平均数的 89.4%。 平均数与中位数这里以居民收入为例来说明，平均数，所有居民收入总和除以居民的数量；中位数，将居民收入按照升序排列，取最中间的一个居民收入值（居民总数为奇数的情况）或者两个居民收入值的平均值（居民总数为偶数的情况）。 在最理想的情况下，居民收入应该呈正态分布，即处于中等收入水平的人数最多，而高收入和低收入的人数朝两极方向递减。此外，正态分布下，居民收入的平均数和中位数是相等的。2018 年居民人均可支配收入的中位数是平均数的 86.2%，即中位数小于平均数，这说明右侧数据（高收入）存在多个异常的偏大数据。这些异常的高收入个体拉高了居民人均可支配收入，所以在这样的情况下，中位数比平均数更适合描述大多数居民的收入情况。简而言之，平均数适合描述趋于正态分布的数据，中位数适合描述存在极大或极小值的数据。 统计指标解释（一）居民可支配收入居民可支配收入指居民可用于最终消费支出和储蓄的总和，即居民可用于自由支配的收入。既包括现金收入，也包括实物收入。按照收入的来源，可支配收入包含四项，分别为：工资性收入、经营净收入、财产净收入和转移净收入。 工资性收入指就业人员通过各种途径得到的全部劳动报酬和各种福利，包括受雇于单位或个人、从事各种自由职业、兼职和零星劳动得到的全部劳动报酬和福利。 经营净收入指住户或住户成员从事生产经营活动所获得的净收入，是全部经营收入中扣除经营费用、生产性固定资产折旧和生产税之后得到的净收入。计算公式为： 经营净收入=经营收入-经营费用-生产性固定资产折旧-生产税 财产净收入指住户或住户成员将其所拥有的金融资产、住房等非金融资产和自然资源交由其他机构单位、住户或个人支配而获得的回报并扣除相关的费用之后得到的净收入。财产净收入包括利息净收入、红利收入、储蓄性保险净收益、转让承包土地经营权租金净收入、出租房屋净收入、出租其他资产净收入和自有住房折算净租金等。财产净收入不包括转让资产所有权的溢价所得。 转移净收入计算公式为：转移净收入=转移性收入-转移性支出 转移性收入指国家、单位、社会团体对住户的各种经常性转移支付和住户之间的经常性收入转移。包括养老金或退休金、社会救济和补助、政策性生产补贴、政策性生活补贴、救灾款、经常性捐赠和赔偿、报销医疗费、住户之间的赡养收入，本住户非常住成员寄回带回的收入等。转移性收入不包括住户之间的实物馈赠。 转移性支出指调查户对国家、单位、住户或个人的经常性或义务性转移支付。包括缴纳的税款、各项社会保障支出、赡养支出、经常性捐赠和赔偿支出以及其他经常转移支出等。 （二）居民消费支出居民消费支出是指居民用于满足家庭日常生活消费需要的全部支出，既包括现金消费支出，也包括实物消费支出。消费支出可划分为食品烟酒、衣着、居住、生活用品及服务、交通通信、教育文化娱乐、医疗保健以及其他用品及服务八大类。 食品烟酒指用于各种食品和烟草、酒类的支出。 衣着指与居民穿着有关的支出，包括服装、服装材料、鞋类、其他衣类及配件、衣着相关加工服务的支出。 居住指与居住有关的支出，包括房租、水、电、燃料、物业管理等方面的支出，也包括自有住房折算租金。 生活用品及服务指家庭及个人的各类生活品及家庭服务。包括家具及室内装饰品、家用器具、家用纺织品、家庭日用杂品、个人用品和家庭服务。 交通通信指用于交通和通信工具及相关的各种服务费、维修费和车辆保险等支出。 教育文化娱乐指用于教育、文化和娱乐方面的支出。 医疗保健指用于医疗和保健的药品、用品和服务的总费用。包括医疗器具及药品，以及医疗服务。 其他用品及服务指无法直接归入上述各类支出的其他用品与服务支出。 实例分析我们以小明一家的收入情况为例，来对比居民人均可支配收入的情况。小明一家三口的情况是这样的，小明今年 5 岁，没有任何形式的收入；爸爸和妈妈都是企业职工，两个人的各项收入情况共计如下： 工资性收入共计 73048 元 经营净收入共计 0 元 财产净收入（银行定期理财/各类互联网理财产品等）共计 10584 元，支付宝 4232 元，腾讯财付通 663 元，银行理财 7960 元。 转移净收入共计 27660 元。 所以小明一家的可支配收入共计 113665 元，人口数为 3 ，所以小明家的人均可支配收入为 37888 元，而城镇居民人均可支配收入中位数 36413 元，平均数 39251 元。 链接 居民收入情况 统计指标解释]]></content>
      <tags>
        <tag>公民</tag>
        <tag>人均可支配收入</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心愿清单]]></title>
    <url>%2Fpassages%2F%E5%BF%83%E6%84%BF%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[数码产品类Apple Watch Series 4 为什么需要它？想要买一个手表，主要诉求有 3 点：计时、装饰、健康。 为什么选择它？优秀的工业设计，赏心悦目的用户界面，强大实用的健康功能，包括光学心率检测、摔倒检测，以及健身记录、睡眠状况、冥想呼吸训练等，再加上 iOS 生态的各种健康 App，让它成为市面上最值得购买的智能手表。其他吸引我的包括，设计精美的多种表盘、多种形式的表带。唯一的遗憾在于续航只有一天。 iPhone XRA12 仿生芯片加持，优秀的摄像品质，加以 Apple 一直以来的工业设计以及 iOS 系统和生态，在 5000 元这个价位来说，是一个合适的选择。 SONY WH-1000XM3优秀的头戴式无线降噪耳机。 家居物品书房椅及木黑胡桃实木真皮书房总统椅 休闲椅及木黑胡桃实木真皮休闲椅 休闲摇椅及木玻璃钢休闲摇椅 人体工学椅个人用品眼镜基本诉求：耐脏，耐磨，耐汗渍，佩戴舒适。尝试先去医院做一次详细的验光，然后在网易严选或者必要商城在线配眼镜。 更新(2019年9月)：直接在宝岛眼镜的线下店配了一副眼镜，镜框材质是钛合金，镜片品牌为来自新加坡的 SAP。 大愿景房子为什么需要自己的房子？ 目前居住环境比较恶劣，地理位置偏僻，交通网络不发达，出行和通勤距离非常长。政府的政策/资源倾斜很少，各类基础设施较差，比如公园/商场/学校/医院/图书馆/电影院/健身房/银行等，要么处于缺位状态，要么体验差；休闲娱乐没有好去处，健身/散步没有好地方。 此外，噪音污染严重，晚上火车噪音和汽车噪音非常大。现在的房子硬件方面条件也较差，没有电梯，门窗隔音效果差，没有直饮水。 除去上面提到的物质硬件方面，与长辈住一起也十分糟心。我与父母的思想观念和生活习惯有着很大的差别。 我这里所说的房子，重点不在于水泥箱子。简单来说，是为了换一个生活环境；详细一点说，是为了地理位置，更加优质的配套教育/医疗资源，更加发达便利的交通网络，更短的出行半径/通勤距离，素质更高/思想观念更相近的友邻，这一切都将提升我的生活品质和幸福感。除此之外，我可以真正拥有属于自己的生活，按自己的生活方式打造一个温馨的小家。 基于目前较为痛苦的生活经验，我的新房应该改善以下方面： 装修的风格以及各类设施遵从简约/实用/健康/可持续的核心理念。 有效地利用有限的空间，对于使用频率很低的设施（比如客厅茶几以及第二次卧的床），考虑去除或者用更加优雅的方式替代。 高度重视健康，目前能想到的包括：饮用处理过的桶装水，安装新风机或空气净化器，留出足够的空间用于运动，只食用植物油，不购买除油盐之外的非必需调味品。 购买有保障的品牌五金件/电线/插座/电气零件，最大限度地降低未来几年内的返工率。贯彻可持续性的理念。 培养家人间的亲密感。平时多通过亲吻和拥抱表达爱意，同时在特殊的日子（节日/纪念日/生日）借助仪式感传达自己的情感 建立良好的亲子关系。这是一个非常大的话题。对于父母和孩子间的关系，基于我读过的书和自身的经历，形成了下面的看法。父母和孩子之间应该是平等的如朋友一般的关系，而非传统中国孝道中的尊卑关系。如鲁迅所说，父母和孩子之间联系的纽带不应该是孝道，而是爱。作为父母，我们如何看待孩子的归属，她/他是我们的私有财产吗？对这个问题我有两种满意的回答。第一种是大多数西方国家父母的想法，孩子是上天带给父母的礼物；第二种则是如纪伯伦所说：『你的儿女，其实不是你的儿女；他们是生命对于自身渴望而诞生的孩子；他们借助你来这世界，却非因你而来；他们在你身旁，却并不属于你。』有了上面的铺垫，我认为父母在孩子成长过程中，重点应该放在理解，鼓励，引导这几点上。孩子通常比我们想象的要更强大，也更敏感和脆弱，我们在成为大人的过程中，很多时候已经忘记了作为孩子的一些心绪。 私人汽车 出行/通勤更加方便，灵活安排出行时间，携带行李出行更轻松 有一个相对私密的空间，这点非常重要，它可以让你很大程度地隔绝噪音/刺鼻难闻的气味 旅行类日本游日本文化对世界影响很大，消费电子/汽车工业/精益制造/设计/动漫游戏等领域在世界上都处于领先位置，公民素质高，城市建设好，街道干净整洁。自然景观保存很好，风景优美。 欧洲游]]></content>
      <tags>
        <tag>心愿清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 学习笔记]]></title>
    <url>%2Fpassages%2FWebpack%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Webpack 的核心设计理念一切皆模块Webpack 通过 loader 来处理其他非 .js 文件，比如 HTML 和 CSS 文件，字体文件，图片。以上这些全都被当做模块来看待，依赖关系更加明确清晰，也更适合复用。 只在需要的时候加载需要的模块如果最后打包输出的是一个 app.bundle.js 文件，这个文件的体积可能很大，用户访问应用程序的首页时需要等待其被全部加载、编译、执行，这个等待时间会很长。更合理的做法是，优先加载首页渲染所需要的模块，其他的资源在浏览器主线程空闲和网络空闲的时候延迟加载。只在需要的时候加载需要的模块，除了延迟部分模块的加载，还可以做以下优化： 抽取使用次数较多的公共模块，进一步缩减打包后的体积 抽取代码更新频率较低的第三方库，额外打包以利用浏览器的缓存 去除无副作用的 dead code。所谓 dead code 是指既没有 export 模块，也没有像 polyfill 类工具库那样做影响全局作用域的处理（比如添加 Promise 到 window 对象上）。去除这些 dead code 不会对整个应用程序产生影响。这一过程即所谓的 Tree Shaking。 利用 prefetching 特性确保延迟加载的模块不至于影响用户体验 术语表： Code splitting 代码分割Lazy loading 懒加载Prefetching 预获取code splitting 代码分割 Webpack 中有不少功能可以较为显著地提升网页的性能。下面列举出其中几个： 代码分割与懒加载、预获取如果不使用代码分割，那么 Webpack 打包出来的只有一个类似 app.bundle.js 的文件。这有什么问题呢？主要有以下几个方面的缺陷，可能导致首页加载速度变慢： 代码中使用的诸如 lodash 第三方库，它们通常没有我们自己的应用代码更新地那么频繁。为了利用浏览器的缓存机制，可以将第三方库的代码独立出来，另外打包。这样，浏览器如果检测到第三方库的文件没有变动，便不会发送 http 请求，而是直接从缓存中读取，这样在刷新页面或者第二次进入的时候可以加快网页加载的速度。 包含了许多首页不需要的代码，比如弹窗、模态框这些交互性组件，比如详情页面，比如首页不需要的 CSS 样式，比如首页不需要的其他 JavaScript 代码等。这会拖慢首页的加载速度，降低用户体验。ES6 的 import 语法返回的是一个 Promise 的实例，可以利用这一点实现异步加载代码、模块。Webpack 在打包过程中会自动识别这样的 import 语法，将这些异步代码进行分割以实现延迟加载，这也是 Webpack 代码分割默认的匹配块是 async 的原因。以上所说的就是懒加载，当然，具体哪些资源用懒加载处理，需要开发者自己来按需配置。 上面提到的懒加载方式，在某些时候需要配合预获取来使用。举个例子，假如某个业务庞大的网站，首页仅加载了一些关键路径的资源，类似详情页面这类组件被设置为当用户点击后才会去加载。但如果详情页面组件本身体积很大，那么可能在用户点击几秒之后才会到达，这是很影响用户体验的。所以，理想的情况是，当首页加载完毕，主线程空闲了，网络请求也空闲了，再在后台获取这些体积较大的异步组件或其他资源（实际上，只要用户大概率会使用到、但是不影响首页的模块都应该采用懒加载再配合预获取的手段来处理）。Webpack 的 prefetch/preloading 特性可以解决这一问题。 我们以 Webpack 官网上一个例子来说明 prefetching 特性：现在我们有一个 HomePage 组件，其中包含一个 LoginButton 的子组件（该组件会在首页加载时渲染）。LoginButton 组件在被点击后会加载 LoginModal 组件。为了更好的用户体验，我们应该预获取 LoginModal 组件。在 LoginButton.js 组件内，通过在引入 LoginModal 组件时增加特殊的注释以让 Webpack 识别： 1import(/* webpackPrefetch: true */ 'LoginModal') Webpack 见到这行代码后，会将 &lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt; 添加到 HTML 文件的 &lt;head&gt; 标签内。这会指示浏览器在空闲时段加载 login-modal-chunk.js 文件。 Tree ShakingTree Shaking 指去除那些在 JavaScript 上下文中未引用到的代码，这一特性是基于 ES2015 的静态结构特性。考虑如下代码： 123456789101112// math.jsexport function square(x) &#123; return x * x&#125;export function cube(x) &#123; return x * x * x&#125;// index.jsimport &#123; cube &#125; from './math.js'console.log(cube(3)) 上面代码中，index.js 模块没有导入 square 函数，为了更一步缩减加载到浏览器端的脚本大小，应该去除类似这里 square 函数的未被引用的代码。Webpack 官网上指明，要实现 tree shaking，需要满足以下 3 个条件： 使用 ES2015 模块语法（import 和 export） 在项目 package.json 文件中，添加一个 sideEffects 属性 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin） 按我自己的操作，目前来看，第 2 步不是必须的，在生产模式下未指定 sideEffects 也可以。如果使用生产模式，第 3 步 Webpack 也会默认引入 UglifyJSPlugin 压缩工具。简而言之，在生产模式下，你只需要使用 ES2015 的模块语法即可实现 tree shaking。 参考 Webpack - The Confusing Part A beginner’s introduction to Webpack Webpack 4 course ES2015 的静态结构特性]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Webpack</tag>
        <tag>前端工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建博客的工具整理]]></title>
    <url>%2Fpassages%2F%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[图床像我这种直接将页面托管在 GitHub Pages 上的，为了提高博客内图片的加载速度，只能使用图床了，而且最好是免费的。 sm.msV2EX 的某网友做的，国内国外的速度都不错，免费。上传图片的界面非常简洁，但是功能也非常简陋，不支持上传图片管理。单张图片不能超过 5M，单次批量上传数量最多 10 张。不过对于我来说够用了。 七牛云如果像我一样没有经过备案的域名，不太适合用七牛云，因为当测试域名过期后，如果你没有绑定备案的域名，将会收回你的免费对象存储服务。一旦到期，你已经上传的图片转移起来比较麻烦。 图库网站写博客离不开优质的、符合特点需求的图片，下面的几个网站都提供部分免费、优质的图片。 Everypixel一个图片素材的搜索引擎，汇集超过 50 家在线图库。AI 技术加持。个人感觉最适合程序员这个群体。提供多种过滤条件来搜索图片，包括： 基于免费还是付费搜索 基于指定的图库来搜索 基于图片格式搜索，是矢量 vector 形式还是像素阵列 graphics 形式 基于图片的宽高比搜索，是水平模式即宽度大于高度，还是垂直模式即高度大于宽度 基于图片主题颜色搜索，支持输入 RGB 或者 HSV 两种颜色格式 以九宫格形式划分图片，搜索某一个或几个格子内没有物体的图片 基于作者名字或者昵称搜索 特殊技能: 提供基于 AI 和机器学习的图片识别 API，免费用户每天可以调用 100 次该接口。包括以下 4 个功能： 图片标签赋能，识别图片内容然后基于内容给出一系列的标签。用户可以基于这些标签来对图片分类。 从摄影的专业角度来给图片打分，主要考虑美学和市场潜在价值两个维度。 基于 Instagram 网站上 347, 000 张图片训练的基础上，基于美学效果给照片打分。 提取图片中人物的脸部特征以评估其年龄。 评价图片资源非常多，搜索功能强大，AI 加持，提供 API 接口。部分图片需要付费。适合喜欢折腾一点的人，比如程序员。 Pexels主要是基于关键词搜索，图片质量高但是数量较少，界面简洁友好，支持 API。提供多种分辨率的图片下载，部分图片需要付费。 评价适合普通用户，就像下个与某关键词相关的美图。 Unsplash与上面的 Pexels 很像。除了不提供多种分辨率的图片下载。 评价适合普通用户，就像下个与某关键词相关的美图。 Freepik这个网站针对的目标用户应该是以设计师为主，提供除了基于关键词、分类的搜索外，还提供基于 PSD，Icon 的搜素。 评价Pinterest以瀑布流形式展示的图片社交网站。 Pixiv来自日本的插画交流网站。 适合设计师。 图虫网千图网Pixabay500px一个摄影师聚集的网站，因此大部分图片均为付费。 其他EGOUZ资源聚合网站，包含网址导航、图库、素材库、在线工具、小程序等各类资源。]]></content>
      <tags>
        <tag>工具</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木工爱好者]]></title>
    <url>%2Fpassages%2F%E6%9C%A8%E5%B7%A5%E7%88%B1%E5%A5%BD%E8%80%85%2F</url>
    <content type="text"><![CDATA[为什么我会爱好木工呢？ 最早可能是受到了乔布斯的影响，对铝合金、不锈钢金属，玻璃，实木这类有质感，不会随时间轻易褪色的材质情有独钟。 目前自己家里其实只有两个小件的实木制品，一个是柏木做的腰部靠枕，一个是榉木做的小型收纳盒。我对这两件物品都是比较满意的，柏木的纹理算不上好看，但是触感以及抚摸木材表面发出的声音让人安心舒适，同时靠近一点还能闻到淡淡的柏木芳香。榉木的纹理细且长，色浅柔和，虽然比不上橡木和黑胡桃木那么吸引人，不过也算得上清新恬淡。此外，触感十分光滑。我的这个榉木收纳盒购于 2014 年，到现在 5 年时间了，外观依然好看，而且未出现过开裂等情况。 因为几个月后，自己的房屋需要装修，同时免不了要添置不少家具。逛过 MUJI 的木制家具之后，便对日式简约风格的木制家具深深着迷了，还向店内员工索要了一本精美的产品图册。 此后愈发不可收拾，除了了解各种木材的特点外，还对这些桌椅、床柜如何制成的产生了浓厚兴趣。 日本现代木工夏目石谷，家具制作 B 站上转载自 Youtube Up 主 ISHITANI FURNITURE。夏目石谷是一位典型的日本现代木工，使用了非常多的现代加工设备，风格偏向日式简约，产品多为实木成品家具，包括各式各样的桌椅、床、柜等。 另外附上 B 站上搬运他视频合集的地址： 目前有 34 集，这个合集顺序更合理，由简单到复杂 目前有 50 集，保持同步更新 实木材质参考这篇博文 榫卯结构榫卯结构是实木家具中最常见的一种连接方式。其他的连接方式包括：木楔、胶水、钉子等五金件。iOS 平台上有一个 APP 《榫卯》，做的非常精致，介绍了常见的榫卯结构，可以通过手指触控操作看到榫卯详细的 3D 立体结构。 其他链接 北欧设计之父 Alvar Aalto 的曲木制造大解密 株式会社小林幹也工作室 一个来自日本的设计工作室的官网]]></content>
      <tags>
        <tag>木工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装修前的准备]]></title>
    <url>%2Fpassages%2F%E8%A3%85%E4%BF%AE%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[写在前面这篇文章存在的意义是先简单地列出一些临时性的想法、资料、清单，后续会经过长期、缓慢的整理，最后形成几篇供自己装修参考的手册。 其中不少只是一个简单的初步印象，为了描绘大致效果通常会附上一些图片，但是距离实际施工还有很大的差别。鉴于此，此篇博文将会有多图杀效果。初步考虑以下几个大类： 地板与吊顶类 卫浴用品 住宅家具 全屋定制 厨房五金 门窗 整体橱柜 衣柜 &amp; 榻榻米 瓷砖 涂料（乳胶漆） 浴霸 板材 灯具灯饰 电子电工 智能门锁 安防监控 收纳整理 床上用品 摆件 这里 给出一份天猫美家 2018 年 7 月份零售榜单出炉，共 20 多个品类、百余家品牌荣登榜单。 家具家具板材的初步选择： 成品家具，选用实木板材或者胶合板； 定制的柜体（比如衣柜）采用胶合板、密度板或者刨花板。 实木家具网店一览收集淘宝天猫上的实木家具网店。目前从以下几方面来综合评测： 用户评价。主要查看追加评价，鉴别刷单的情况。比如如果一个桌子的追加评价 90% 以上都为当天追加的，这就非常值得怀疑了。设身处地的想，假如你在网上购置了一套家具，会在初次好评之后在当天追加好评吗？ 产品。网店通常在木材材质和所用的油漆、木蜡油上都会做大量清晰的描述，但是对外观设计、工艺结构这两点，不同的网店情况就很不同了。所以，一般来说，材质上通常不会有假，而且天猫针对这些实木家具网店做了一些抽检，以餐桌为例，主要考量的指标只有 3 个：桌子结构稳固性、甲醛、是否为全实木。所以，我认为这些实木家具网店，他们的实木材质通常没有大问题，最多是将木材的分级夸张宣传了一下，比如将普一级宣传珹 FAS 特级，如何辨别可以参考之前的 这篇博文。产品的主要差别还是在外观设计和工艺结构上。基于以上情况，我主要将考虑外观设计和工艺结构这两点。外观设计其实就是看桌子为什么做成这个样子，不考虑装饰这一属性，将目光聚焦在为何如何设计的内在逻辑上。至于工艺结构，主要看各个组成部分是如何连接固定的，是大面积采用榫卯结构、木楔，辅以少量胶水和五金部件；还是以胶水和五金部件为主，极少用榫卯。 价格及售后服务。 是否有线下体验店、实体店，在全国分布情况如何。 下面列出一个天猫官方出品的天猫榜单-趋势榜，北欧全实木餐桌榜（近一年本榜单商品购买人数增加 659%）： 及木家具北欧简约长方形全实木餐桌 9.7 分 概述：进口欧美实木 天然木蜡油 超厚实台面 回去餐桌，台面厚度 30-33mm目前价格：1.4 米单桌。美国白橡木 3428 元，欧洲榉木 2253 元，美国黑胡桃木 4311 元材质解析：可选欧洲榉木、美国樱桃木、美国白橡木、美国黑胡桃木售后：3 年质保，人为原因及气候问题导致产品使用问题需支付维修费用实体店：广州、上海、深圳、杭州、厦门免费仓储：无买家评价：暂无刷单嫌疑商品链接：简约全实木餐桌 原始原素北欧全实木胡桃色餐桌进口橡木 9.4 分 概述：纯实木打造 环保喷涂 进口白橡木，台面厚度 20mm目前价格：1.3 米一桌四椅 3526 元材质解析：北美橡木，胡桃木色或原木色售后：五年质保，90 天无理由退换货实体店：上海、杭州、青岛、武汉、成都、重庆、长沙、西安免费仓储：180 天买家评价：暂无刷单嫌疑商品链接：胡桃色橡木餐桌椅组合 dreasylife 家居大理石餐桌椅组合全实木餐桌 9.4 分 概述：白蜡木框架，桌面贴大理石纹饰目前价格：1.3 米一桌四椅 3080 元材质解析：白蜡木框架，桌面贴大理石纹饰，木材颜色可选胡桃木色和原木色售后：3 年质保，45 天无理由退货实体店：无免费仓储：120 天买家评价：可能存在刷单商品链接：大理石餐桌椅组合 雅琼家居北欧全实木餐桌椅组合现代简约 4 人 6 人长方形饭桌 9.3 分 概述：橡胶木实木桌椅组合目前价格：1.4 米一桌四椅 2509 元材质解析：桌面-指接板橡胶木做油漆，其他承重件-橡胶木做油漆，软包-麻布+海绵+中纤板，颜色可选胡桃木色和原木色售后：3 年保修，7 天无理由退换实体店：无免费仓储：无买家评价：暂无刷单嫌疑商品链接：橡胶木餐桌椅组合 golsibo 哥思宝火烧石餐桌椅组合北欧现代简约全实木框架家用长方形大理石头餐桌 9.0 分 概述：火烧石桌面，北美白蜡木榫卯结构框架目前价格：1.4 米一桌四椅 4000 元材质解析：四色可选，古铜色、原木色、胡桃色、黑色售后：3 年质保实体店：无免费仓储：无买家评价：目前这一款只有一个买家评价。商品链接：火烧石餐桌椅组合 源氏木语全实木餐桌长方形桌椅组合 8.9 分 概述：全用黑胡桃木 干净大板 圆润边角 木蜡油目前价格：1.4 米一桌四椅 5792 元，1.4 米一桌两椅加一条 1.0 米长条凳 4992 元材质解析：美国黑胡桃木，德国 OSMO 木蜡油售后：5 年质保，90 天退换货实体店：上海、北京、成都、武汉、长沙、南京等 15 个城市免费仓储：180 天买家评价：暂无刷单嫌疑商品链接：黑胡桃木餐桌椅组合 维莎北欧全实木餐桌日式饭桌 8.9 分 概述：进口橡木 环保喷涂 圆角处理 安全健康目前价格：1.5 米一桌四椅 3340 元材质解析：北美橡木，可选胡桃色和原木色，桌面厚度 20mm售后：5 年质保，90 天退换货实体店：上海、北京、成都、武汉、长沙、南京等 15 个城市免费仓储：无买家评价：暂无刷单嫌疑商品链接：日式橡木餐桌椅组合 马氏皇庭家居北欧全实木餐桌长方形大理石餐桌椅合租 8.1 分 概述：水曲柳实木框架，大理石桌面饰面目前价格：1.35 米一桌四椅，大理石桌面 2920 元，火烧石桌面 3152 元材质解析：桌面饰面材质大理石，水曲柳木质框架。木质可选胡桃色和原木色。售后：3 年质保，7 天退换货实体店：无免费仓储：免费仓储，未写明具体多少天买家评价：暂无刷单嫌疑商品链接：大理石桌面水曲柳框架餐桌椅组合 木智工坊穿带榫桌全实木餐桌简约北欧家用 8.1 分 概述：穿带榫结构全实木餐桌目前价格：1.35 米单桌，2926 元材质解析：可选黑胡桃木，橡木，榉木。橡木喷涂木蜡油，榉木喷涂半开放式的硝基漆售后：1 年质保，7 天退换货实体店：无免费仓储：免费仓储，未写明多少天买家评价：暂无刷单嫌疑商品链接：穿带榫结构全实木餐桌 艺鼎宏全实木餐桌椅组合北欧长方形铜腿餐桌 7.1 分 概述：橡胶木铜腿餐桌椅目前价格：1.4 米一桌四椅 2329 元材质解析：桌面-指接板橡胶木做油漆，其他承重件-橡胶木做油漆，软包-麻布+海绵+中纤板，颜色可以选原木色和胡桃色，桌面厚度 22mm售后：3 年质保，7 天退换货实体店：无免费仓储：60 天买家评价：暂无刷单嫌疑商品链接：橡胶木铜腿餐桌椅组合 衣柜、电视柜、收纳柜、鞋柜沙发床餐桌椅备选清单： 铜师傅安格尔胡桃木餐桌椅 售价 ¥5299，最低 ¥4999 茶几排除笨重的长方体状传统茶几，这种茶几占地大、重量大、实用性也不强。移动起来非常麻烦。备选清单： 样子拼图茶几组合三件套 售价 ¥599，最低 ¥569 橙舍多功能 T 移动边几 售价 ¥189 改善生活体验的物件以下是一些传统中国家庭装修不会考虑到的（虽然其中不少已经被越来越多的年轻一辈所推崇），但是可以显著提升生活体验的物件。 智能马桶盖这里先贴一个爱否科技对目前中国市场上智能马桶盖的对比评测，时间节点是 2019 年 4 月底：智能马桶盖消费者报告 - 爱否科技。先提醒自己一点，不要盲目推崇日式马桶，不少国产品牌在慢慢崛起，特别是考虑价格之后有很强的竞争力。 家用前置反冲洗过滤器装在家庭进水总管前，用于过滤水中的铁锈/渣滓/沉淀物等对身体有害的东西。 家庭垃圾处理器增压花洒解决水压可能不足的问题，重拾洗澡的乐趣。 可抽拉水龙头可抽拉水龙头是指水龙头顶端出水口连接的软管可以抽出,以扩大清洗范围。这种水龙头在西方国家比较流行，只是在中国因为使用习惯问题，还不算太普及，不过现在许多人已经开始逐渐接受这个新事物了。可抽拉水龙头最主要的使用场景有 2 个：洗漱台上装一个可抽拉水龙头，用来洗头体验非常好；厨房水槽装一个可以更加方便地冲洗各个角落。另外，根据我的生活经验，可抽拉水龙头除了支持冷热水外，还得有花洒、水柱两种出水模式以供切换，体验更佳。 可抽拉水龙头 1可抽拉水龙头 2可抽拉水龙头 3可抽拉水龙头 4 指纹锁自 iPhone 5s 面世后，其所搭载的指纹识别技术经过整个产业的推动，从最开始的手机，到平板电脑，笔记本电脑，再到以智能指纹锁为代表的智能家居硬件，越来越多的设备都附带了指纹识别技术。指纹识别的安全性已经得到了非常高的保障。 扫地机器人电动拖把免去弯腰之苦，关键词日本 UONI 品牌，参考这个型号 TUJ-MA817。 多功能吸尘器电动牙刷备选：素士。 激光投影仪据说电视已经成为一种社交工具，比如化解和长辈亲戚无话可说的尴尬。 无线降噪耳机这里不用纠结，买 SONY 或者 BOSE 最贵的那一款就行了。 摆件提前罗列心仪的一些小摆件。 日本药师窑发财猫 WELLY 自行车合金仿真模型 参考 如何把家装修成舒服的地方 - 胡依林]]></content>
      <tags>
        <tag>装修</tag>
        <tag>家具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 平台优质软件整理]]></title>
    <url>%2Fpassages%2FWindows%20%E5%B9%B3%E5%8F%B0%E4%BC%98%E8%B4%A8%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[以下软件通常有这些特性： 免费 没有广告 功能实用 用户体验好 CmderCmder is a software package created out of pure frustration over the absence of nice console emulators on Windows. It is based on amazing software, and spiced up with the Monokai color scheme and a custom prompt layout, looking sexy from the start. 可以简单理解为 Windows 默认命令行的替代品，但是体验和功能都有巨大提升。界面简洁美观，字体和颜色赏心悦目。有两个版本，一个轻量级版本，一个完全版本。建议下载完全版本，集成了 Git for Windows。安装完之后需要做一些简单的设置。 将 Cmder 添加到系统环境变量。即将 Cmder.exe 所在的目录路径追加到 Windows 系统环境变量 Path 值的末尾。 将 Cmder 添加到右键菜单，这是一个非常强烈的需求，我们想要在某个文件夹，以此所在路径为工作路径打开 Cmder。具体设置为： a. 先打开一个 Cmder 窗口 b. 按下 Alt + Shift + 3，即打开一个管理员权限的 PowerShell c. 输入以下命令: Cmder.exe /REGISTER ALL d. 完成 Cmder 的快捷键与浏览器内的快捷键基本相同: Tab 自动路径补全以及自动命令提示 Ctrl + T 新建一个命令行标签页（标签页显示在窗口底部），可选 Cmder / PowerShell / bash / cmd 等 Ctrl + W 关闭当前焦点所在的命令行标签页 Ctrl + Tab 切换命令行标签页 Alt + F4 关闭所有标签页 Alt + Shift + 1 开启任务 1。任务可以自定义，如果没有定义过，一般是开启 Cmder / PowerShell / bash 等命令行标签页。 Alt + Shift + 2 开启任务 2 Alt + Shift + 3 开启任务 3 Alt + Shift + n 开启任务 n Ctrl + 1 快速切换到第 1 个页签 Ctrl + n 快速切换到第 n 个页签( n 值无上限) Alt + enter 切换全屏状态 / 窗口状态 Ctrl + ~ 切换最小化 / 窗口状态 Ctrl + r 历史命令搜索 Ctrl + 鼠标滚轮 调节字体大小 End, Home 将光标移动到当前行的行首 / 行尾 以上只是很少一部分，具体可以参考帮助里面的热键信息。 Git BashLinux 风格的命令行工具。 Sublime Text 3文本编辑器，轻量，拥有强大的插件系统，可以让用户根据需要灵活配置。 EverythingWindows 下面的文件搜索软件，速度非常快，远胜系统自带的搜索功能。 PotPlayer可能是 Windows 下最好的视频播放器。支持的格式多，无广告，功能非常多。 7-Zip一款拥有极高压缩比的开源压缩软件。体验好、无广告。 Geek Uninstaller Clean Removal and Force Removal Native X64 support Easy-to-use User Interface Uninstall Windows Store Apps 比 Windows 自带的程序卸载好用，删除更加彻底。 GooglePinyin对于 Windows 10 以下版本的用户而言，这可能是唯一不耍流氓/没有各种弹窗的干净简洁的输入法了。当然，它的云词库以及一些本地化做的没有那么好，不过也足够使用了。上面给出的链接是互联网存档的，因为 Google 官方已经不再维护这个输入法，并从官网移除了有关信息。 Picasa 3Google 出品的图片查看器，速度快，功能强大。 Honeyview一款快速图片查看软件。 支持的操作系统: Windows XP/Vista/7/8/10 许可类型: 免费软件 (无广告/间谍软件/病毒)，EULA 支持显示 JPEG 格式的 EXIT 信息，包括 GPS 信息 批量转换图片格式和调整大小 直接浏览 ZIP/RAR/7Z/LZH/TAR/ALZ/EGG 等格式的压缩包 支持幻灯片放映 支持将喜爱的图片储存到照片文件夹 支持的格式 图片格式: BMP, JPG, GIF, PNG, PSD, DDS, JXR, WebP, J2K, JP2, TGA, TIFF, PCX, PGM, PNM, PPM, and BPG Raw 图片格式: DNG, CR2, CRW, NEF, NRW, ORF, RW2, PEF, SR2, and RAF 动画格式: Animated GIF, Animated WebP, Animated BPG, and Animated PNG 无需解压，直接预览图像: ZIP, RAR, 7Z, LZH, TAR, CBR, and CBZ Sumatra PDFSumatra PDF is a PDF, ePub, MOBI, CHM, XPS, DjVu, CBZ, CBR reader for Windows。 AutoHotKeyPowerful. Easy to learn.The ultimate automation scripting language for Windows. AutoHotKey 使用 ShareX截图、上传共享等。 Typora一款小巧、简洁、实时预览、功能全面的 Markdown 编辑器。支持 TOC 目录，支持 LateX 公式。 Mp3tag用来编辑 .mp3 等常见格式音频文件的软件。可以用来给音频文件添加标题、艺术家、作曲家、专辑、年份、封面等信息。对我来说，主要是方便编辑一些冷门音频资源，来用本地音乐播放器听歌。]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>软件</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国古典椅子]]></title>
    <url>%2Fpassages%2F%E4%B8%AD%E5%9B%BD%E5%8F%A4%E5%85%B8%E6%A4%85%E5%AD%90%2F</url>
    <content type="text"><![CDATA[一般而言，我们谈到的中国古典家具，通常是指明清时期的。这篇文章提到的椅子形式均形成于明清时期。 椅子的形式大致可以分为 6 种类型：四出头官帽椅、南官帽椅、圈椅、交椅、玫瑰椅、灯挂椅。 四出头官帽椅官帽椅」分四出头官帽椅与南官帽椅。四出头椅子就是形容搭脑和扶手都出头。有的在尾端直接直平截断收尾，有的或者像书法收笔时，带弯头的圆笔或到尾端轻轻提起，不回锋的姿态。在各色各样传统明式椅子中，或以四出头椅式最能展现高尚，大方的架势。它是礼节/仪式性的椅子，常常在阶层等级的坐席场合安排出现。 官帽椅中的良品必然塑形灵动，生气勃勃，线条挺劲，整体展现正直不阿的稳重，以及曲度婀娜的扶手和联邦棍。靠背板一般采用 S 形曲线，有的以一块整板做成，有的或分数段装板，或锼镂或浮雕如意云头或雕刻其它的装饰主题。 榆木大四出头椅子一对清代中期产于华北56.5 x 46 x 119 公分高，座高 53 公分 南官帽椅南官帽椅以扶手和搭脑不出头而向下弯扣其直交的枨子为特征。中国匠师以术语 「挖烟袋锅」来称呼这闷榫角接合的正角榫接，正是反映其烟斗官形象。该榫的起用予以接合部位平整、流畅的外壳效果。 南官帽椅通常区分为高背式或矮背式两类，后者的高度一般不会超过一百公分。高背式者最为舒适；据高廉的看法，在选择一把椅子时，搭脑的舒适性应当作为最主要的考量因数。而选择矮背式南官帽椅时，也要与文震亨的尚古品味一致，他评论，「一般而言，椅子要矮而非过高，要宽而非过窄。」这两类型的存世实例仍然不少。 在宋元期间的画作上，可见到这类形椅子的早期证据。晚明的百科全书，《三才图会》 （1607 年刊版）描绘一种扶手出头的变体品种，名称更是精简，仅仅两字，称「方椅」。 榆木南官帽椅一对清代中期产于山西55 x 43 x 119 公分高， 座面 53 公分高 圈椅圈椅的出现与高背椅同时，皆在唐与宋之间。有种说法是它的前身源头是上古时期的弧形三足凭几，用于席地而坐或者后期置于台座（也称「榻」）上使用。宋代文献中也有「作栲栳，屈曲竹、木为圈形扶手」的记载。在明代之前，圈椅造型的发展在传统家具中已达到最完美的基本形式。由于圆靠背和扶手是一顺而下，臂膀和肘部得以全然支撑，坐在上面分外舒适。 在西方以「铁马蹄扶手椅」一词来形容靠背扶手作 U 形铁马蹄的圈椅。晚明的百科全书《三才图会》（有关天，地，人的图文百科）中，有一帧带「圆椅」标题的插图，展示了圆背扶手椅。现今国人则偏好「圈椅」一词。 圈椅表现出艺术意境里所谓的圆融或浑圆美，透过半圆形曲线的圈背扶手和鹅脖子而融合一气，好像圈抱着一虚无的球体。搭配其下相对性的「方」形座盘，圆背椅也有三度空间的代表意义，亦即表达了中国人「天圆地方」的宇宙观。再者，边框骨架构件采「圆材在上，方材在下」，也是表达这同样的概念。 紫榆圈椅一对清代中期产于华北56 x 47 x 95 公分高 交椅交椅风行于宋代，有圆后背与直后背式两种，在该时期的文献画册中皆有范例可考。中国惯用的名称有「交椅」及「折叠椅」两种。 交椅是腿子做十字交叉，并以枢轴铰链在交叠的部位结合的结构体。在椅盘横枨之间以线绳编织可折叠的软屉。腿子张开后的延展范围超过椅盘的后缘，此乃何以略微向后倾斜的靠背能够得以支持，而不失平衡。 可折叠式的交椅便于携带，颇适合长途跋涉的旅程使用，或居家应景临时设座款客之用。加长型的交椅能载坐两或三人，也适合于户外的活动，例如观赏野台戏。 清代皇帝们也流行使用交椅，本着游牧民族满洲男人的一些固有传统的维护，他们特别喜好外出下乡打猎。 黑漆榆木圈背交椅明代（髹漆部份经炭十四检测约 1575 年）产于华北72 x 59 x 99 公分高， 座面 47 公分高 折叠式的躺椅，传统习俗上又称『醉翁椅』，也适合携带登山赏景，在松树下、断崖前孕育崇高的心性。 木头竹片躺椅清末民国初产于广东66 x 106 x 89.5 公分高， 座面 46 公分高 玫瑰椅「玫瑰椅」的特性在于其相对矮的高度，略窄的坐盘，以及直边方角结构的靠背和扶手。其设计很可能是吸取自传统的竹椅，亦即模仿其未经截断的竹材直接弯曲九十度角的边框以及以细竹攒接的背板或牙条等。 此类椅子与女性寓所多所关联，主要在于其娇小的尺寸以及「玫瑰椅」其女性化名称之缘由，只是未曾有二十世纪以前的实物传世。另外尚有「文椅」一词，与晚明清初绘画/版画中常见该椅出现在文房摆设有关联。 由于靠背是矮背式并且平直，此椅也颇适合置放在窗下，抵靠墙面而坐。外观赏心悦目，舒适性倒是无法与其他传统椅子按人体工学设计的靠背相比。 榆木玫瑰椅一对清代中期产于山西57 x 46 x 87 公分高，座面 54 公分高 灯挂椅没有扶手的椅子，能靠拢桌边收进的椅子，在宋代就出现，并且一直持续到清代，基本形式几乎没有什么变化。一般来说，体积比南官帽椅略小，但靠背与搭脑造型则相差无几。在所有椅子类型中，这种椅子很可能是最普遍的一种；然而，由于其结构上比那些带有扶手者较为薄弱，灯挂椅传世实物的数量因此少的多了。 传统惯称「灯挂椅」一词出现于雍正期间的文献，中国人至今仍然普遍使用该名。该名称符合并反映了过去民间所使用、可挂在墙上或置于桌上的油灯架之迷你椅子的造型。 榆木灯挂椅清代中期产于山西52.5 x 41 x 125 公分高座面 54 高 总结从现代的观点来看，中国古典椅子中： 圈椅的结构最符合人体工学，所以坐起来也最舒适。 灯挂椅结构最为简单，没有扶手，同时体积相对较小，便于收纳，使用最为普遍。 交椅由于其可折叠的特点，便携性最佳，适合长途携带或运输。 官帽椅的结构则最具中国传统文化的韵味。 玫瑰椅尺寸娇小，外观简约优美，舒适性上则欠佳。 链接 中国古典家具椅子种类]]></content>
      <tags>
        <tag>古典家具</tag>
        <tag>椅子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铜师傅安格尔黑胡桃原木餐桌椅]]></title>
    <url>%2Fpassages%2F%E9%93%9C%E5%B8%88%E5%82%85%E5%AE%89%E6%A0%BC%E5%B0%94%E9%BB%91%E8%83%A1%E6%A1%83%E5%8E%9F%E6%9C%A8%E9%A4%90%E6%A1%8C%E6%A4%85%2F</url>
    <content type="text"><![CDATA[餐桌椅的购买目标之一：铜师傅安格尔黑胡桃原木餐桌椅。选择的款式为 1.4 米餐桌配套 4 把餐椅。 除了官方给出的产品信息，我收集了什么值得买上几位参与众测的用户提供的产品照片和信息，整理如下： 包装 安装由于桌子采用悬浮式设计，桌腿和桌面没有直接接触，所以安装比较简单，只要将桌腿与立水通过 8 颗螺丝固定好即可。 实拍 细节桌腿的两端都有铜件：在较粗的一头嵌入了两个螺母，用于将桌腿固定到立水上：椅腿的两端同样都有铜件：桌子侧面和椅面都镶嵌着刻有生产年份的铜铭牌：桌面四角连接桌腿细节：铜套底部贴有 3M 防滑橡胶：铜套用螺丝与木料连接：四条桌腿的造型： 结构餐桌桌面，共有八块板材拼接而成，各块板材应该都是取材自树芯，色调为棕色，除了图片右侧有两块料下方颜色稍微深一点外，整张桌面的色调还是较为统一的，未见奶白色边材。类似地，椅面也是由板材拼接而成。 观察餐桌面和椅面横截面的拼接痕迹，判断是企口拼接法，类似于实木地板之间的拼接方法。这是一种能够和胶水黏合并用的拼接法，且在胶水失效后仍然有一定机械强度，能保持版面平整和紧密性。 仔细察看整套桌椅，在框架、横梁等处，均采用整根木材制作。 桌腿和椅腿则采用两段或者三段板材拼接而成。 餐桌桌底四条穿带榫横档排布桌底，支撑桌面。使用穿带榫结构，可以增加桌面承重力，同时也有效防止桌面变形，翘曲。 穿带榫又称作“档木”。传统家具中的穿带榫一般安装在桌、几、案、椅、凳等面板的背面，以燕尾榫与面板相连，因为它贯穿在面板的两侧，故称“穿带”。穿带榫既可以支撑面板承受压力，同时又向下拉住面板，不使其上翘、弯曲和左右串动，这就是穿带榫的作用所在。 餐椅椅腿采用两段拼接（直段部分）或者三段拼接（有歪曲的部分）。餐椅靠背的两块木料通过榫卯方式固定在两边立柱上：餐椅底部是框架+横梁的结构+螺丝固定： 结构总结：桌面和椅面采用板材拼接而成，桌腿和椅腿大部分采用两段板材拼接，椅腿连靠背立柱采用三段板材拼接，框架、横梁则采用整根板材制成。 板材按照全美硬木板材协会(NHLA)的等级分类，实木板材被分为 FAS（一级），FAS 单面，S&amp;B（特选级），No.1C（普 1 级），No.2AC（普 2 级）这几个大致级别，从官方产品描述的信息来看，基本可以认为是选用的普 1 级的黑胡桃木。 板材纹理 板材厚度18mm 的厚度对于餐桌桌面来说，是有点薄的。 总结这套安格尔黑胡桃木餐桌椅，1.4 米加上 4 把椅子的款式，在 小米有品 上最低的价格是 4999 元。从选材上讲，这套安格尔餐桌椅实木部件均采用黑胡桃木芯材，木纹细腻，疏密有致，变化丰富，色泽统一。从设计上讲，桌椅造型简洁现代，桌面和椅面融合了悬浮设计理念，使其看上去更加灵动，加入黄铜装饰件点缀，提升了整套餐桌椅的质感，同时也区别于市面多数实木家具设计。从工艺上讲，餐桌椅使用了大量榫卯结构，在增加了结构强度的同时，也是对传统木工的一种传承和回归。从做工上讲，整套桌椅无论明暗面各个部件，都是一致对待，装配严谨，打磨光滑，涂装均匀，手感温润。目前来看，这套安格尔桌椅有着挺强的综合竞争力。 更新2020 年 12 月 23 日，在了解了更多实木家具知识和实木家具品牌后，认为铜师傅的这套黑胡桃木餐桌椅不太值得购买，用料和工艺不如宣传的那么好。 链接 加一千也买不到的原创设计——有品网铜师傅安格尔黑胡桃木餐桌椅套装众测报告 不完美但别有韵味，铜师傅安格尔黑胡桃木餐桌套装体验]]></content>
      <tags>
        <tag>装修</tag>
        <tag>心愿清单</tag>
        <tag>家具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线图片压缩工具]]></title>
    <url>%2Fpassages%2F%E5%9C%A8%E7%BA%BF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[收集几个体验好的在线图片压缩工具。 recompressor 免费 界面清爽，无广告 安全。上传的图片在浏览器内通过 JavaScript 处理，不会发送到服务器端 支持一键拖拽图片上传，支持批量下载已压缩图片 压缩质量可选，并以图表形式列出不同压缩质量下的压缩率、文件大小等信息 支持格式：.svg, .jpg, .png 其他图片处理服务（付费）： Clipping Magic: Easily clean up and remove the background from your photos. Great for use on product images for your eCommerce store. Vector Magic: Easily convert bitmap files (JPEG, PNG, BMP and GIF) to vector images (PDF, SVG, EPS, AI). Great for making logos printable on T-Shirts or to embroider them on hats. picdiet 免费 界面清爽，无广告 安全。上传的图片在浏览器内通过 JavaScript 处理，不会发送到服务器端 压缩质量可选 支持格式 .jpeg 和 .jpg 宣称比 jpegoptim, jpegtran, jpegrescan, jpegmini 这些常见的图片压缩工具性能更佳]]></content>
      <tags>
        <tag>工具</tag>
        <tag>图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化博客的网页性能]]></title>
    <url>%2Fpassages%2F%E4%BC%98%E5%8C%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[未优化前的性能指标使用 Google 的 PageSpeed Insights 评估，移动设备得分：91，各项指标如下： 指标 时间（估算值） 首次内容绘制时间 1.9 秒 速度指数 3.5 秒 可交互前的耗时 3.6 秒 首次有效绘制时间 3.0 秒 首次 CPU 闲置时间 3.4 秒 输入延迟（估算值） 30 毫秒 优化建议这些优化建议可以加快网页加载速度。 优化建议 有望节省的总时间（估算值） 1. 适当调整图片大小 4.05 s 2. 采用新一代格式提供图片 2.4 s 3. 移除阻塞渲染的资源 0.93 s 4. 移除未使用的 CSS 0.3 s 使用 gulp 压缩 html, css, js, images 等gulp 让你用代码实现一组任务的串行或者并行执行。 一个典型的 gulpfile.js 可能是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const &#123; src, dest, parallel &#125; = require('gulp')const minifycss = require('gulp-minify-css')const uglify = require('gulp-uglify')const htmlmin = require('gulp-htmlmin')const htmlclean = require('gulp-htmlclean')const imagemin = require('gulp-imagemin')const minifyHtml = () =&gt; src('./public/**/*.html') .pipe(htmlclean()) .pipe( htmlmin(&#123; removeComments: true, minifyCSS: true, minifyURLs: true, minifyJS: true &#125;) ) .pipe(dest('./public'))const minifyCss = () =&gt; src('./public/**/*.css') .pipe( minifycss(&#123; compatibility: 'ie8' &#125;) ) .pipe(dest('./public'))const minifyJs = () =&gt; src('./public/**/*.js') .pipe(uglify()) .pipe(dest('./public'))const minifyImage = () =&gt; src('./public/images/*.*') .pipe( imagemin( [ imagemin.gifsicle(), imagemin.jpegtran(), imagemin.optipng(), imagemin.svgo() ], &#123; verbose: true &#125; ) ) .pipe(dest('./public/images'))const build = parallel(minifyHtml, minifyCss, minifyJs, minifyImage)module.exports = &#123; default: build&#125; 移除阻塞渲染的资源PageSpeed tools 给出的优化建议如下： 资源阻止了系统对您网页的首次绘制。请考虑以内嵌方式提供关键的 JS/CSS 并推迟提供所有非关键的 JS/样式。网址大小有望节省的时间…dist/jquery.fancybox.min.css(cdn.jsdelivr.net)4 KB780 ms/css?family=…(fonts.googleapis.com)1 KB780 ms…css/font-awesome.min.css(cdn.jsdelivr.net)7 KB930 ms/css/main.css?v=7.1.0(cddbysj.github.io)10 KB330 ms 从上面的表格可以看出，都是形如 &lt;link rel=&quot;stylesheet&quot; href=&quot;**/*.css&quot;&gt; 这样的标签发起请求 CSS 文件导致阻塞渲染。 前置知识在所有的 HTML 标签中，涉及到引用或者请求外部资源的，主要有以下几个标签： &lt;script src=&#39;script.js&#39;&gt;&lt;/script&gt; &lt;link href=&#39;stylesheet&#39; ref=&#39;style.css&#39;/&gt; &lt;img src=&#39;image.png&#39;/&gt; &lt;a href=&#39;https://somethere.com&#39;&gt;To somewhere&lt;a/&gt; 那么 href 与 src 这两个属性有何区别呢？ 以下说明来自 Stackoverflow 的一个对 difference-between-src-and-href 问题的回答： There is a differentiation between src and href and they can’t be used interchangeably. We use src for replaced elements while href for establishing a relationship between the referencing document and an external resource.href (Hypertext Reference) attribute specifies the location of a Web resource thus defining a link or relationship between the current element (in case of anchor a) or current document (in case of link) and the destination anchor or resource defined by this attribute. When we write:&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;The browser understands that this resource is a stylesheet and the processing parsing of the page is not paused (rendering might be paused since the browser needs the style rules to paint and render the page). It is not similar to dumping the contents of the css file inside the style tag. (Hence it is advisable to use link rather than @import for attaching stylesheets to your html document.)src (Source) attribute just embeds the resource in the current document at the location of the element’s definition. For eg. When the browser finds&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;The loading and processing of the page is paused until this the browser fetches, compiles and executes the file. It is similar to dumping the contents of the js file inside the script tag. Similar is the case with img tag. It is an empty tag and the content, that should come inside it, is defined by the src attribute. The browser pauses the loading until it fetches and loads the image. [so is the case with iframe]This is the reason why it is advisable to load all JavaScript files at the bottom (before the tag) 需要注意的是，上面的回答由于是几年前的，&lt;script&gt; 标签的 async 与 defer 属性还没有加入到标准中。它们的作用如下： &lt;script src=&#39;script.js&#39; async&gt;脚本会异步执行，即不会中断浏览器解析页面，在可行的时候才执行脚本。 &lt;script src=&#39;script.js&#39; defer&gt;脚本会在页面解析完成后才执行。 &lt;script src=&#39;script.js&#39;&gt;浏览器会中断页面的解析，转而下载、编译、执行该脚本，完成后再继续解析页面。 分析以第一项 CSS 资源为例，这是 fancybox 的 CSS 样式表，博客首页完全用不到，可以推迟提供。通常的做法是将 &lt;link&gt; 标签转化为 &lt;script 标签，然后稍后动态地创建 &lt;link&gt; 标签。 123// 获取 &lt;head&gt; 标签内的 &lt;link&gt; 标签const styleLinks = [...document.querySelectorAll('link[rel=stylesheet]')]const links = styleLinks.filter(el =&gt; el.parentNode === document.head) 对于其他的 CSS 资源，更合理精细的做法是只保留影响首页的那些 CSS 规则，其余的都推迟提供。 参考链接 PageSpeed tools - Google 分析网站的性能，展示详细的结果并给出详细的建议 Pingdom Website Speed Test Hexo performance optimizations]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 问题之居中一个元素]]></title>
    <url>%2Fpassages%2FCSS%20%E9%97%AE%E9%A2%98%E4%B9%8B%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[来自 freeCodeCamp 的 这篇文章 已经写的非常好了。 动手实践：使用 CSS 画一颗心 See the Pen heart by BillWen (@cddbysj) on CodePen.]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买一张木桌]]></title>
    <url>%2Fpassages%2F%E4%B9%B0%E4%B8%80%E5%BC%A0%E6%9C%A8%E6%A1%8C%2F</url>
    <content type="text"><![CDATA[如何根据自己的需求买到一张合适的木桌？ 通过抽象，桌子主要有以下三种形式： 假如人在桌子旁边： 我们来看上图，3 张桌子的间距其实是一致的，但 2 个人偶站居其中以拟人心态去体验的话，第一张桌子的预期伤害系数更低，第二第三张桌子因为来自桌面的横向张力，人类会自主的更加小心同时给出更大的避让空间。哪怕他们造成伤害的系数一致。这是人基于潜在意识里的经验，给自身的心理暗示。 3 种形式的桌子并无优劣之分，但放置在不同条件的空间里其匹配性就各有千秋了。 显而易见，第一张桌子，即四平桌，这种形式对于小户型而言更优。不管是在人的视觉感知层面还是实际空间上，四平桌都更具优势。 视觉感知：四平桌较低的视觉张力，使得人的潜意识认为行动通行空间更宽裕。 实际空间：考虑到小户型的桌子摆放位置，桌面至少有一边是靠墙的。这样四平桌的两个桌腿和一个桌面都与墙面贴合，显得更加融合、安静，实际占据的空间也确实更小。 通常来说，对于小户型而言，第一种场景是最常见也是最合适的。 另外，很多卖场、展示和体验店，都是这种四面平桌的形式，对于流动空间和展示都是最好的应用。 四腿内收与四腿不内收前面的三张桌子，代表了桌子的两大类型，四腿内收和四腿不内收。第一张桌子是四腿不内收的代表；后两张桌子都是四腿内收的代表。这2种形式在功能和工艺上各有长处。较早之前桌子四腿不内收的典型代表是四面平和八仙桌，内收的条案。国外反而几乎见不到四平桌，基本都是内收。或者至少是留一些桌面的边缘。 工艺对比： 四腿内收在基于实木材料上，实现难度更低，工艺成本也更低，精度配合要求非常低。 而以四平桌为代表的四腿不内收形式，在桌面缩胀的基础上要保持 4 面望板和 4 腿的配合都是 3 个部件的配合，工艺难度非常大。 从零到一所以，一个理想中的，剥离了所有装饰元素，最极致简约的四平卓是这样的： 然而，这样的桌子几乎无法使用。最直观的一点是，棱角过于锋利，桌子的使用者极易被磕碰到。所以有了下图： 在前面的基础上，减少器物与人体交互时动作的干涉： 围边的斜面，减少起身动作时与胸部以下躯干和服饰的刮擦； 桌腿内侧斜面去掉了 90 度棱线，以面代线与人体接触； 外侧桌面与桌腿圆角大于股骨直径，降低磕碰强度； 桌腿上宽下细，偏移受力垂直轴心，更加稳固； 以上线面的变化，无不是功能逻辑出发，并非装饰，最终在桌腿上交汇、过渡、衔接，运用车体设计的渐消锋面技法，GO-G3 级曲面结合的变化也使光影更为丰富； 桌面边缘 2.5D 曲面，使桌面边缘棱线与桌面落差 5 毫米，大于前臂真皮厚度，不会压迫皮肤和血管。 所有这些细节的设计无不是从逻辑出发，为舒适服务。 大部分家具是弱交互的器具。比如桌子，没有人为了用桌子而用桌子，一定是在桌上从事某项动作。不舒适也许会有响应，舒适反而察觉不到。如此，便是存在感的进一步弱化。 框架结构 除了入户最后装配的4条桌腿为五金链接，主体框架结构全是榫卯。 产品照 这里应该再写一些其他的东西，待补上。 然后我在天猫上的一家网红实木家具店，找到了 同款桌子。 餐桌椅目标一：铜师傅安格尔黑胡桃原木餐桌椅不得不说，小米的产品，对产品的描述做的很用心。仔细看了一番，发现有以下几点是值得注意的： 从产品图片来看，以及商品未明确指出非指接板工艺，这套黑胡桃木餐桌椅应该是使用了指接板工艺，而非长度方向或者宽度方向的大板直拼。 有关商品的选材，产品描述中只提到美国黑胡桃木，而未提及木材的分级。可以排除使用了最高级的 FAS 的可能性，较大可能采用了 1com 普通一级的木材。 以上 2 点，说明 这套餐桌椅 在选材上的成本并不是很高。不过它的工艺应该比天猫上几个网红实木家具店（源氏木语、林氏木业、原始原素、维莎等）用心可靠。 这里顺带说一下这几个实木家具网店的共同点： 在选材上，极大概率夸大了材质，比如都宣称采用北美的 FAS 级白橡木，但是根据北美相关规范的定义，餐桌直拼板的宽度明显达不到规范内的要求，普遍偏小了。 产品的宣传重点主要在两个方面：一是反复强调实木，无指接板，无人造板，无贴皮，北美白橡木和美国黑胡桃木如何优秀等；二是强调使用的木蜡油是某知名品牌，既好用又环保健康。但是对自身产品的工艺，极少提到，比如桌板与桌腿之间如何衔接固定等。具体来说，你几乎看不到一张将桌子翻过来的产品细节图。 产品设计十分单一，多是几个重复的、高度同化的爆款产品。 外部链接 设计故事 - 木桌]]></content>
  </entry>
  <entry>
    <title><![CDATA[平面设计的 4 个基本原则]]></title>
    <url>%2Fpassages%2F%E5%B9%B3%E9%9D%A2%E8%AE%BE%E8%AE%A1%E7%9A%84%204%20%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[摘录自 《写给大家看的设计书》。这本书出自一位世界级设计师之手。复杂的设计原理在书中凝炼为亲密性、对齐、重复对比 4 个基本原则。作者以其简洁明快的风格，将优秀设计所必须遵循的这 4 个基本原则及其背后的原理通俗易懂地展现在读者面前。这 4 个基本原则是: 对比 Contrast 对比的基本思想是，要避免让页面上的元素太过相似。要让页面引人注目，对比通常是最重要的一个因素。 重复 Repetition 让设计中的视觉要素在整个作品中重复出现，可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片等。这样一来，既可以增加条理性，也能加强统一性。 对齐 Alignment 任何东西在页面上都不能随意安放。如果某些元素存在某种联系，那么这些元素间也应该具有视觉上的联系。这样能建立一种清晰、精巧而且清爽的外观。 亲密性 proximity 彼此相关的项应该靠近，组织在一起。如果多个项之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个孤立的元素。这有助于组织信息，减少混乱，为读者提供清晰的结构。 亲密性思想的真实含义是：如果某些元素在理解上存在关联，或者它们相互之间存在某种关系，那么这些元素在视觉上也应该存在关联。除此之外，其他孤立的元素或元素组则不应存在亲密性。位置是否靠近可以体现出元素之间是否存在关系。]]></content>
      <tags>
        <tag>设计</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十分钟学会的小技能]]></title>
    <url>%2Fpassages%2F%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%9A%84%E5%B0%8F%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[国外的问答网站 Quora 上面有这样一个问题: What can I learn right now in just 10 minutes that could be useful for the rest of my life? 有一个回答在 Quora 获得一万多赞。以下是某位网友翻译的。 十分钟就能学会但是终生受用的技能： 人们倾向于记住最先发生的事情和最后发生的事情。中间的事情记不清楚。所以，如果你要做自我介绍的话，最好做第一个或者最后一个。面试的时候，也是一样的。 如果你在酒吧或者前台工作，在你身后放一面镜子。这样的话，当顾客发脾气的时候，就能从镜子里看到自己的丑恶嘴脸。一面镜子可以显著降低他们无理取闹的概率。 报价之后，不再说话。如果你是做销售工作的，这项技巧很有用。在其他领域，这项技巧也很有用。我之前干过一份工作，是在一家体育馆卖会员卡。有个老家伙就是这么指导我的，他说，一旦你和顾客寒暄完毕，报出了你的价格。从此时开始，先开口的那个就输了。看起来好像毫无根据，但确实是这个样子的。通常会有很长时间的尴尬沉默，但是，最终，顾客会买的。 如果你问了别人一个问题，然后他们回答了一半，你等着，他们会说完的。只要等着，保持眼神接触，最终，他们会开口讲完的。 公开讲话或者蹦极之前这种会紧张的时刻，嚼口香糖就好了。据说是因为人类在危险的时候会自动停止咀嚼（吃东西），所以吃东西的时候就是安全的，大脑就是这么告诉你的。反正这招对我很管用。 人们最终记住的不是你说过的话，而是你让他们产生的感觉。几乎所有的人都喜欢谈论自己的事情，所以，多问问题。 当你学习新东西的时候，尝试着教给朋友们，或者让他们问你相关的问题。如果你能教给人一杯水，你自己一定会有一桶水。 如果你看到某人时，很开心，溢于言表的开心，那么他们以后看到你也会手舞足蹈的。第一次也许不是这样，但第二次一定是。 身体对压力的反应——呼吸加速，心跳加快——和鼓起勇气时的反应是一样的。所以是好是歹，全在你一念之间。反正你的身体已经都准备好了，你看着办吧。 注意别人的脚。当你加入别人的谈话时，发现别人只是把上半身转过来了，脚还是维持原来的方向，那就说明他们不欢迎你的加入。类似的，你和你的同事谈话时，你觉得他在专心和你谈话，他的身体也面向你，但他的脚却不是朝向你的，他可能早就已经受不了这场谈话了。 装出牛逼的样子，直到你做到了；信心比知道更重要。别被任何人吓住，生活不易，全靠演技，那些吓你的人也在演戏。 你假装成什么样子，你最终就会成为什么样子。装逼得逼，求仁成仁，念念不忘，必有回响。 虽然不是要你去吓人，但如果你一定要厚颜无耻的盯着某人，视线聚集在他的两只眼睛中间，等着他们害羞。如果他们移开视线，他们就不会再看着你。这个时候，你就可以肆无忌惮的盯着他们的眼睛了。至少有 45 秒的时间哦。 建立人际网络。成为朋友们的信息源，当然，他们也会是你的信息源。和前同事一起喝杯酒吧，也是好的。 如果你前面的车子慢的像是老爷爷在开，你恨不得杀了他。假装他真的是你的亲爷爷。 然后你的怒气就全消了。 站得直。 不许没精打采，不许手插兜，头要高高抬起。不要觉得这是陈词滥调。你自己会因此觉得很好，而且周围的人也会感受到你的自信。 不要说“我觉得”、“我认为”，除非真的有必要。这些词语会让你和自信无缘，对你可没什么好处。 焦虑的时候，收拾一下家里或者工作桌。你会比之前更开心、更有感觉。 第一次饭，第一支酒，你请。你都不知道你自己会因此而自我感觉良好多久。 为人父母者请注意：给孩子们选择的权利，让他们认为自己掌控自己的生活。比如我想让孩子自己穿鞋的时候，我会问他“你是想穿那双星星的，还是鲨鱼的？”。值得注意的是，这招对成年人也管用。 态度决定行动，可是行动也决定态度。就像我以前的一个老师说的那样：你可以因为高兴而跳起舞来，也可以故意跳起舞来让自己高兴。 一群人在大笑的时候，人们会立刻看向这群人里最亲近的人。 如果你想和某人建立密切的关系，或者获得某人的信任，学习他的身体的姿势。 本杰明·富兰克林效应。借给别人钱的人会比欠别人钱的记得更清楚，而且会不由自主地对借贷者产生好感。调情的时候也很有用。“同学，借我一根铅笔”。或者开玩笑似的让女孩请你喝支酒。这可是一石三鸟的事情：你得到了好处；她会下意识的更喜欢你；将来她接受你的“帮助”也会更加没有负担。]]></content>
      <tags>
        <tag>百科知识</tag>
        <tag>生活</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家具木材指南之人造板篇]]></title>
    <url>%2Fpassages%2F%E5%AE%B6%E5%85%B7%E6%9C%A8%E6%9D%90%E6%8C%87%E5%8D%97%E4%B9%8B%E4%BA%BA%E9%80%A0%E6%9D%BF%E7%AF%87%2F</url>
    <content type="text"><![CDATA[人造板是以木材或其他非木材植物为原料，经一定机械加工分离成各种单元材料后，施加或不施加胶粘剂和其他添加剂胶合而成的板材或模压制品。主要包括胶合板、刨花（碎料）板、纤维板三大类产品，其延伸产品和深加工产品达上百种。人造板的诞生，标志着木材加工现代化时期的开始。此外，人造板还可提高木材的综合利用率，1立方米人造板可代替3～5立方米原木使用。 –百度百科 胶合板胶合板，LVL(Laminated Veneer Lumber)，更通用的英文用语是 Plywood。是由蒸煮软化的原木，旋切成大张的薄木片，然后使上下相邻两层木片的纤维方向相互垂直放置，用酚醛胶、脲醛胶或者三聚氰胺胶粘结，再经加压、干燥、锯边、表面修整而成的板材。其层数通常为奇数，一般为3-13层，分别称三合板、五合板等。用来制作胶合板的树种有椴木、桦木、水曲柳、榉木、色木、柳桉木等。 注意上图中，相邻木片的纹理强度方向交错胶合（顺向-亮色）（断面-暗色）。 使用胶合板代替木板的普遍原因是因为胶合板具有很强的抗破裂、抗收缩、抗扭曲和普通的高强度属性。LVL 区别于 Glulam，Glued laminated timber。 为了尽量改善天然木材各向异性的特性，使胶合板特性均匀、形状稳定，一般胶合板在结构上都要遵守两个基本原则：一是对称；二是相邻层单板纤维互相垂直。对称原则就是要求胶合板对称中心平面两侧的单板，无论木材性质、单板厚度，层数、纤维方向，含水率等，都应该互相对称。在同一张胶合板中，可以使用单一树种和厚度的单板，也可以使用不同树种和厚度的单板；但对称中心平面两侧任何两层互相对称的单板树种和厚度要一样。面背板允许不是同一树种。要使胶合板的结构同时符合以上两个基本原则，它的层数就应该是奇数。所以胶合板通常都做成三层，五层、七层等奇数层数。胶合板各层的名称是：表层单板称为表板，里层的单板称为芯板；正面的表板叫面板，背面的表板叫背板；芯板中，纤维方向与表板平行的称为长芯板或中板。在组成腔台板板坯时，面板和背板必须紧面朝外。 种类按使用途径我国新制订的国家标准(报批草案)根据胶合扳使用情况，将胶合板分为： 涂饰用胶合板 – 用于表面需要涂饰透明涂料的家具、缝纫机台板和各种电器外壳等制品 装修用胶合板 – 用作建筑、家具，车辆和船舶的装修材料 一般用胶合板 – 适用于包装，垫衬及其它方面用途 薄木装饰胶合板 – 用作建筑，家具，车辆，船舶等的高级装饰材料 按照国家标准中的术语定义按照国标 普通胶合板 GB/T 9846-2015 中的术语，有以下 3 类胶合板： I 类胶合板 - class I plywood II 类胶合板 - class II plywood III 类胶合板 - class III plywood 名称 定义 国标 I 类胶合板 能够通过煮沸试验，供室外条件下使用的耐气候胶合板。 GB/T 18259-2009，定义 2.2.1.18 II 类胶合板 能够通过 63 ℃ ± 3 ℃ 热水浸溃试验，供潮湿条件下使用的耐水胶合板。 GB/T 18259-2009，定义 2.2.1.19 III 类胶合板 能够通过 20 ℃ ± 3 ℃ 冷水浸泡试验，供干燥条件下使用的不耐潮胶合板。 GB/T 209846-2015，定义 3.3 外观质量胶合板按成品板面板上可见的材质缺陷和加工缺陷的数量和范围分成优等品、一等品、合格品 3 个等级。详情见普通胶合板 GB/T 9846-2015 国标。 理化性能胶合板的物理化学性能，主要从 5 个维度来评估： 含水率 胶合强度 浸渍剥离 静曲强度和弹性模量 甲醛释放量 含水率 (%) 胶合板板种 I 、II 类 III 类 阔叶树材 5~14 5~16 针叶树材 5~14 5~16 胶合强度 (MPa) 树种名称／木材名称／国外商品材名称 I 、II 类 III类 椴木、杨木、拟赤杨、泡桐、橡胶木、柳安、奥克榄、白梧桐、异翅香、海棠木、桉木 ≥ 0.70 ≥ 0.70 水曲柳、荷木、枫香、槭木、榆木、柞木、阿必东、克陈、山樟 ≥ 0.80 ≥ 0.70 桦木 ≥ 1.00 ≥ 0.70 马尾松、云南松、落叶松、云杉、辐射松 ≥ 0.80 ≥ 0.70 浸渍剥离当胶合板相邻层单板木纹方向相同时，应进行浸渍剥离试验，每个试件同一胶层每边剥离长度累计不超过 25 mm。 静曲强度和弹性模量略，详情见标准。这里 是一份普通胶合板 GB/T 9846-2015 PDF 格式的存档。 甲醛释放量按照 室内装饰装修材料 人造板及其制品中甲醛释放限量 GB 18580-2017 规定执行。 装饰单板贴面胶合板装饰单板贴面胶合板是室内装修最常使用的材料之一。由于该产品表层的装饰单板是用优质木材经刨切或旋切加工方法制成的，所以比胶合板具有更好的装饰性能。我国装饰单板贴面胶合板标准规定装饰单板贴面胶合板分为优等品、一等品、合格品三个等级。在此提醒厂家和消费者其他分等形式均不符合我国装饰单板贴面胶合板标准，例如有的厂家标识等级为“AAA”，这是企业行为。 国家标准对装饰单板贴面胶合板的性能要求：我国现行的是推荐标准 GB/T 15104-2006 《装饰单板贴面人造板》，绝大部分企业的生产执行此标准。该标准对装饰单板贴面胶合板在外观质量、加工精度、物理力学性能三个方面规定了指标。其物理力学性能指标有：含水率、表面胶合强度、浸渍剥离。GB 18580-2017 《室内装饰装修材料 人造板及其制品中甲醛释放限量》还规定了该产品的甲醛释放限量指标。 通常天然木质单板饰面板所贴饰面单板往往是花纹好，身价高的树种，比如柏木、橡木、花梨木、水曲柳等。但是在商品名称中应当予以说明，比如称为“柏木贴面胶合板”，或者“水曲柳切片胶合板”，或者“樱桃木饰板”。几种称法中“贴面”、“切片”、“饰板”都反映了“饰板”的基本特征。但是不能以柏木三合板、水曲柳三合板等简称，因为这些简称泛指胶合板的面板、底板都由柏木或水曲柳制成。 纤维板纤维板是将树皮、刨花、树枝等以木质纤维或其他植物素纤维为原料经破碎、浸泡、研磨成木浆，施加脲醛树脂或其他适用的胶粘剂，经加压成型、干燥处理而制成的板材。因成型时温度和压力不同，可以分为硬质、半硬质、软质三种。又名密度板，按照密度对应前面三种又称为高密度纤维板、中密度纤维板、低密度纤维板。纤维板具有材质均匀、纵横强度差小、不易开裂等优点。 刨花板刨花板是利用施加或未施加胶料的木刨花或木纤维料压制成的板材。刨花板密度小、材质均匀，但易吸湿、强度低。 与人造板有关的国家标准 普通胶合板 GB/T 9846-2015本标准规定了普通胶合板的术语和定义、分类、要求、测量及试验方法、检验规则以及标志、包装、运输和贮存等。本标准适用于普通胶合板，不适用于细木工板、单板层积材等不同结构和特殊性能要求的胶合板。 装饰单板贴面人造板 GB/T 15104-2006本标准规定了装饰单板贴面人造板（又称薄木贴面人造板）的术语和定义、分类、要求、试验方法、检验规则以及标志、包装、运输和贮存等。本标准适用于以普通单板、调色单板、集成单板和重组装饰单板等为饰面材料，以人造板为基材经胶合制成的未经涂饰加工的装饰单板贴面人造板。 室内装饰装修材料 人造板及其制品中甲醛释放限量 GB 18580-2017本标准规定了室内装饰装修用人造板及其制品中甲醛释放限量要求、试验方法。本标准适用于纤维板、刨花板、胶合板、细木工板、重组装饰材、单板层积材、集成材、饰面人造板、木质地板、木质墙板、木质门窗等室内用各种类人造板及其制品的甲醛释放限量。 中密度纤维板 GB/T 11718-2009本标准规定了中密度纤维板的术语、定义和缩略语、分类和附加分类、要求、测量和试验方法、检验规则、标志、包装、运输和贮存等。本标准适用于干法生产的中密度纤维板。 室内装饰装修材料 胶粘剂中有害物质限量 GB 18583-2008本标准规定了室内建筑装饰装修用胶粘剂中有害物质限量及其试验方法。本标准适用于室内建筑装饰装修用胶粘剂。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检验检测机构的资质认定.md]]></title>
    <url>%2Fpassages%2F%E6%A3%80%E9%AA%8C%E6%A3%80%E6%B5%8B%E6%9C%BA%E6%9E%84%E7%9A%84%E8%B5%84%E8%B4%A8%E8%AE%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[检验检测机构的资质认定在我国，评判一个检测实验室或者其他类型的检验检测机构的资质，主要看是否获得以下两个认证： CMA - China Metrology Accredidation CNAS - China National Accreditation Service for Conformity Assessment CMA一般称为中国计量认证或者中国实验室资质认证。是依据《中华人民共和国计量法》、《中华人民共和国认证认可条例》等有关法律、法规的规定，对为社会出具公证数据的检验机构进行强制考核的一种手段，是政府对第三方实验室的行政许可，是政府权威部门对检测机构进行规定类型检测所给予的正式承认。实验室获得 CMA，才具备向用户、社会及政府提供公正数据的条件和资格。CMA 证书备有所批准合格的检测项目附表，取得 CMA 证书的检测机构只能按照附表中所批准的项目进行检测业务。 国家质量监督检验检疫总局《检验检测机构资质认定管理办法》（总局令第163号）：第四十一条 检验检测机构未依法取得资质认定，擅自向社会出具具有证明作用数据、结果的，由县级以上质量技术监督部门责令改正，处3万元以下罚款。第四十五条 检验检测机构有下列情形之一的，资质认定部门应当撤销其资质认定证书：（一）未经检验检测或者以篡改数据、结果等方式，出具虚假检验检测数据、结果的；（二）违反本办法第四十三条规定，整改期间擅自对外出具检验检测数据、结果，或者逾期未改正、改正后仍不符合要求的；（三）以欺骗、贿赂等不正当手段取得资质认定的；（四）依法应当撤销资质认定证书的其他情形。被撤销资质认定证书的检验检测机构，三年内不得再次申请资质认定。 我国的 CMA，由国家认证认可监督管理委员会（CNCA）统一管理，分国家和省两级实施。国家认证认可监督管理委员会统一管理、监督和综合协调实验室的资质认定工作，国家级实验室的资质认定由国家认监委负责实施；各省、自治区、直辖市人民政府质量技术监督部门和各直属出入境检验检疫机构按照各自职责负责所辖区域内的实验室的资质认定和监督检查工作，地方级实验室的资质认定，由地方质检部门负责实施。 CNAS即中国合格评定国家认可委员会，是根据《中华人民共和国认证认可条例》的规定，由国家认证认可监督管理委员会（英文缩写为：CNCA）批准成立并确定的认可机构，统一实施对认证机构、实验室和检验机构等相关机构的认可工作。 取得 CNAS 证书意味着认可机构批准实验室从事特定的校准或检验活动, 经认可的实验室或认证、审核机构表明其具有从事特定任务的能力。通过国家实验室认可的检测技术机构，证明其符合国际上通行的校准与检测实验室能力的通用要求，即 CNAS 认可对实验室的法律地位没有限制，可以是企业内部的实验室，也可以是独立的第三方实验室。 CMA 与 CNAS 的区别 评审组织机构的区别CNAS 的评审组织机构和发证机构是中国合格评定国家认可委员会。CMA 分省级和国家级的，国家级实验室的资质认定由国家认监委负责，非国家级的实验室一般由所在地省级的质量技术监督局负责组织评审和发证。 评审原则的区别CNAS 秉承的是自愿、非歧视的原则。CMA 是针对为社会出具公证数据的检验机构进行的强制考核。 对实验室的法律地位要求的区别CNAS 认可对实验室的法律地位没有限制，可以是企业内部的实验室，也可以是独立的第三方实验室。CMA 认定的对象，需要是独立的第三方实验室、政府相关部门下属的事业单位实验室等。 报告有效范围的区别通过 CNAS 认可的实验室在其认可范围内出具的带 CNAS 标识的报告，可在全球的多个国家和地区通行（双方签署了互认协议 MRA）。通过 CMA 资质认定的实验室在其认定范围内出具的报告只在国内有效。 总结我国国内从事检验检测的机构必须取得 CMA 资质认证，否则为违法行为。也就是说，CMA 资质认定是强制考核的。CNAS 资质认定则是自愿性质的，同时 CNAS 可在全球的多个国家和地区通行，所以在国际上更具竞争力。 链接 CNCA - 中国国家认证认可监督管理委员会 国家计量认证实验室名录查询 全国认证认可信息公共服务平台]]></content>
  </entry>
  <entry>
    <title><![CDATA[好物日志]]></title>
    <url>%2Fpassages%2F%E5%A5%BD%E7%89%A9%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[这里记录我买过的好东西。 SONY 头戴式无线降噪耳机 WH-900NIRIS OHYAMA 日本爱丽思迷你空气循环扇米家 LED 智能台灯iPad mini 2小米手环 4 SONY 头戴式无线降噪耳机型号是 WH-900N。对机器发出的杂音(比如引擎发出的噪音)降噪效果不错，对人声降噪效果一般。另外这款耳机，不适合在比较热的环境里佩戴。淘宝购入。 IRIS OHYAMA 日本爱丽思迷你空气循环扇简约精致的空气循环扇。最小的一档是静音挡，声音确实比一般的风扇要小，同时它的送风距离较一般风扇更长。搭配空调使用效果更佳。 米家 LED 智能台灯造型简洁，可以灵活调节灯光角度，实体旋转按键可以调节灯光亮度和色温。另外支持 APP 远程开关、调节灯光。 iPad mini 2苹果的产品大部分是值得买的，这台 iPad 是在 2014 年 10 月购入，用到现在成色依然非常新，几乎没有出过什么毛病。由于期间只升级了一次系统到 iOS 9，所以目前系统仍然流畅，当然由于电池损耗，续航时间有所缩减，不过无伤大雅。友情提示，一般来说 iPad 最主要使用场景就是用来看视频或者电子书，至于其他的生产力，不要对自己的自控力太自信，也不要对 iPad 的生产力属性抱有太大期望。 小米手环 4如果目前手上没有手环/手表类产品，以 169 元这个价格来说是值得购买的。这款手环最实在的功能不外乎这几个： 显示时间想要看时间的时候不用掏手机了，部分取代手表的功能，手表的装饰性功能无法取代。 运动健康利用加速度传感器和三轴陀螺仪实现久坐提醒/计步功能；开启运动模式之后，利用心率传感器结合算法判断你处于有氧运动还是无氧运动状态。此外，结合小米运动 APP 定制自己的锻炼计划。小米运动 APP 上有许多针对不同目的（减脂/增肌/塑形）有不同的健身教程，同时会记录你的健身过程，还有部分社交功能。 来电提醒/短信/微信消息/天气 控制音乐播放支持暂停/播放/上一首/下一首/音量调节。对于不带线控或者触控的耳机来说非常方便。 闹钟/秒表等常见工具软件 手环的技术规格信息：小米手环 4产品型号：XMSH07HM产品颜色：石墨黑无线连接：蓝牙 5.0BLE 版防水等级：5ATM输入电压：DC5.0V输入电流：250 mA MAX电池容量：135mAh电池类型：锂离子聚合物电池 CMIIT ID： 2019DP1398执行标准：Q/HM01-2018 请在手环的“监管”界面下查看产品 CMIIT ID支持系统：Android4.4 或 iOS9.0 及以上版本包装内含：手环主体、腕带、专用充电线、使用说明书（含三包凭证）委托方：小米通讯技术有限公司制造商：安徽华米信息科技有限公司（小米生态链企业）地址：合肥市高新区望江西路 800 号国家动漫基地 A4 楼 1201 室SKU：MGW4046CN服务电话：400-100-5678生产地址：上海市浦东新区生产日期：2019.05本产品的相关信息请查询销售网址 www.mi.com]]></content>
      <tags>
        <tag>生活</tag>
        <tag>好物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国主要木材名称的三大相关标准]]></title>
    <url>%2Fpassages%2F%E4%B8%AD%E5%9B%BD%E4%B8%BB%E8%A6%81%E6%9C%A8%E6%9D%90%E5%90%8D%E7%A7%B0%E7%9A%84%E4%B8%89%E5%A4%A7%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[《中国主要木材流通商品名称》WB/T1038-2008、《中国主要木材名称》GB/T16734-1997、《中国主要进口木材名称》GB/T18513-2001 标准出台后，三大标准配套使用，给各类木材企业的生产、经营、进出口等带来便利，也给各类商检、质检、专业机构与院校的执法与教学提供依据。 《中国主要木材名称》 GB/T16734-1997标准简介本标准共收载我国 380 类(个)木材名称(中、英名)及其树种名称(包括中名、别名、拉丁名)、科别、产地和备注。380 类木材名称是由 907 个树种归纳而来，其归类的原则是以树木学(或植物学)的属为基础，把材性和用途相近木材树种名称统一，以便利木材生产、利用、贸易、造林、营林、科研、教学等的应用。907 个树种隶属 99 科(针叶树材 8 科、阔叶树材 91 科)、347 属(针叶树材 33 属、阔叶树材 314 属)，基本上覆盖了我国重要木材树种。 木材树种名称按科以拉丁学名的字母顺序排列，既保持针、阔叶树材和科的完整性，又便于查找。科的范围，针叶树材参照郑万钧等《中国植物志》第七卷的系统概念，阔叶树材参照哈钦松的《有花植物科志》一书的概念，个别种的处理略有不同。在科内、属内木材树种名称原则上也按属及种以拉丁学名的字母顺序排列。 范围 本标准规定了中国主要木材的名称(中、英名)，树种中名、别名、拉丁名。 本标准适用于木材的科研、教学、木材生产和使用、贸易等部门。 《中国主要进口木材名称》 GB/T18513-2001标准简介本标准为首次发布。本标准共收集世界各国 423 个(类)木材名称，它们是由 1010 个树种归纳而来。1010 个树种隶 366 属(针叶树材 19 属;阔叶树材 347 属)、84 科(针叶树材 4 科;阔叶树材 80 科)，基本上包括了世界各国重要商品材树种。 范围 本标准规定了中国主要进口木材的木材名称、树种名称(树种中文名、树种拉丁文名)。 本标准适用于木材生产、贸易、科研及教学等。 《中国主要木材流通商品名称》 WB/T1038-2008标准简介本标准为首次发布。本标准共收集了目前中国市场上流通的主要国内外木材 416 个树种。按照科学性与实用性相结合的原则，根据树木分类科、属系统归纳成 340 类(个)。 木材流通商品名称按其所在科、属、种拉丁名字母顺序分级排列，同时介绍了科别、材色及密度和产地。本标准分进口针叶树材、进口阔叶树材和国产针叶树材、国产阔叶树材四部分。 范围 本标准规定了中国主要商品木材的木材名称、树种名称(中文名、拉丁名)、商品名、流通商品名。 本标准适用于木材生产、贸易、科研及教学等。 各种标准的下载地址]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 问答]]></title>
    <url>%2Fpassages%2Fevent%20loop%20%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[问答 像 V8 这样的 JavaScript 引擎，除了 call stack 和 heap，是否还有一个 callback queue(message queue/task queue)?答：JavaScript 引擎只有一个 call stack 和 一个 heap，callback queue 是由 JavaScript runtime 实现的，比如 Chrome 浏览器或者 NodeJS。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Event loop</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the V8 engine + 5 tips on how to write optimized code]]></title>
    <url>%2Fpassages%2FInside%20the%20V8%20engine%20%2B%205%20tips%20on%20how%20to%20write%20optimized%20code%2F</url>
    <content type="text"><![CDATA[接上一篇关于 JavaScript 的引擎、运行时、调用栈的技术文章，这篇文章主要集中于 V8 引擎以及写出高性能代码的 5 个小建议。原文链接在这里此外，这里是一篇中文翻译。 The first post of the series focused on providing an overview of the engine, the runtime and the call stack. This second post will be diving into the internal parts of Google’s V8 JavaScript engine. We’ll also provide a few quick tips on how to write better JavaScript code. OverviewA JavaScript engine is a program or an interpreter which executes JavaScript code. A JavaScript engine can be implemented as a standard interpreter, or just-in-time compiler that compiles JavaScript to bytecode in some form. This is a list of popular projects that are implementing a JavaScript engine: V8 — open source, developed by Google, written in C++ Rhino) — managed by the Mozilla Foundation, open source, developed entirely in Java SpiderMonkey — the first JavaScript engine, which back in the days powered Netscape Navigator, and today powers Firefox JavaScriptCore — open source, marketed as Nitro and developed by Apple for Safari KJS) — KDE’s engine originally developed by Harri Porten for the KDE project’s Konqueror web browser Chakra(JScript9)) — Internet Explorer Chakra(JavaScript)) — Microsoft Edge Nashorn) - open source as part of OpenJDK, written by Oracle Java Languages and Tool Group JerryScript — is a lightweight engine for the Internet of Things. Why was the V8 Engine created?The V8 Engine which is built by Google is open source and written in C++. This engine is used inside Google Chrome. Unlike the rest of the engines, however, V8 is also used for the popular Node.js runtime. V8 was first designed to increase the performance of JavaScript execution inside web browsers. In order to obtain speed, V8 translates JavaScript code into more efficient machine code instead of using an interpreter. It compiles JavaScript code into machine code at execution by implementing a JIT (Just-In-Time) compiler like a lot of modern JavaScript engines do such as SpiderMonkey or Rhino (Mozilla). The main difference here is that V8 doesn’t produce bytecode or any intermediate code. V8 used to have two compilersBefore version 5.9 of V8 came out (released earlier this year), the engine used two compilers: full-codegen — a simple and very fast compiler that produced simple and relatively slow machine code. Crankshaft — a more complex (Just-In-Time) optimizing compiler that produced highly-optimized code. The V8 Engine also uses several threads internally: The main thread does what you would expect: fetch your code, compile it and then execute it There’s also a separate thread for compiling, so that the main thread can keep executing while the former is optimizing the code A Profiler thread that will tell the runtime on which methods we spend a lot of time so that Crankshaft can optimize them A few threads to handle Garbage Collector sweeps When first executing the JavaScript code, V8 leverages full-codegen which directly translates the parsed JavaScript into machine code without any transformation. This allows it to start executing machine code very fast. Note that V8 does not use intermediate bytecode representation this way removing the need for an interpreter. When your code has run for some time, the profiler thread has gathered enough data to tell which method should be optimized. Next, Crankshaft optimizations begin in another thread. It translates the JavaScript abstract syntax tree to a high-level static single-assignment (SSA) representation called Hydrogen and tries to optimize that Hydrogen graph. Most optimizations are done at this level. InliningThe first optimization is inlining as much code as possible in advance. Inlining is the process of replacing a call site (the line of code where the function is called) with the body of the called function. This simple step allows following optimizations to be more meaningful. Hidden classJavaScript is a prototype-based language: there are no classes and objects are created using a cloning process. JavaScript is also a dynamic programming language which means that properties can be easily added or removed from an object after its instantiation. Most JavaScript interpreters use dictionary-like structures (hash function based) to store the location of object property values in the memory. This structure makes retrieving the value of a property in JavaScript more computationally expensive than it would be in a non-dynamic programming language like Java or C#. In Java, all of the object properties are determined by a fixed object layout before compilation and cannot be dynamically added or removed at runtime (well, C# has the dynamic type which is another topic). As a result, the values of properties (or pointers to those properties) can be stored as a continuous buffer in the memory with a fixed-offset between each. The length of an offset can easily be determined based on the property type, whereas this is not possible in JavaScript where a property type can change during runtime. Since using dictionaries to find the location of object properties in the memory is very inefficient, V8 uses a different method instead: hidden classes. Hidden classes work similarly to the fixed object layouts (classes) used in languages like Java, except they are created at runtime. Now, let’s see what they actually look like:123456function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2); Once the new Point(1,2) invocation happens, V8 will create a hidden class called C0. No properties have been defined for Point yet, so C0 is empty. Once the first statement this.x = x is executed (inside the Point function), V8 will create a second hidden class called C1 that is based on C0. C1 describes the location in the memory (relative to the object pointer) where the property x can be found. In this case, x is stored at offset 0, which means that when viewing a point object in the memory as a continuous buffer, the first offset will correspond to property x. V8 will also update C0 with a class transition which states that if a property x is added to a point object, the hidden class should switch from C0 to C1. The hidden class for the point object below is now C1. Every time a new property is added to an object, the old hidden class is updated with a transition path to the new hidden class. Hidden class transitions are important because they allow hidden classes to be shared among objects that are created the same way. If two objects share a hidden class and the same property is added to both of them, transitions will ensure that both objects receive the same new hidden class and all the optimized code that comes with it. This process is repeated when the statement this.y = y is executed (again, inside the Point function, after the this.x = x statement). A new hidden class called C2 is created, a class transition is added to C1 stating that if a property y is added to a Point object (that already contains property x) then the hidden class should change to C2, and the point object’s hidden class is updated to C2. Hidden class transitions are dependent on the order in which properties are added to an object. Take a look at the code snippet below:123456789101112function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.b = 7;p2.a = 8; Now, you would assume that for both p1 and p2 the same hidden classes and transitions would be used. Well, not really. For p1, first the property a will be added and then the property b. For p2, however, first b is being assigned, followed by a. Thus, p1 and p2 end up with different hidden classes as a result of the different transition paths. In such cases, it’s much better to initialize dynamic properties in the same order so that the hidden classes can be reused. Inline cachingV8 takes advantage of another technique for optimizing dynamically typed languages called inline caching. Inline caching relies on the observation that repeated calls to the same method tend to occur on the same type of object. An in-depth explanation of inline caching can be found here. We’re going to touch upon the general concept of inline caching (in case you don’t have the time to go through the in-depth explanation above). So how does it work? V8 maintains a cache of the type of objects that were passed as a parameter in recent method calls and uses this information to make an assumption about the type of object that will be passed as a parameter in the future. If V8 is able to make a good assumption about the type of object that will be passed to a method, it can bypass the process of figuring out how to access the object’s properties, and instead, use the stored information from previous lookups to the object’s hidden class. So how are the concepts of hidden classes and inline caching related? Whenever a method is called on a specific object, the V8 engine has to perform a lookup to the hidden class of that object in order to determine the offset for accessing a specific property. After two successful calls of the same method to the same hidden class, V8 omits the hidden class lookup and simply adds the offset of the property to the object pointer itself. For all future calls of that method, the V8 engine assumes that the hidden class hasn’t changed, and jumps directly into the memory address for a specific property using the offsets stored from previous lookups. This greatly increases execution speed. Inline caching is also the reason why it’s so important that objects of the same type share hidden classes. If you create two objects of the same type and with different hidden classes (as we did in the example earlier), V8 won’t be able to use inline caching because even though the two objects are of the same type, their corresponding hidden classes assign different offsets to their properties. The two objects are basically the same but the a and b properties were created in different order. Compilation to machine codeOnce the Hydrogen graph is optimized, Crankshaft lowers it to a lower-level representation called Lithium. Most of the Lithium implementation is architecture-specific. Register allocation happens at this level. In the end, Lithium is compiled into machine code. Then something else happens called OSR: on-stack replacement. Before we started compiling and optimizing an obviously long-running method, we were likely running it. V8 is not going to forget what it just slowly executed to start again with the optimized version. Instead, it will transform all the context we have (stack, registers) so that we can switch to the optimized version in the middle of the execution. This is a very complex task, having in mind that among other optimizations, V8 has inlined the code initially. V8 is not the only engine capable of doing it. There are safeguards called deoptimization to make the opposite transformation and reverts back to the non-optimized code in case an assumption the engine made doesn’t hold true anymore. Garbage collectionFor garbage collection, V8 uses a traditional generational approach of mark-and-sweep to clean the old generation. The marking phase is supposed to stop the JavaScript execution. In order to control GC costs and make the execution more stable, V8 uses incremental marking: instead of walking the whole heap, trying to mark every possible object, it only walk part of the heap, then resumes normal execution. The next GC stop will continue from where the previous heap walk has stopped. This allows for very short pauses during the normal execution. As mentioned before, the sweep phase is handled by separate threads. Ignition and TurboFanWith the release of V8 5.9 earlier in 2017, a new execution pipeline was introduced. This new pipeline achieves even bigger performance improvements and significant memory savings in real-world JavaScript applications. The new execution pipeline is built on top of Ignition, V8’s interpreter, and TurboFan, V8’s newest optimizing compiler. You can check out the blog post from the V8 team about the topic here. Since version 5.9 of V8 came out, full-codegen and Crankshaft (the technologies that have served V8 since 2010) have no longer been used by V8 for JavaScript execution as the V8 team has struggled to keep pace with the new JavaScript language features and the optimizations needed for these features. This means that overall V8 will have much simpler and more maintainable architecture going forward. These improvements are just the start. The new Ignition and TurboFan pipeline pave the way for further optimizations that will boost JavaScript performance and shrink V8’s footprint in both Chrome and Node.js in the coming years. Finally, here are some tips and tricks on how to write well-optimized, better JavaScript. You can easily derive these from the content above, however, here’s a summary for your convenience: How to write optimized JavaScript Order of object properties: always instantiate your object properties in the same order so that hidden classes, and subsequently optimized code, can be shared. Dynamic properties: adding properties to an object after instantiation will force a hidden class change and slow down any methods that were optimized for the previous hidden class. Instead, assign all of an object’s properties in its constructor. Methods: code that executes the same method repeatedly will run faster than code that executes many different methods only once (due to inline caching). Arrays: avoid sparse arrays where keys are not incremental numbers. Sparse arrays which don’t have every element inside them are a hash table. Elements in such arrays are more expensive to access. Also, try to avoid pre-allocating large arrays. It’s better to grow as you go. Finally, don’t delete elements in arrays. It makes the keys sparse. Tagged values: V8 represents objects and numbers with 32 bits. It uses a bit to know if it is an object (flag = 1) or an integer (flag = 0) called SMI (SMall Integer) because of its 31 bits. Then, if a numeric value is bigger than 31 bits, V8 will box the number, turning it into a double and creating a new object to put the number inside. Try to use 31 bit signed numbers whenever possible to avoid the expensive boxing operation into a JS object. Resource https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P--dtDvwXXEeD0/pub https://github.com/thlorenz/v8-perf http://code.google.com/p/v8/wiki/UsingGit http://mrale.ph/v8/resources.html https://www.youtube.com/watch?v=UJPdhx5zTaw https://www.youtube.com/watch?v=hWhMKalEicY]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[an overview of the engine, the runtime, and the call stack]]></title>
    <url>%2Fpassages%2Fan%20overview%20of%20the%20engine%2C%20the%20runtime%2C%20and%20the%20call%20stack%2F</url>
    <content type="text"><![CDATA[转载一篇国外开发者写的技术文章，关于 JavaScript 的引擎、运行时、调用栈。 OverviewAlmost everyone has already heard of the V8 Engine as a concept, and most people know that JavaScript is single-threaded or that it is using a callback queue. In this post, we’ll go through all these concepts in detail and explain how JavaScript actually runs. By knowing these details, you’ll be able to write better, non-blocking apps that are properly leveraging the provided APIs. If you’re relatively new to JavaScript, this blog post will help you understand why JavaScript is so “weird” compared to other languages. And if you’re an experienced JavaScript developer, hopefully, it will give you some fresh insights on how the JavaScript Runtime you’re using every day actually works. The JavaScript EngineA popular example of a JavaScript Engine is Google’s V8 engine. The V8 engine is used inside Chrome and Node.js for example. Here is a very simplified view of what it looks like: The Engine consists of two main components: Memory Heap — this is where the memory allocation happens Call Stack — this is where your stack frames are as your code executes The runtimeThere are APIs in the browser that have been used by almost any JavaScript developer out there (e.g. setTimeout). Those APIs, however, are not provided by the Engine. So, where are they coming from? It turns out that the reality is a bit more complicated. So, we have the Engine but there is actually a lot more. We have those things called Web APIs which are provided by browsers, like the DOM, AJAX, setTimeout and much more. And then, we have the so popular event loop and the callback queue. A runtime environment is the execution environment provided to an application by the operating system. In a runtime environment, the application can send instructions or commands to the processor and access other system resources such as RAM, DISK etc. JS engine, Event queues, Event loop and Web/Dom APIs forms the Runtime Environment. The Call StackJavaScript is a single-threaded programming language, which means it has a single Call Stack. Therefore it can do one thing at a time. The Call Stack is a data structure which records basically where in the program we are. If we step into a function, we put it on the top of the stack. If we return from a function, we pop off the top of the stack. That’s all the stack can do. Let’s see an example. Take a look at the following code: 12345678910function multiply(x, y) &#123; return x * y&#125;function printSquare(x) &#123; var s = multiply(x, x) console.log(s)&#125;printSquare(5) Running code on a single thread can be quite easy since you don’t have to deal with complicated scenarios that are arising in multi-threaded environments — for example, deadlocks. But running on a single thread is quite limiting as well. Since JavaScript has a single Call Stack, what happens when things are slow? Concurrency &amp; the Event LoopWhat happens when you have function calls in the Call Stack that take a huge amount of time in order to be processed? For example, imagine that you want to do some complex image transformation with JavaScript in the browser. You may ask — why is this even a problem? The problem is that while the Call Stack has functions to execute, the browser can’t actually do anything else — it’s getting blocked. This means that the browser can’t render, it can’t run any other code, it’s just stuck. And this creates problems if you want nice fluid UIs in your app. And that’s not the only problem. Once your browser starts processing so many tasks in the Call Stack, it may stop being responsive for quite a long time. And most browsers take action by raising an error, asking you whether you want to terminate the web page. ow, that’s not the best user experience out there, is it? So, how can we execute heavy code without blocking the UI and making the browser unresponsive? Well, the solution is asynchronous callbacks. This will be explained in greater detail in Part 2 of the “How JavaScript actually works” tutorial: “Inside the V8 engine + 5 tips on how to write optimized code”.]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中的 Event Loop]]></title>
    <url>%2Fpassages%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%20Event%20Loop%2F</url>
    <content type="text"><![CDATA[Event loop 是针对运行时而非引擎首先，我们要弄清楚一点，event loop 是针对 JavaScript runtime environment 的，而非 JavaScript engine。对于 NodeJS 这一 runtime environment 来说，它的 JavaScript engine 是 V8，对于 Chrome 这一 runtime environment 来说，它的 JavaScript engine 是 V8 ；对 Firefox 这一 runtime environment 来说，它的 JavaScript engine 是 SpiderMonkey。event loop 是浏览器和 NodeJS 这两个 JavaScript runtime environment 处理异步的机制，它不属于 JavaScript 引擎的运行机制。另外，浏览器和 NodeJS 的 event loop 是不一样的，这篇文章将集中讨论浏览器这一运行时环境。另外要说明的是，浏览器除了包含 JavaScript runtime environment 之外，还负责 HTML 和 CSS 的解析以及最后渲染图形在屏幕上等工作。 JavaScript Engine负责解析和执行 JavaScript 代码。最开始的时候，JavaScript 的 engine 只是一个解释器，后来以 V8 为代表的现代引擎实现了一种叫做 JIT(just-in-time) 的及时编译技术，拥有更好的性能。 引擎由以下两个主要部分组成： Memory Heap 堆内存，负责内存分配。 Call Stack 调用栈，主要用于记录函数调用的位置。 下图是 Chrome 内的 V8 引擎示意图： JavaScript runtime EnvironmentJavaScript runtime environment 的示意图如下（以 Chrome 为例）： JavaScript Engine - JavaScript 引擎。 Web APIs - 由浏览器提供的 APIs，主要包括 DOM、BOM、AJAX、定时器。 Callback Queue - 回调队列。也叫作 task queue 或者 message queue。 event loop 是 JavaScript runtime 实现异步的一种机制，负责协调调度以上三者。它的工作是不停地查看调用栈和回调队列，一旦调用栈为空，就通知回调队列将下一个回调函数发送到调用栈，等引擎执行完回调函数，它再进行下一轮循环。 为什么需要 event loop?Event loop 的存在，是为了协调事件、用户交互、脚本、UI 渲染、网络处理等行为，防止主线程阻塞。注意下面这段话： The event loop, the web APIs and the message queue/task queue are not part of the JavaScript engine, it’s a part of browser’s JavaScript runtime environment or Nodejs JavaScript runtime environment (in case of Nodejs). In Nodejs, the web APIs are replaced by the C/C++ APIs.more ECMAScript 规范主要是写给 JavaScript 这门语言的引擎实现者看的，而引擎的主要工作是解析并执行脚本。所以 event loop 在实现上的标准没有写在 ECMAScript 规范，而是写在 HTML 规范 中，是 Web application APIs 的组成部分，供各大浏览器厂商参考。总而言之，event loop 是 JavaScript runtime environment 对于异步的实现，而非 JavaScript engine。 下面这些都是不属于 JavaScript 语言特性的 Web APIs： setTimeout, setInterval, setImmediate 等定时器，按朴灵的说法，其本质仍然是事件。定时器并不是特例。到达时间点后，会形成一个事件（timeout 事件）。不同的是，一般事件是靠底层系统或者线程池之类的产生事件，但定时器事件是靠事件循环不停检查系统时间来判定是否到达时间点来产生事件。 DOM 网页文档对象模型，主要给 JavaScript 的编程接口。 BOM 浏览器对象模型，主要是一些浏览器的 API。 XMLHttpRequest。 上面提到的这些 APIs，与 DOM 相关的挂载在 document 对象上，与 BOM 相关的挂载在 window 对象上，而 document 对象也被挂载在 window 对象上。另外，属于语言特性的全局属性（包括全局值属性、全局函数属性、全局对象属性）也挂载在 window 对象上，请看下面的代码： 123456789// 以下比较都为 truewindow.Infinity === Infinity // 全局值属性window.parseInt === parseInt // 全局函数属性window.Array === Array // 全局对象属性window.setTimeout === setTimeoutwindow.Promise === window.Promisewindow.document === documentwindow.XMLHttpRequest === XMLHttpRequestdocument.location === window.location Browsing Context即浏览器执行上下文，是一个向用户呈现 Document 对象的环境。通常来说，浏览器的每一个标签页包含一个 browsing context，每一个 &lt;iframe&gt; 标签也包含一个 browsing context。每个 browsing context 具有如下属性： 一个相对应的 WindowProxy 对象。可以理解为一个封装了浏览器全局对象 window 的对象，包含了在浏览器环境执行 JavaScript 代码所需的初始化信息，比如： Infinity, NaN, undefined 等值属性 eval(), isFinite(), isNaN(), parseFloat(), encodeURI() 等函数属性 Array, Date, Object, Function, Error, Promise 等构造器属性 另外，必然还有 DOM 和 setTimeout 等各种 Web API。 一个 opener browsing context 属性，它的值是 null 或者另一个 browsing context。初始值为 null。 一个 disowned 布尔属性，初始值为 false。 一个 is closing 布尔属性，初始值为 false。 一个 session history 属性，可以认为包含的是该标签页的会话历史信息。 每一个 browsing context 都有一个 event loop 在调度各种任务间的协同工作。 详解 Event Loop按照 HTML 规范，Event Loop 有如下 3 种类型： window event loop worker event loop worklet event loop 这里我们主要关注第一种 event loop，即一个浏览器标签页包含一个 event loop 或者一组同源的标签页共享一个 event loop 的情况。下面提到的 event loop 也均指 window event loop。 浏览器的 event loop 至少包含两个队列，macrotask 队列和 microtask 队列。按照 HTML 规范，Event loop 的实现应该至少使用一个队列用于处理 macrotasks，至少一个队列处理 microtasks。Event loop 的实际实现通常分配几个队列用于处理不同类型的 macrotasks 和 microtasks。这使得可以对不同的任务类型进行优先级排序。例如优先考虑一些性能敏感的任务如用户输入。另一方面，因为实际上存在很多 JavaScript 宿主环境，所以有的 event loop 使用一个队列处理这两种任务也不应该感到奇怪。 MacrotaskMacrotasks 包含生成 DOM 对象、解析 HTML、执行主线程 JavaScript 代码、更改当前 URL 还有其他的一些事件如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，macrotask 代表一些离散的独立的工作。当执行完一个 task 后，浏览器可以继续其他的工作如页面重渲染和垃圾回收。 MicrotaskMicrotasks 则是完成一些更新应用程序状态的较小任务，如处理 promise 的回调和 DOM 的修改，这些任务在浏览器重渲染前执行。Microtask 应该以异步的方式尽快执行，其开销比执行一个新的 macrotask 要小。Microtasks 使得我们可以在 UI 重渲染之前执行某些任务，从而避免了不必要的 UI 渲染，这些渲染可能导致显示的应用程序状态不一致。 对于浏览器这个 JavaScript runtime environment 来说，microtask 主要包括以下两项： promise 的回调函数 MutationObserver 的回调函数，DOM 规范指出 step 5 of queuing a mutation record 会将 MutationObserver 的回调函数放置在 microtask 中。 Event Loop TickEvent loop 的每一轮循环称为 tick。如下图所示（图片来自 secrets of javascript ninja 这本书）： 这张图也不错： 如上图所示，在一次 tick 中，event loop 首先检查 macrotask 队列，如果有一个 macrotask 等待执行，那么执行该任务。当该任务执行完毕后（或者 macrotask 队列为空），event loop 继续执行 microtask 队列。如果 microtask 队列有等待执行的任务，那么 event loop 就一直取出任务执行直到 microtask 队列为空。这里我们注意到处理 microtask 和 macrotask 的不同之处：在一次 tick 中，一次最多处理一个 macrotask （其他的仍然驻留在队列中），然而会一次性处理完所有的 microtask 直至 microtask 队列为空。 紧接着，当执行完所有 microtask 即 microtask 队列为空时，event loop 检查是否需要执行 UI 重渲染，如果需要则重渲染 UI。这样就结束了当次循环，继续从头开始检查 macrotask 队列。 上图还包含了一些细节： 两个任务队列都放置在 event loop 外，这表明将任务添加和任务处理行为分离。在 event loop 内负责执行任务（并从队列里删除），而在 event loop 外添加任务。如果不是这样，那么在 event loop 里执行代码时，发生的任何事件都被忽略，这显然不是我们想要的，因此我们将添加任务的行为和 event loop 分开进行。 两种类型的任务同时只能执行一个，因为 JavaScript 基于单线程执行模型。任务一直执行到完成而不能被其他任务中断，这一特性叫做 run-to-completion。只有浏览器才能停止任务的执行；例如如果某个任务消耗了太多的内存和时间的话，浏览器可以中断其执行。 所有的 microtasks 都应该在下次渲染前执行完，因为其目的就是在渲染前更新应用状态。 浏览器通常每秒尝试渲染页面 60 次，以达到每秒 60 帧（60 fps），这个帧速率通常被认为是平滑运动的理想选择。这意味着浏览器尝试每 16ms 渲染一帧。上图中update rendering操作在 event loop 中进行，这是因为在呈现页面时，页面内容不应该被另一个任务修改。这意味着如果我们想要实现平滑的 UI 效果，单个 event loop 中不能占据太多时间。单个任务和由该任务生成的所有 microtasks 应该在 16 毫秒内完成。 当浏览器完成页面渲染后，event loop 的下一次 tick 中可能发生三种情况： event loop 在另一个 16ms 之前执行的 is rendering needed 的判断处。因为更新 UI 是一个复杂的操作，如果没有明确要求渲染页面，浏览器可能在本次迭代中不执行 UI 渲染。 event loop 在上次渲染后约 16ms 处达到 Is rendering needed 判断处。在这种情况下，浏览器更新 UI，用户会认为应用比较流畅。 执行下次任务（及其所有相关的 microtask）花费时间大大超过 16ms。这样浏览器将无法按照目标的帧速率重新渲染页面，UI 也将不会更新。如果运行任务代码不占用太多时间（超过几百毫秒），这种延迟甚至可能感知不到，尤其是对于没有太多动画的页面。另一方面，如果我们花费太多时间，或者页面中含有动画，用户可能认为网页缓慢和没有响应。在最坏的情况下，如果任务执行超过几秒钟，用户的浏览器会显示无响应脚本消息。 处理事件时应注意其发生的频率和处理所需时间。如在处理鼠标移动事件时应该格外小心。移动鼠标会导致大量的事件排队，因此在该鼠标移动处理程序中执行任何复杂的操作都可能导致应用变得很不流畅。 Task Queue (Callback Queue / Message Queue)根据 HTML 规范，event loop 具有一个或多个 task queue，即任务队列。任务队列是一个有序的任务列表，这些任务是指负责以下工作的算法： 事件 解析 HTML 回调 获取网络资源 对 DOM 操作作出反应 每个任务都被定义为来自特定的任务源。来自同一个任务源的所有任务（例如，由文档的定时器生成的回调、由鼠标在文档上移动而触发的事件、为该文档的解析器排队的任务）必须始终添加到同一任务队列中，但是来自不同任务源的任务可以被放置在不同的任务队列中。 Generic task sources以下任务源被本规范和其他规范中许多几乎不相关的特性使用： DOM 操作任务源此任务源用于对 DOM 操作做出反应的功能，例如在将元素插入文档时以非阻塞方式发生的事件。 用户交互任务源此任务源用于对用户交互做出反应的功能，例如键盘或鼠标输入。响应用户输入而发送的事件(例如点击事件)必须使用在用户交互任务源中排队的任务来触发。 网络任务源此任务源用于响应网络活动而触发的功能。 历史遍历任务源这个任务源是用来对 history.back() 及类似的 API 进行排队。 浏览器的异步处理模型目前在网络上找到的一些中文资料无法完全说服自己，而 HTML 规范主要给出的是详实严谨的算法，所以试着按照自己的理解梳理下：通常情况下，每一个浏览器的标签页都有一个独立的 browsing context。这个 browsing context： 有一个 execution context stack 执行上下文栈 至少有一个而且通常只有一个与之关联的 event loop。 而这里 event loop 有一个 microtask queue 和至少一个 task queue。当一个浏览器标签页加载时，通常是做以下几件事情（按照 HTML 规范是 task 任务）： 解析 HTML 当遇到 &lt;script src=&#39;...&#39;&gt;, &lt;link&gt;, &lt;img&gt; 等标签时发起网络请求。如果有 defer 属性浏览器则会并行发起网络请求，并在 HTML 解析完毕后执行脚本；如果有 async 属性浏览器则会并行发起网络请求，在脚本资源加载完成后执行。 当遇到内嵌的 script 脚本时，执行脚本内的代码，即将脚本内的代码会形成若干执行上下文，被压入执行上下文栈 渲染 UI 这里需要注意的是，script 脚本内执行的诸如 setTimeout 定时器的回调、通过 XMLHttpRequest 发起的异步网络请求、onclick 等事件触发的回调、通过脚本动态操作 DOM 等，这些操作或者说任务，实际上与上面提到的 task 任务是平行的。也就是说，我们写在 script 标签内的 author code，如果里面包含 setTimoutout 等非 JavaScript 语言特性的代码，JavaScript 引擎会调用外部的 Web APIs，将这些任务放置到 task queue 中。根据 HTML 规范，一个浏览器标签页至少有一个 task queue；而遇到 Promise 或者 MutationObserver，则浏览器会将其放置到 miscrotask queue 中。 简而言之，对于浏览器来说，event loop 这种机制，将 JavaScript 引擎的执行上下文栈（也叫 call stack 调用栈）、Web APIs、task queue 这三者进行协调。下面是一个浏览器的 event loop 的示意简图： Event loop 实例推荐使用文章末尾参考链接给出的两个将 event loop 在线可视化工具，非常赞。下面的一组图片清晰的展示了如下代码在浏览器的 JavaScript runtime 中是如何运行的（可点击图片以幻灯片形式查看）： 1234567console.log('Hi')setTimeout(function() &#123; console.log('there')&#125;, 5000)console.log('Designvelopers') 初始状态： 执行 console.log(&quot;Hi&quot;);，在控制台打出 Hi 后，该函数的调用帧（执行上下文）从调用栈中弹出。另外，这里的 main() 函数模拟一个 .js 文件的全局调用帧： 执行 setTimeout(...)，调用 Web APIs 中针对 setTimeout() 的接口，开始比对系统时间与定时器设置的延迟时间。接着 setTimeout(...) 从调用栈中弹出。 执行 console.log(&quot;Designvelopers&quot;);，在控制台打出 Designvelopers 后，该函数的调用帧从调用栈中弹出。与此同时，Web APIs 仍在另一个线程中比对时间，显然这时还没有到达定时器所设置的 5 秒延迟时间。 脚本的同步代码都已经执行完，此时调用栈为空。当到达定时器设置的时间后，Web APIs 将定时器的回调函数放入回调队列中排队。 此时调用栈为空，并且回调队列中只有定时器回调函数这一个任务，直接取出定时器回调在调用栈中执行，形成两个调用帧： 执行完 console.log(&quot;there&quot;); 后，该函数的调用帧从调用栈弹出： 定时器的回调函数只有一行代码，所以紧接着，回调函数的调用帧也从调用栈弹出： 完毕。 性能优化从性能优化的角度出发，压倒一切的指导方针是，以下几种情况必须并行执行，否则可能会导致阻塞 event loop，这包括但不限于： 执行繁重的计算； 显示面向用户的提示； 执行可能需要外部系统参与的操作(即退出流程)。 参考链接和外部资料 菲利普·罗伯茨：到底什么是 Event Loop 呢？ | 欧洲 JSConf 2014youtube 上面关于 event loop 播放量最高的一个视频，对 event loop 讲解非常清晰（因为是 2014 年发布的，所以没有涉及到 miscrotask），更可贵的是作者针对这一机制做了可视化。下面的链接是一个将 event loop 可视化的在线网站。 Event loop 在线可视化工具 Jake Archibald: In The Loop - JSConf.Asia 20182018 年发布的有关浏览器的 event loop 机制的视频，涉及到了 miscrotask。作者是一名来自 Google 的开发者。下一个链接也是他的文章。 tasks-microtasks-queues-and-schedules作者是一名来自 Google 的开发者，这篇文章里包含了可视化 event loop 机制的工具，很赞。 The JavaScript Event Loop - Concurrency in the Language of the Web使用 Google 办公套件的 PPT 描述的 event loop，讲述了 JavaScript 这门单线程语言是如何处理异步的。里面有两张对 event loop 的图解，非常赞。 All you need to know about the JavaScript event loop一组关于 Event Loop 的幻灯片 the-javascript-event-loop-explained/写于 2013 年对 event loop 的解释。 how-browsers-work发布于 2011 年 8 月 5 日的一篇深度好文，作者是一名以色列开发者，用了几年收集整理有关浏览器内部原理的资料，同时阅读了非常多的浏览器源码，最终形成了这篇文章，详细讲述了以 Chrome 为主的浏览器的工作原理，你在网络看到绝大多数有关浏览器原理的文章和图片可能都是取材于这篇文章的。 understanding-asynchronous-javascript-the-event-loop 重新认识 script 标签 - HTML specification HTML specification HTML draft Event Loop - MDN JavaScript 中的事件循环 Event Loop JavaScript 运行机制详解：再谈 Event Loop - 阮一峰 【朴灵评注】JavaScript 运行机制详解：再谈 Event Loop HTML 系列：macrotask 和 microtask - 知乎专栏]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
        <tag>浏览器原理</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 规范阅读笔记之全局对象]]></title>
    <url>%2Fpassages%2FECMAScript%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ECMAScript 规范中全局对象的阅读笔记。 根据 ECMAScript 的规范，全局对象： 在代码控制流进入任何执行上下文之前，它会被创建。 它没有构造器 [[Constructor]] 这个内部方法；所以不能用 new 操作符创建全局对象的实例。 它没有调用 [[Call]] 这个内部方法；所以不能作为函数调用。 它有一个 [[Prototype]] 内部插槽，其值与各种实现有关。 除了本规范定义的属性，可能还有基于宿主环境定义的属性。 值属性 Infinity NaN undefined 函数属性 eval() isFinite() isNaN() parseFloat() parseInt() URI 专用处理函数 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 构造器属性 Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Init8Array Init16Array Init32rray Map Number Object Promise Proxy RangeError ReferenceError RegExp Set SharedArrayBuffer String Symbol SyntaxError TypeError Uinit8Array Uinit8ClampedArray Uinit16Array Uinit32Array URIError WeakMap WeakSet 其他属性 JSON Math Reflect]]></content>
      <tags>
        <tag>ECMAScript specification</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习资源索引]]></title>
    <url>%2Fpassages%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[这篇文章的目的是为了给自己更清晰地罗列出优秀的前端学习资源，以备日后需要时随时参考。 规范最原始、权威的第一手资料，内容非常详细、严谨。 ECMAScript specification HTML draft HTML specification DOM specification CSSOM specification W3C standards The WHATWG specification index. 权威速查手册适合想要了解某个属性或者方法的详细信息时使用。 Mozilla manual 第三方教程 The Modern JavaScript Tutorial ES6 入门教程 - 阮一峰 CSS tricks 其他 Google Web 开发者文档]]></content>
      <tags>
        <tag>学习资源</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闪电计划]]></title>
    <url>%2Fpassages%2F%E9%97%AA%E7%94%B5%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[为了自身的健康，为了买了个表，我决定开启这项闪电计划，目标只有一个：通过科学合理的方式，将体重从目前的 78 Kg 减轻到 73 Kg。 措施措施主要分两个部分：控制饮食和持续运动。 控制饮食 早餐以燕麦搭配牛奶为主 严格控制晚餐的食物摄入量，一碗饭 晚饭后刷牙，之后除了喝水不吃任何东西 除少量水果外，不吃任何零食 不喝除牛奶、酸奶、咖啡之外的任何饮料 持续运动 工间休息 开合跳 蹲下起立 晚上的运动 热身：平板支撑 有氧运动：跳绳 无氧运动：俯卧撑 战利品华为运动手表]]></content>
      <tags>
        <tag>健身</tag>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：异步编程]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为什么需要异步编程？在我们的程序中，类似下面这样的代码，是由计算机的处理器一次性执行完毕的。代码的运行速度也很大程度上取决于计算机处理器的速度。 1234567891011const sumTo = function(n) &#123; let sum = 0 for (let i = 0; i &lt;= n; i++) &#123; sum += i &#125; return sum&#125;sumTo(10000) 但是，还有很多其他程序需要在处理器外面与其他设备交互。比如，有些程序可能需要通过计算机网络进行通信，或者从硬盘读取数据，而这些都比从内存读取代码慢得多了。 当这样的情形发生时，让处理器处于空闲状态是非常浪费资源的，因为可能有不少其他工作需要处理器在这时来处理。某种程度上来说，这取决于你的操作系统，它会切换处理器运行多个不同的程序。但是，当我们在运行单个程序，遇到等待网络请求的情形时，我们没法让处理器去做其他事情。 在同步编程的模型里，事情一件接着一件地执行。当调用一个性能开销很大的函数时，只有当函数内的操作都完成了才会返回。在这个函数运行期间，程序只能原地待命。 异步编程的模型允许多个事情在同一时间发生。当我们开始一项任务（比如从硬盘读取数据），我们的程序可以继续运行。当这个任务完成时，程序会通知我们并返回一个结果。 我们可以用一个小例子来对比同步编程和异步编程：一个程序从网络获取两个资源文件然后组合成需要的结果。 在一个同步的环境里，只有当网络请求全部完成时，请求函数才会返回。执行上面那个例子的最简单方式就是：一个接一个地发出网络请求。这样做的缺点是：第二个网络请求只有在第一个网络请求全部完成时才会开始。那么，完成上述例子的时间将是至少两项网络请求所需时间之和。 12345// 先请求第一个资源文件request(resourceOne)// 当上面的网络请求完成，才会继续执行第二个网络请求request(resourceTwo) 针对这类问题的解决方式，在一个同步的环境里就是增加额外的线程。线程是指另一个运行中的程序，它的执行可能通过操作系统与另外的程序交织在一起。鉴于大多数现代计算机都包含多个核心的处理器，多个线程可能同时由不同的处理器核心来运行。对于上面的小例子来说，增加的第二个线程可以用来发起第二个网络请求，接着让两个线程都等待返回的结构，然后两个线程实现同步，再组合成需要的结果。 两个重量级的 JavaScript 平台，浏览器和 NodeJS 都需要进行一些费时的异步操作，而不是依赖于多线程。鉴于多线程编程是众所周知的难，所以这通常被认为是个好事情。 回调 Callback异步编程的其中一种方式是：当函数执行耗时较长的操作时，增加一个额外的参数，即回调函数。当这个耗时的操作开始，等待它结束并返回一个结果时，回调函数以这个结果为参数被调用。 举个例子，在 NodeJS 和浏览器环境中都已实现的 setTimeout 函数，等待一段时间（以毫秒为单位）后再调用回调函数。 1setTimeout(() =&gt; console.log('Tick'), 500) 回调实例：加载脚本一个典型的用例：动态加载一个脚本，并在脚本加载完成后使用该脚本。在浏览器的 Web API 中，像 Window，XMLHttpRequest，&lt;script&gt;，&lt;img&gt; 等元素都部署了 onload 事件处理接口，当资源加载完成后被触发。这里以加载 &lt;script&gt; 元素的资源为例： 12345678910111213141516171819202122const loadScript = function(src, callback) &#123; const script = document.createElement('script') // 执行这一行代码，浏览器会发起网络请求获取脚本资源 script.src = src // 资源加载成功时执行 script.onload = () =&gt; callback(null, script) // 资源加载失败时执行 script.onerror = () =&gt; callback(new Error(`Script load error for $&#123;src&#125;`)) document.head.appendChild(script)&#125;// 使用loadScript('/my/script.js', (error, script) =&gt; &#123; // “错误优先”风格的回调， 在 NodeJS 生态中被广泛使用 if (error) &#123; // 处理错误 &#125; else &#123; // 脚本加载成功 &#125;&#125;) 回调地狱有的时候，我们需要按照一定的顺序来执行一连串的异步任务。如果使用回调函数的方式来处理，就会形成嵌套的异步任务。假设我们现在要依次获取 3 个脚本资源，那么就会形成下面这样的代码： 12345678910111213141516171819202122232425loadScript('one.js', (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; one() // 继续获取第 2 个脚本 loadScript('two.js', (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; two() // 继续获取第 3 个脚本 loadScript('three.js', (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; three() // 获取到所有脚本资源 // ... &#125; &#125;) &#125; &#125;) &#125;&#125;) 上面的代码即构成了回调金字塔，或者称回调地狱。这样的代码不仅不易阅读，后续维护成本也高。 Promise为了解决回调地狱，Promise 诞生了。一个 Promise 的实例，是一个代表着最终会完成或者失败的异步操作的对象。新建一个 Promise 实例的语法如下： 123const promise = new Promise((resolve, reject) =&gt; &#123; // executor&#125;) 上面这种新建 Promise 实例的方式，通常只会在封装基于回调处理异步操作的陈旧代码时用到（绝大部分时候，我们是 Promise 实例的使用者）。后面会给出详细例子。 executor传递给 new Promise 的参数是一个叫做 executor 的函数，它会在 promise 被创建的时候自动立即执行。executor 函数接受 2 个参数，resolve 函数 和 reject 函数，它们是由引擎预定义的，我们不必创建它们。我们应当在执行成功时调用 resolve 函数，执行失败时调用 reject 函数。 创建的 Promise 实例具备 2 个内部属性： state 初始值为 pending，之后会转变为 fulfilled 或者 rejected。 result 初始值为 undefined，之后会转变为结果或者错误对象 不可逆过程每个 Promise 实例可能的状态有 3 种：初始状态 pending，完成状态 fulfilled 和 rejected。即一个 Promise 实例要么由 pending 变成 fulfilled，要么由 pending 变成 rejected，并且此过程不可逆，一旦到了完成状态就无法改变。如下图所示： resolve 实例1234const promise = new Promise((resolve, reject) =&gt; &#123; // 模拟一项任务，1 秒后完成，成功并返回结果 "done" setTimeout(() =&gt; resolve('done'), 1000)&#125;) reject 实例1234const promise = new Promise((resolve, reject) =&gt; &#123; // 模拟一项任务，1 秒后完成，失败并返回错误对象 setTimeout(() =&gt; reject(new Error('error occurs')), 1000)&#125;) resolve 与 reject 注意事项resolve 函数或者 reject 函数其中任意一个只会被调用一次，后续的调用都将会忽略： 123456const promise = new Promise((resolve, reject) =&gt; &#123; resolve('done') reject(new Error('…')) // 忽略，不会执行 setTimeout(() =&gt; resolve('…')) // 忽略，不会执行&#125;) resolve 函数或者 reject 函数都只接受一个参数，多余的参数将会忽略。 then本质上，Promise 做的事情是，将一项耗费时间的任务（我们传入的 executor 函数）自动立即执行，然后在任务完成后将这项任务的结果保存到内部属性 result。这个结果可能是我们传入 resolve 函数的任意值，也可能是我们传入 reject 函数的错误对象。并且这个结果一旦形成就不会再改变。 我们可以通过 Promise 实例的 then 方法来获取结果。它可能被成功解决，返回一个结果： 12345678const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('done!'), 1000)&#125;)promise.then( result =&gt; alert(result), // shows "done!" after 1 second error =&gt; alert(error) // doesn't run) 也可能失败，返回错误对象： 123456789const promise = new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('Whoops!')), 1000)&#125;)// reject runs the second function in .thenpromise.then( result =&gt; alert(result), // doesn't run error =&gt; alert(error) // shows "Error: Whoops!" after 1 second) 链式调用Promise 的 then 方法支持链式调用。注意下面代码中 then 方法内的返回值。 123456789101112new Promise(resolve =&gt; &#123; resolve(1);&#125;).then(result =&gt; &#123; console.log(result); // 1 return result * 2; // 返回一个基本数据类型的值&#125;).then(result =&gt; &#123; console.log(result); // 2 return new Promise(resolve =&gt; resolve(100)); // 返回一个 Promise 的实例&#125;).then(result =&gt; &#123; console.log(result); // 100 return &#123; a: 1 &#125;; // 返回一个对象&#125;).then(result =&gt; console.log(result); // &#123; a: 1 &#125; thenable事实上，then 方法只要返回一个部署了 then 方法的任意对象，引擎就会将它当做 Promise 的实例来看待。第三方库可以利用这一点来兼容原生的 Promise。 12345678910111213141516class Thenable &#123; constructor(num) &#123; this.num = num &#125; then(resolve, reject) &#123; alert(resolve) // function() &#123; native code &#125; // resolve with this.num*2 after the 1 second setTimeout(() =&gt; resolve(this.num * 2), 1000) // (**) &#125;&#125;new Promise(resolve =&gt; resolve(1)) .then(result =&gt; &#123; return new Thenable(result) // (*) &#125;) .then(alert) // shows 2 after 1000ms catch本质上是基于 then 实现的，只不过专注于错误处理。由于链式调用 then 方法可以传递结果和错误，所以最佳实践通常是这样： 123456789101112new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('done'), 1000)&#125;) .then(result =&gt; &#123; // .... &#125;) .then(result =&gt; &#123; // ... &#125;) .catch(error =&gt; &#123; // 最后统一处理错误 &#125;) finally与 try...catch...finally 类似，主要用于做一些清理扫尾的工作，略。 Promise 实例：加载脚本使用 Promise 改写上面使用回调实现的加载脚本实例： 123456789101112131415161718192021222324const loadScript = function(src) &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement('script') script.src = src script.onload = () =&gt; resolve(script) script.onerror = () =&gt; reject(new Error(`error when load script for $&#123;src&#125;`)) document.head.appendChild(script) &#125;)&#125;// 使用const promise = loadScript( 'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js')promise.then( script =&gt; alert(`$&#123;script.src&#125; is loaded!`), error =&gt; alert(`Error: $&#123;error.message&#125;`))promise.then(script =&gt; alert('One more handler to do something else!')) Promise 串行加载资源链式调用 Promise 实例的 then 方法可以规避上面提到的回调地狱。使用 Promise 改写上面的按照顺序获取脚本资源的例子： 123456789101112131415// 串行获取资源loadScript('one.js') .then(script =&gt; &#123; one() return loadScript('two.js') &#125;) .then(script =&gt; &#123; two() return loadScript('three.js') &#125;) .then(script =&gt; &#123; three() // 获取到了全部脚本 // ... &#125;) 串行执行异步操作可以改写成更聪明简洁的写法： 12345678const asyncFn1 = x =&gt; x + 1const asyncFn2 = x =&gt; x + 10const asyncFn3 = x =&gt; x + 100const asyncs = [asyncFn1, asyncFn2, asyncFn3]asyncs .reduce((p, f) =&gt; p.then(f), Promise.resolve(1)) .then(result3 =&gt; console.log('result3:', result3)) // result3: 112 上面的代码等同于： 1Promise.resolve(1).then(asyncFn1).then(asyncFn2).then(asyncFn3)。 还可以进一步抽象出一个组合函数，这个组合函数以一组函数为参数，按照参数的顺序依次执行，上一个函数的输出结果作为下一个函数的输入参数。这通常被使用在函数式编程中： 12345678const applyAsync = (acc, val) =&gt; acc.then(val)// 尝试从该函数的调用者的角度去思考，更易读懂下面这行代码const composeAsync = (...funcs) =&gt; x =&gt; funcs.reduce(applyAsync, Promise.resolve(x))// 使用const transformData = composeAsync(fn1, fn2, fn3)const result3 = transformData(data) Promise 实例：fetchPromise 通常被用于网络请求。这里我们以 fetch 方法为例，从远程服务器获取用户数据 user.json。fetch 方法的基本用法如下： 1const promise = fetch(url) // 返回一个 Promise 的实例 详细的例子如下： 12345678910fetch('https://javascript.info/article/promise-chaining/user.json') // 下面的 then 方法在服务器响应时执行 .then(response =&gt; &#123; // 当我们接收到服务器发送的全部响应信息，response.text() 返回一个包含全部响应结果的新的 Promise 实例 return response.text() &#125;) .then(text =&gt; &#123; // text 即是服务器发送过来的响应内容 alert(text) // &#123;"name": "iliakan", isAdmin: true&#125; &#125;) response 还有一个 response.json() 方法，它会读取服务器的响应内容并将之解析为 JSON。很多时候使用它来代替 response.text() 会更加方便： 123fetch('https://javascript.info/article/promise-chaining/user.json') .then(response =&gt; response.json()) .then(user =&gt; alert(user.name)) // iliakan 接着让我们进一步扩展上面的例子，比如使用获取的用户数据做点什么。这里我们用获取到的用户名，查询该用户的 GitHub 信息，然后在网页上显示用户的头像： 123456789101112fetch('https://javascript.info/article/promise-chaining/user.json') .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/user/$&#123;user.name&#125;`)) .then(response =&gt; response.json()) // 用户的头像地址在 githubUser.avatar_url .then(githubUser =&gt; &#123; const img = document.createElement('img') img.src = githubUser.avatar_url document.body.append(img) setTimeout(() =&gt; img.remove(), 3000) // (*) &#125;) 注意到上面代码中 (*) 这一行，用户头像显示 3 秒后将被移除。为了让代码更具有扩展性，即可以继续往下链式调用，同时传递数据，我们可以让第 4 个 then 方法返回一个新的 Promise 实例： 1234567891011121314151617181920fetch('https://javascript.info/article/promise-chaining/user.json') .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/users/$&#123;user.name&#125;`)) .then(response =&gt; response.json()) .then( githubUser =&gt; new Promise((resolve, reject) =&gt; &#123; // (*) const img = document.createElement('img') img.src = githubUser.avatar_url document.body.append(img) setTimeout(() =&gt; &#123; // 先移除头像 img.remove() // 接着往下链式传递之前的数据 resolve(githubUser) // (*) &#125;, 3000) &#125;) ) 通常来说，最好让每一个异步操作都返回 Promise 的实例，这样的代码更具扩展性，即使我们现在不需要继续往下链式调用，可能将来会用到。最后，让我们优化上面的代码，将部分代码抽象成可复用的函数： 123456789101112131415161718192021222324252627282930313233const loadJson = function(url) &#123; return fetch(url).then(response =&gt; response.json());&#125;;const loadGithubUser(name) &#123; return fetch(`https://api.github.com/users$&#123;name&#125;`).then(response =&gt; response.json());&#125;;const showAvatar(githubUser) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = document.createElement("img"); img.src = githubUser.avatar_url; img.onload = () =&gt; &#123; // 图片加载完成 3 秒后移除图片，并继续往下链式传递该 GitHub 用户数据 setTimeout(() =&gt; &#123; img.remove(); resolve(githubUser); &#125;, 3000); &#125;; document.body.append(img); &#125;)&#125;;// 使用loadJson("https://javascript.info/article/promise-chaining/user.json") .then(user =&gt; loadGithubUser(user.name)) .then(githubUser =&gt; showAvatar(githubUser)) // 可简写为 .then(showAvatar) .then(githubUser =&gt; new Promise(resolve =&gt; &#123; console.log(`Finished showing $&#123;githubUser.name&#125;`); resolve(githubUser); &#125;)); Promise 错误处理Promise 实例的错误可以沿着 then 方法往下链式传递，所以最佳实践通常是在最后统一处理错误，以上面的例子为例可以这样做： 1234567891011loadJson('https://javascript.info/article/promise-chaining/user.json') .then(user =&gt; loadGithubUser(user.name)) .then(githubUser =&gt; showAvatar(githubUser)) // 可简写为 .then(showAvatar) .then( githubUser =&gt; new Promise(resolve =&gt; &#123; console.log(`Finished showing $&#123;githubUser.name&#125;`) resolve(githubUser) &#125;) ) .catch(error =&gt; console.log(error.message)) 隐式的 try...catchPromise 实例的 executor 函数和 then 函数内都存在一个隐式的 try...catch。即如果出现错误，后续 .catch 会自动捕获所有错误： 123new Promise((resolve, reject) =&gt; &#123; throw new Error('Whoops!')&#125;).catch(alert) // Error: Whoops! 实际上相当于以下代码： 123new Promise((resolve, reject) =&gt; &#123; reject(new Error('Whoops!'))&#125;).catch(alert) // Error: Whoops! 在 then 方法内抛出错误，也是一样，会被传递到最近的 .catch： 1234567new Promise((resolve, reject) =&gt; &#123; resolve('ok')&#125;) .then(result =&gt; &#123; throw new Error('Whoops!') // rejects the promise &#125;) .catch(alert) // Error: Whoops! 不仅是抛出的错误，对于所有错误也是如此： 1234567new Promise((resolve, reject) =&gt; &#123; resolve('ok')&#125;) .then(result =&gt; &#123; blabla() // no such function &#125;) .catch(alert) // ReferenceError: blabla is not defined 实例以上面的 fetch 方法请求用户数据为例，类似下面的错误处理方式，效果依然很不理想： 123456fetch('no-such-user.json') // (*) .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/users/$&#123;user.name&#125;`)) // (**) .then(response =&gt; response.json()) .catch(alert) // SyntaxError: Unexpected token &lt; in JSON at position 0// ... 最后的 .catch 方法捕获的错误非常宽泛，无法直观的看出究竟是哪里出了错误，以及进一步的错误信息。对于上面的代码而言，可能有如下错误： 请求 no-such-user.json数据，服务器返回的响应是一个 404 或者 500 的错误提示页面。 成功拿到用户数据，但是请求 GitHub 用户信息接口的时候，返回的响应是一个 404 或者 500 的错误提示页面。 我们可以增加一个步骤，检查 response.status 代表的 HTTP 状态码是否为 200。如果不是则抛出一个定制的 HttpError 错误： 1234567891011121314151617class HttpError extends Error &#123; constructor(response) &#123; super(`$&#123;response.status&#125; for $&#123;response.url&#125;`) this.name = 'HttpError' this.response = response &#125;&#125;fetch('.../no-such-user.json') .then(response =&gt; &#123; if (response.status === 200) &#123; return response.json() &#125; else &#123; throw new HttpError(response) &#125; &#125;) .catch(err =&gt; console.log(err)) // 404 for .../no-such-user.json 再看一个针对特定错误进行处理的例子： 1234567891011121314151617181920const demoGithubUser = function() &#123; let name = prompt('Enter a name?', 'iliakan') return loadJson(`https://api.github.com/users/$&#123;name&#125;`) .then(user =&gt; &#123; alert(`Full name: $&#123;user.name&#125;.`) return user &#125;) .catch(err =&gt; &#123; if (err instanceof HttpError &amp;&amp; err.response.status == 404) &#123; // (*) alert('No such user, please reenter.') return demoGithubUser() &#125; else &#123; throw err // (*) &#125; &#125;)&#125;demoGithubUser() 上面的代码，注意 (*) 这一行，当没有查询到对应名字的 GitHub 用户时，弹出没有此用户的信息并让用户重新输入有效的 GitHub 用户名。而对于其他错误，重新抛出。 unhandled rejections对于 Promise 内未处理的错误，比如 catch 重新抛出的错误，或者根本没有 catch 方法，大多数引擎都会追踪到这些未处理错误，并创建一个全局的错误。对于浏览器环境而言，我们可以通过监听全局事件 unhandledrejection 来访问错误并作出处理。NodeJS 环境也有类似的机制离开处理未处理的 Promise 错误。 12345678window.addEventListener('unhandledrejection', event =&gt; &#123; alert(event.promise) // [object Promise] - the promise that generated the error alert(event.reason) // Error: Whoops! - the unhandled error object&#125;)new Promise(resolve =&gt; &#123; throw new Error('whoops')&#125;) Promise 静态方法Promise 一共有以下 4 个静态方法： Promise.resolve Promise.reject Promise.all Promise.race Promise.resolve主要使用场景：将一个值封装为 Promise 的实例。举例，下面的代码实现的功能是：假如某个 url 的资源之前已经获取过，可以通过 then 方法直接返回资源。 12345678910111213141516171819const loadCached = function (url) &#123; const cache = loadCached.cache || (loadCached.cache = new Map()); if (cache.has(url)) &#123; // 封装缓存结果，保证返回的是 Promise 实例 return Promise.resolve(cache.get(url)); &#125; return fetch(url) .then(response =&gt; response.text()) .then(result =&gt; &#123; cache.set(url, result); return result; &#125;);&#125;;// 使用loadCached("https://example.com/user.json") .then(result =&gt; /* do something with result */) Promise.reject用于创建包含错误对象的 Promise 实例，很少用到。 Promise.all并发执行异步操作，会等待所有异步任务完成，返回的结果是由各项异步任务返回结果组成的数组；如果其中任意一个异步任务出错，直接返回错误作为最终结果，其他异步任务的结果将被忽略。基本用法： 123Promise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) =&gt; &#123; /* use result1, result2 and result3 */&#125;) 考虑如下代码： 123456Promise.all([ new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)), // 3 4 // 被自动封装为 Promise.resolve(4)]).then(alert) // 3 秒后，返回的结果是 [1, 2, 3, 4] then 方法返回的结果是一个数组，数组成员为传入 Promise.all 的 Promise 实例 resolve 的结果，顺序也与 Promise.all 的参数顺序一致，而与异步操作的时间无关。 一个常用的技巧是，将一组任务的数据映射为一个成员为 Promise 实例的数组，然后使用 Promise.all 来并发执行异步任务： 123456789101112131415let urls = [ 'https://api.github.com/users/iliakan', 'https://api.github.com/users/remy', 'https://api.github.com/users/jeresig']// 映射为 Promise 实例const requests = urls.map(url =&gt; fetch(url))// 等待所有异步操作完成// 如果其中有一个异步操作失败，将立即返回对应的错误对象Promise.all(requests).then(responses =&gt; &#123; responses.forEach(response =&gt; alert(`$&#123;response.url&#125;:$&#123;response.status&#125;`)) return responses&#125;) 实现容错的并发异步任务Promise.all 方法本身不具备容错性，即一旦有一个异步任务错误便立即返回错误信息。但是，有时候我们希望的结果是这样的：返回一个数组，包含处理成功的异步任务结果和处理失败的异步任务的错误信息。为了实现这一点，需要使用 catch 捕获错误，让错误不被抛出，同时让错误继续往下传递： 12345678910111213const urls = [ 'https://api.github.com/users/iliakan', 'https://api.github.com/users/remy', 'http://no-such-url']Promise.all(urls.map(url =&gt; fetch(url).catch(error =&gt; error))).then( responses =&gt; &#123; // 返回结果的数组包含以下 3 项 // [object Response], [object Response], TypeError: Failed to fetch responses.forEach(response =&gt; alert(response)) &#125;) Promise.race与 Promise.all 类似，不同点在于，Promise.race 不会等待所有异步任务完成，而是只要其中一个完成或者出错，就立即返回处理结果或者错误对象，忽略掉后续的结果或者错误。这点与它的名字 race （赛跑）相契合。 1234567Promise.race([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('Whoops!')), 2000) ), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))]).then(alert) // 1 Promisify一些第三方库的遗留代码仍然使用基于回调的方式处理异步，而 Promise 更加方便好用，所以需要一种方式，将接受回调函数作为参数的函数转化为返回值为 Promise 实例的函数。一个典型的例子是 setTimeout() 函数： 1setTimeout(() =&gt; alert('At least 3 seconds passed'), 3000) 在之前的一篇有关错误处理的博文中讲到，try...catch 结构无法捕获 setTimeout() 函数内的错误，而这一点正是基于回调的 setTimeout() 函数备受指责的原因。 12345678try &#123; setTimeout(() =&gt; &#123; throw new Error('error in setTimeout') // 脚本在这行直接挂掉了 &#125;, 0)&#125; catch (error) &#123; // 无法捕获错误，因为抛出错误时已经离开了 try...catch 结构体 alert('this line will not be printed')&#125; 让我们使用 Promise 封装它： 12345const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))// 使用wait(3000) .then(() =&gt; alert('At least 3 seconds passed')) .catch(failureCallback) 一个更加具体的加载脚本的例子： 12345678910111213141516171819202122232425262728293031// 使用 Promise 封装基于回调处理异步的代码// 回调const loadScript = function(src, callback) &#123; const script = document.createElement('script') script.src = src script.onload = () =&gt; callback(null, script) script.onerror = () =&gt; callback(new Error(`Load script error for $&#123;src&#125;`)) document.head.append(script)&#125;// 使用loadScript('path/script.js', (error, result) =&gt; &#123; if (error) alert(error) else alert(result)&#125;)// promisifyconst loadScriptPromise = function(src) &#123; return new Promise((resolve, reject) =&gt; &#123; loadScript(src, (error, result) =&gt; &#123; if (error) reject(error) else resolve(result) &#125;) &#125;)&#125;// 使用loadScriptPromise('path/script.js').then(res =&gt; alert(res)) 鉴于这是一个常见的需求，可以将其抽象成一个单独的函数 promisify： 123456789101112131415161718192021222324const promisify = function(f) &#123; const wrapper = function(...args) &#123; return new Promise((resolve, reject) =&gt; &#123; // 定制 f 的回调函数 const callback = function(error, result) &#123; if (error) &#123; reject(error) &#125; else &#123; resolve(result) &#125; &#125; // 将定制的回调函数添加到 f 参数的末尾 args.push(callback) f.apply(this, args) &#125;) &#125; return wrapper&#125;// 使用const loadScriptPromise = promisify(loadScript)loadScriptPromise('https://api.github.com/users/cddbysj') .then(res =&gt; alert(res)) .catch(err =&gt; alert(err)) 上面的代码存在一个不足，只能接受形式为 (err, result) =&gt; {...} 的回调函数，即回调只能接受两个参数，一个代表错误，另一个代表结果。如果遇到类似(err, result1, result2, ...) =&gt; {...} 这样的回调函数则无法正常运行。针对这一问题的改进如下： 12345678910111213141516171819202122232425262728293031323334// 回调const loadScript = function(src, callback) &#123; const script = document.createElement('script') script.src = src script.onload = () =&gt; callback(null, script, 'test1', 'test2') script.onerror = () =&gt; callback(new Error(`Load script error for $&#123;src&#125;`)) document.head.append(script)&#125;// promisifyconst promisify = function(f) &#123; const wrapper = function(...args) &#123; return new Promise((resolve, reject) =&gt; &#123; const callback = function(error, ...result) &#123; if (error) &#123; reject(error) &#125; else &#123; resolve(result.length === 1 ? result[0] : result) // (*) &#125; &#125; args.push(callback) f.apply(this, args) &#125;) &#125; return wrapper&#125;// 使用const loadScriptPromise = promisify(loadScript)loadScriptPromise('https://api.github.com/users/cddbysj') .then(res =&gt; alert(res)) // [script, "test1", "test2"] .catch(err =&gt; alert(err)) 参考链接及外部资料JavaScript.info - promise-basics Using promise - MDN Promise - MDN]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：错误处理]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[通常，对于 JavaScript 脚本而言，如果运行脚本时出现错误会挂掉，即引擎会在错误代码处停下来，不会继续执行后续代码，而是将错误信息打印到控制台。比如：1234let a = 1;console.log(b); (*)console.log(a);// Uncaught ReferenceError: b is not defined 上面的代码中，执行到 (*) 这一行便会停下来，将错误信息打印到控制台。 try…catch 结构但是，有一种语法结构 try...catch 允许我们捕获错误并作出相应的处理，这样脚本在出现错误时不会挂掉，而是执行我们设定的错误处理代码。我们来看两个例子：123456789101112131415try &#123; alert('Start of try runs'); // (1) &lt;-- // ...no errors here alert('End of try runs'); // (2) &lt;--&#125; catch(err) &#123; alert('Catch is ignored, because there are no errors'); // (3)&#125;alert("...Then the execution continues"); 上面的代码中，因为 try 语句块没有错误，所以 catch 语句块内的代码会被忽略，不会执行。 123456789101112131415try &#123; alert('Start of try runs'); // (1) &lt;-- lalala; // error, variable is not defined! alert('End of try (never reached)'); // (2)&#125; catch(err) &#123; alert(`Error has occured!`); // (3) &lt;--&#125;alert("...Then the execution continues"); 上面的代码中，由于 try 语句块内存在错误：变量未定义，所以 try 语句块内这一行之后的代码都不会执行，直接跳转到 catch 语句块内执行错误处理代码。 try…catch 只能捕获运行时错误所谓运行时错误 runtime-error，是指有效的 JavaScript 代码，即 JavaScript 引擎可以正确解析的代码。对于一个 JavaScript 脚本，引擎首先会解析它，接着执行它。如果出现解析时错误，通常是语法错误，引擎会直接报错，因为引擎这时无法读懂代码，自然地，try..catch 结构不可能捕获到解析错误。比如：12345try &#123; &#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#125; catch(e) &#123; alert("The engine can't understand this code, it's invalid");&#125; try…catch 是同步执行的在诸如定时器 setTimeout 等异步代码中发生错误，try...catch 结构无法捕获错误。比如：1234567try &#123; setTimeout(function() &#123; noSuchVariable; // script will die here &#125;, 1000);&#125; catch (e) &#123; alert( "won't work" );&#125; 原因在于，setTimeout 的回调函数在执行时，引擎实际上已经离开了 try...catch 结构体。要捕获类似这样的错误，需要这样做：1234567setTimeout(function() &#123; try &#123; noSuchVariable; // try..catch handles the error! &#125; catch (e) &#123; alert( "error is caught here!"); &#125;&#125;) 错误对象当发生运行时错误时，引擎会创建一个错误对象，里面包含了有关这次错误的信息。该错误对象会被当作参数传递给 catch 语句：1234567891011try &#123; lalala; // error, variable is not defined!&#125; catch(err) &#123; // &lt;-- the "error object", could use another word instead of err alert(err.name); // ReferenceError alert(err.message); // lalala is not defined alert(err.stack); // ReferenceError: lalala is not defined at ... // Can also show an error as a whole // The error is converted to string as "name: message" alert(err); // ReferenceError: lalala is not defined&#125; 错误对象主要有 2 个属性： name 错误的名称，对于未定义的变量而言，是引用错误 ReferenceError。 message 有关错误详情的文本信息。 还有一个非标准但是被广泛采用的属性： stack 主要用作调试，包含了导致错误的调用栈跟踪。 实例让我们来看一个实际的例子：解析从服务器获取的 JSON 数据。正常的情况下，应该是这样的：1234567const json = '&#123;"name":"John", "age": 30&#125;'; // data from the serverconst user = JSON.parse(json); // convert the text representation to JS object// now user is an object with properties from the stringalert( user.name ); // Johnalert( user.age ); // 30 JSON 格式错误但是实际情况往往复杂多变，首先考虑一种情况，假如 JSON 数据不合法（格式错误，无法被正确解析），那么脚本运行到解析 JSON 数据时将会直接挂掉。这显然不是我们想要的结果，这也会让用户非常困惑。我们可以使用 try...catch 来进行错误处理：12345678910111213const json = "&#123; bad json &#125;";try &#123; let user = JSON.parse(json); // &lt;-- when an error occurs... alert( user.name ); // doesn't work&#125; catch (e) &#123; // ...the execution jumps here alert( "Our apologies, the data has errors, we'll try to request it one more time." ); alert( e.name ); alert( e.message );&#125; 抛出错误再考虑另一种情况：JSON 格式是对的，但是不包含我们需要的字段，在这里是 name 字段：12345678910const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; let user = JSON.parse(json); // &lt;-- no errors alert( user.name ); // no name!&#125; catch (e) &#123; alert( "doesn't execute" );&#125; 对于这种情况，我们可以使用 throw 操作符来抛出错误：123456789101112131415const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); // (*) &#125; alert( user.name );&#125; catch(e) &#123; alert( "JSON Error: " + e.message ); // JSON Error: Incomplete data: no name&#125; 重新抛出错误接着考虑更复杂的情况，除了 JSON 数据字段缺失的错误，假如 try 语句块内还有其他的错误，比如未定义的变量，如何在 catch 语句块内处理这种情况？接着上面的例子：1234567891011121314151617const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors lalala; // (*) undefined variable if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); // &#125; alert( user.name );&#125; catch(e) &#123; alert( "JSON Error: " + e.message ); // JSON Error: lalala is not defined&#125; 上面代码标有 (*) 的一行有一个未定义的变量，于是引擎会创建错误对象并跳转到 catch 语句块。需要明确的一点是，catch 会从 try 中捕获所有的错误。对于类似上面的例子，解决思路很简单：catch 语句块应该只处理它知道的错误并重新抛出其他错误。 这一过程大致如下： catch 会捕获 try 内的所有错误。 在 catch 语句块内，我们通过错误对象的 name 属性来分析错误。 只处理我们知道如何处理的错误，重新抛出其他错误。 针对上面的提到的同时存在未定义变量错误和 JSON 语法错误，我们只需要处理 JSON 语法错误，而将其他错误重新抛出：123456789101112131415161718192021const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors lalala; // (*) undefined variable if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); &#125; alert( user.name );&#125; catch(e) &#123; if (e.name === 'SyntaxError) &#123; alert( "JSON Error: " + e.message ); &#125; else &#123; throw e; // rethrow (*) &#125;&#125; 上面代码中，try...catch 只处理了它关心的 JSON 语法错误，而将其他错误重新抛出。那么其他错误最终到哪里去了呢？ 两种可能：如果外部代码没有使用 try...catch 来捕获错误，那么会导致脚本挂掉；如果外部代码使用了 try...catch 结构，则会捕获重新抛出的错误。如下面代码所示：12345678910111213141516171819function readData() &#123; const json = '&#123; "age": 30 &#125;'; try &#123; // ... blabla(); // error! &#125; catch (e) &#123; // ... if (e.name != 'SyntaxError') &#123; throw e; // rethrow (don't know how to deal with it) &#125; &#125;&#125;try &#123; readData();&#125; catch (e) &#123; alert( "External catch got: " + e ); // caught it!&#125; 上面的代码中，内层的 try...catch 只处理了语法错误，其他的错误都由外层的 try...catch 来处理。 注意事项 在 try...catch...finally 语句块内声明的变量只在该语句块没可见。 123456789101112131415161718192021222324let num = +prompt("Enter a positive integer number?", 35)let diff, result; // 注意这里变量都声明在 try...catch...finally 语句块之外function fib(n) &#123; if (n &lt; 0 || Math.trunc(n) != n) &#123; throw new Error("Must not be negative, and also an integer."); &#125; return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);&#125;let start = Date.now();try &#123; result = fib(num);&#125; catch (e) &#123; result = 0;&#125; finally &#123; diff = Date.now() - start;&#125;alert(result || "error occured");alert( `execution took $&#123;diff&#125;ms` ); finally 语句块总是会执行，即使 try 语句块内有显式的返回： 12345678910111213function func() &#123; try &#123; return 1; &#125; catch (e) &#123; /* ... */ &#125; finally &#123; alert( "finally" ); &#125;&#125;alert( func() ); // first works alert from finally, and then this one 全局捕获错误有一个不属于语言规范，但是各大浏览器都实现了的全局捕获错误的回调函数 window.onerror。它的主要作用不是为了让脚本可以继续执行，而是通常用作错误报告，即将错误信息发送给开发者。在页面中插入下面的脚本，即可实现错误报告的效果：123456789101112&lt;script&gt; window.onerror = function(message, url, line, col, error) &#123; const err = `$&#123;message&#125;\n At $&#123;line&#125;:$&#123;col&#125; of $&#123;url&#125;`; sendToDevelop(err); // 发送给开发者 &#125;; function readData() &#123; badFunc(); // 此处发生错误 &#125; readData();&lt;/script&gt; 定制和扩展错误在实际开发中，语言内置的几个标准错误类，比如 Error，SyntaxError，TypeError，ReferenceError 等，可能不足以满足我们在特定情况下的需要。比如在进行网络请求操作时我们可能需要 HttpError，在进行数据库操作时我们可能需要 DbError，对于搜索操作可能需要 NotFoundError 等。我们可以通过继承通用错误类 Error 来定制我们需要的错误类，这被认为是最佳实践。有以下优点： 可以继承 message，name，stack 这些基础的错误属性。 可以使用 inctanceof 运算符来判断错误类型。 便于之后的多级错误类型继承的形成。 当然，对于不同的错误类，我们可以添加额外所需的属性，比如对于 HttpError，可以添加 statusCode 属性，它的值可能是 404，500 等。 扩展错误实例让我们来看一个读取 JSON 格式的用户数据的例子。假定我们期望的用户数据是这样的：1const json = `&#123; "name": "John", "age": 30 &#125;`; 先做一点铺垫，内置的通用错误类 Error 的伪代码可能是这样的：12345678// The "pseudocode" for the built-in Error class defined by JavaScript itselfclass Error &#123; constructor(message) &#123; this.message = message; this.name = "Error"; // (different names for different built-in error classes) this.stack = &lt;nested calls&gt;; // non-standard, but most environments support it &#125;&#125; 为了将 JSON 数据字段缺失的错误单独处理，我们定制一个单独的 ValidationError 错误类：12345678910111213141516171819class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "ValidationError" &#125;&#125;// 模拟一个错误const test = function() &#123; throw new ValidationError("Whoops!");&#125;try &#123; test();&#125; catch(err) &#123; alert(err.message); // Whoops! alert(err.name); // ValidationError alert(err.stack); // a list of nested calls with line numbers for each&#125; 接着我们将它用在读取用户数据的例子上：123456789101112131415161718192021222324252627282930313233343536class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "Validation"; &#125;&#125;// Usageconst readUser = function (json) &#123; const user = JSON.parse(json); if (!user.name) &#123; throw new ValidationError("no field: name"); &#125; if (!user.age) &#123; throw new ValidationError("no field: age"); &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;// Working example with try..catchtry &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof ValidationError) &#123; console.log(`Invalid data: $&#123;error.message&#125;`); // Invalid data: No field: name &#125; else if (error instanceof SyntaxError) &#123; console.log(`JSON syntax error: $&#123;error.message&#125;`); &#125; else &#123; throw error; // unknown error, rethrow it &#125;&#125; 注意上面代码使用 instanceof 运算符来判断错误类型的做法。 进一步扩展错误类上面的 ValidationError 错误类还是过于通用，我们在它的基础上继续扩展一个更具体的属性缺失错误类 PropertyRequireError:1234567891011121314151617181920212223242526272829303132333435363738394041424344class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "Validation"; &#125;&#125;class PropertyRequireError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; this.name = "PropertyRequireError"; &#125;&#125;// Usageconst readUser = function (json) &#123; const user = JSON.parse(json); if (!user.name) &#123; throw new PropertyRequireError("name"); &#125; if (!user.age) &#123; throw new PropertyRequireError("age"); &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;// Working example with try..catchtry &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof PropertyRequireError) &#123; console.log(`Invalid data: $&#123;error.message&#125;`); &#125; else if (error instanceof SyntaxError) &#123; console.log(`JSON syntax error: $&#123;error.message&#125;`); &#125; else &#123; throw error; // unknown error, rethrow it &#125;&#125; 现在，我们在抛出属性错误的时候只需要传入缺失的属性就可以了。还有一个地方可以优化，每次扩展一个类都需要设置 this.name = ...，可以增加一个继承的层级来专门完成这个任务：123456789101112131415161718class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = this.constructor.name; &#125;&#125;class ValidationError extends MyError &#123; &#125;class PropertyRequiredError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; &#125;&#125;// name is correctalert( new PropertyRequiredError("field").name ); // PropertyRequiredError 包装异常让我们思考一下，readUser 这个函数的任务是从 JSON 数据读取到我们所需要的用户数据字段。让我们站在 readUser 函数的调用者的角度来思考，我们希望得到的错误信息应该简单清晰，是一个类似 ReadError 这样的错误类。至于错误的具体细节应该封装在这个错误类内部，可能是 JSON 格式错误，可能是属性缺失错误，以及将来可能出现的其他错误。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = this.constructor.name; &#125;&#125;class ReadError extends MyError &#123; constructor(message, cause) &#123; super(message); this.cause = cause; &#125;&#125;class ValidationError extends MyError &#123; constructor(message) &#123; super(message); &#125;&#125;class PropertyRequireError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; &#125;&#125;// 验证用户数据是否缺失属性const validateUser = function (user) &#123; if (!user.name) &#123; throw new PropertyRequireError("name"); &#125; if (!user.age) &#123; throw new PropertyRequireError("age"); &#125;&#125;const readUser = function (json) &#123; let user; try &#123; user = JSON.parse(json); &#125; catch (error) &#123; if (error instanceof SyntaxError) &#123; throw new ReadError("SyntaxError", error); &#125; else &#123; throw error; &#125; &#125; try &#123; validateUser(user); &#125; catch (error) &#123; if (error instanceof ValidationError) &#123; throw new ReadError("ValidationError", error); &#125; else &#123; throw error; &#125; &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;try &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof ReadError) &#123; // readUser 调用者关心的错误 console.log(error); // 原始错误信息 console.log(error.cause); &#125; else &#123; throw error; &#125;&#125; 上面代码所使用的方式叫做包装异常 Wrapping Exceptions，是一种在面向对象编程中广泛使用的技巧。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：面向对象之混入]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%B7%B7%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在 JavaScript 中，基于原型的继承是不支持多继承的。但是，在有些时候我们希望有类似的机制。一个非常的典型的例子是事件。有很多的对象，都应该含有对事件处理的方法。而这些针对事件处理的方法不适合被放在原型链中。在 JavaScript 中，实现混入mixin的方式非常简单：将这些方法放在一个对象中，然后通过 Object.assign 将该对象内的方法添加到类中。 实例：事件混入许多对象的一个重要特性是对事件的处理。下面的代码，通过混入的方式扩展了类的行为。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//事件混入：const eventMixin = &#123; /** * 订阅事件 * @param &#123;String&#125; eventName 订阅的事件名称 * @param &#123;Function&#125; handler 订阅的事件处理的回调函数 */ on(eventName, handler) &#123; if (!this._eventHandlers) &#123; this._eventHandlers = &#123;&#125;; &#125; if (!this._eventHandlers[eventName]) &#123; this._eventHandlers[eventName] = []; &#125; this._eventHandlers[eventName].push(handler); &#125;, /** * 取消订阅事件 * @param &#123;String&#125; eventName 要取消订阅的事件名称 * @param &#123;Function&#125; handler 要取消订阅的事件处理回调函数 */ off(eventName, handler) &#123; const handlers = this._eventHandlers &amp;&amp; this._eventHandlers[eventName]; if (!handlers) return; for (let i = 0; i &lt; handlers.length; i++) &#123; if (handlers[i] === handler) &#123; handlers.splice(i--, 1); &#125; &#125; &#125;, /** * 触发事件 * @param &#123;String&#125; eventName 事件名称 * @param &#123;any&#125; args 事件处理回调函数的参数 */ trigger(eventName, ...args) &#123; if (!this._eventHandlers || !this._eventHandlers[eventName]) &#123; return; &#125; this._eventHandlers[eventName].forEach(handler =&gt; handler.apply(this, args)); &#125;&#125;;class Menu &#123; choose(value) &#123; this.trigger("select", value); &#125;&#125;// 将事件混入 Menu 对象的原型Object.assign(Menu.prototype, eventMixin);const menu = new Menu();// 订阅 select 事件menu.on("select", value =&gt; alert(value));// 触发 select 事件menu.choose("apple");]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记：class语法糖]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aclass%20%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[在前面一篇原型与继承的学习笔记中，最后使用基于原型的范式实现了继承。而 ES6 引入的 class 关键字则提供了更加漂亮的语法，与 Java 等语言有点类似。还是以 Rabbit 继承 Animal 为例，使用 class 关键字的写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Animal &#123; constructor(name, speed) &#123; this.name = name; this.speed = speed; &#125; // 静态方法是从属于 class 本身的，而非其原型。静态属性同理。 // 等同于： // Animal.compare = function(animalA, animalB) &#123; ... &#125; static compare(animalA, animalB) &#123; return animalA.speed - animalB.speed; &#125; // 成员方法是从属于 class 的原型的 // 等同于： // Animal.prototype.run = function(speed) &#123; ... &#125; run(speed) &#123; this.speed += speed; console.log(`$&#123;this.name&#125; run with speed $&#123;this.speed&#125;`); &#125; stop() &#123; this.speed = 0; console.log(`$&#123;this.name&#125; stopped`); &#125;&#125;class Rabbit extends Animal &#123; constructor(name, speed, earLength) &#123; super(name, speed); // 必须使用 super 调用父级构造器，然后才能访问 this this.earLength = earLength; &#125; hide() &#123; console.log(`$&#123;this.name&#125; hide`); &#125; stop() &#123; // 通过 super.method() 可以调用父类的方法 super.stop(); this.hide(); &#125;&#125;console.log(typeof Animal); // functionconsole.log(typeof Rabbit); // function 需要注意的几点： class 只是语法糖，在语言层面并未引入新的基本单元，从 typeof Animal 的结果 function 可以看到，本质上依然是函数。 子类的构造器 constructor 在访问 this 之前必须先调用父类构造器，即调用 super(...)。 为了更多地复用代码，在子类中可以使用 super.method() 调用父类的方法。 声明的成员方法 run，stop， hide 都是定义在其原型上。以 stop 方法为例，等同于： Animal.prototype = function () {...}。 声明的静态方法则是定义在 class 函数本身上，而非其原型上。 extends 关键字实际上做了以下工作： 将 Rabbit.prototype 的原型设为 Animal.prototype，使得 Rabbit 的实例可以继承 Animal 的实例属性 将 Rabbit 的原型设为 Animal，使得 Rabbit 本身可以继承 Animal 的静态属性 class 内声明的方法之间没有逗号 ,。 静态属性与实例属性在 JavaScript 中，结合 class 关键字，用类似 Java 中面向对象的思想来理解静态属性与实例属性。静态属性是挂载在 class 本身上的，而实例属性是挂载在原型 prototype 上的。我们以内置的 Object 和 Date 这两个对象为例来说明，如下图所示： 从上图可以清晰的看到：Object 和 Date 两者本身是不存在继承关系的，它们只是通过彼此的原型实现继承关系，仅此而已。 Object 的静态属性 Object.name Object.length Object.prototype Object.assign Object.getOwnPropertyDescriptor Object.getOwnPropertyDescriptors Object.getOwnPropertyNames Object.getOwnPropertySymbols Object.is Object.preventExtensions Object.seal Object.create Object.defineProperties Object.defineProperty Object.freeze Object.getPrototypeOf Object.setPrototypeOf Object.isExtensible Object.isFrozen Object.isSealed Object.keys Object.entries Object.values Object 的实例属性 constructor __defineGetter__ __defineSetter__ hasOwnProperty __lookupGetter__ __lookupSetter__ isPrototypeOf propertyIsEnumerable toString valueOf __proto__ toLocaleString Date 的静态属性 Date.length Date.name Date.prototype Date.now Date.parse Date.UTC Date 的实例属性 constructor toString toDateString toTimeString toISOString toUTCString toGMTString getDate setDate getDay getFullYear setFullYear getHours setHours getMilliseconds setMilliseconds getMinutes setMinutes getMonth setMonth getSeconds setSeconds getTime setTime getTimezoneOffset getUTCDate setUTCDate getUTCDay getUTCFullYear setUTCFullYear getUTCHours setUTCHours getUTCMilliseconds setUTCMilliseconds getUTCMinutes setUTCMinutes getUTCMonth setUTCMonth getUTCSeconds setUTCSeconds valueOf getYear setYear toJSON toLocaleString toLocaleDateString toLocaleTimeString. Symbol.toPrimitive. instanceof 运算符instanceof 运算符的语法如下： 1obj instanceof Class; 这一运算符的本质其实是判断 Class.prototype 是否在 obj 对象的原型链上。除此之外，对于那些部署了 Symbol.hasInstance 静态方法的类，还要额外考虑。obj instanceof Class 这一算法的工作过程大致如下： 如果某个类部署了 Symbol.hasInstance 静态方法，那么直接使用该方法。比如下面这样： 123456789// assume anything that canEat is an animalclass Animal &#123; static [Symbol.hasInstance](obj) &#123; if (obj.canEat) return true; &#125;&#125;let obj = &#123; canEat: true &#125;;alert(obj instanceof Animal); // true: Animal[Symbol.hasInstance](obj) is called 如果某个类没有部署 Symbol.hasInstance 静态方法（大多数类都没有部署）。那么开始检查这个类的原型链，看 Class.prototype 是否等于原型链上的某个原型，即做如下比较： 1234obj.__proto__ === Class.prototypeobj.__proto__.__proto__ === Class.prototypeobj.__proto__.__proto__.__proto__ === Class.prototype... 还是以 Rabbit 继承 Animal 为例，来看看 instanceof 的工作过程： 1234567class Animal &#123;&#125;class Rabbit extends Animal &#123;&#125;let rabbit = new Rabbit();alert(rabbit instanceof Animal); // true// rabbit.__proto__ === Rabbit.prototype// rabbit.__proto__.__proto__ === Animal.prototype (match!) 上面的代码中，rabbit 实例的原型链是这样的： 1rabbit -&gt; Rabbit.prototpye -&gt; Animal.prototype -&gt; Object.prototype -&gt; null rabbit instanceof Animal 执行的操作是在上面的原型链中查找，看 Animal.prototype 是否出现在原型链中，如果是则返回 true，否则返回 false。 类型检查在 JavaScript 中，主要有 3 种方法可以用来做类型检查： typeof 主要用于检查基本数据类型，返回一个说明了所属类型的字符串。比如： 1alert(typeof 1); // number {}.toString 用于检查基本数据类型，内置对象，以及部署了 Symbol.toStringTag 属性的对象。可以看做是增强版的 typeof 。示例： 1234567891011121314151617181920// 对于基本数据类型let s = Object.prototype.toString;alert(s.call(123)); // [object Number]alert(s.call(null)); // [object Null]alert(s.call(alert)); // [object Function]// 对于部署了 Symbol.toStringTag 的对象let user = &#123; [Symbol.toStringTag]: "User"&#125;;alert(&#123;&#125;.toString.call(user)); // [object User]// 对于特定环境的内置对象和类alert(window[Symbol.toStringTag]); // windowalert(XMLHttpRequest.prototype[Symbol.toStringTag]); // XMLHttpRequestalert(&#123;&#125;.toString.call(window)); // [object Window]alert(&#123;&#125;.toString.call(new XMLHttpRequest())); // [object XMLHttpRequest] instanceof 用于对检查对象数据类型，尤其用于检查对象继承关系。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家具木材指南之实木篇]]></title>
    <url>%2Fpassages%2F%E5%AE%B6%E5%85%B7%E6%9C%A8%E6%9D%90%E6%8C%87%E5%8D%97%E4%B9%8B%E5%AE%9E%E6%9C%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[初识木材树木是地球上既宝贵又神奇的资源。通过一系列精心设计，去繁就简的工序，重获新生的木材成为了我们家中的家具。他们陪伴我们和家人一起生活，一同成长，随着时间推移，记录着生活留下的痕迹，成为世上专属你的家具。 钟情实木家具的人，多是喜欢实木的原始素材质感，浑然天成的纹理，温润窝心的感觉，或是欣赏榫卯结构的精湛工艺，在选购前，对木材的特性先有个基本认知，可以帮助我们买到心头好。 同时也要了解，木材是多孔性的有机体，特别是只用木蜡油作表面处理的，存在一定的呼吸性，会随环境的湿度和温度而变化，冷缩热胀以及实木家具不同部位的收缩及膨胀程度不同，会令家具产生开裂及变形。只要是天然的木材均是如此，但请放心，轻微的裂纹及局部变形不会影响家具整体的强度和结构。 另外，天然原木有一些不可避免的的天然瑕疵，包括独特的木纹，木色的变化，树眼，结疤，深色矿物线，斑纹，细小洞孔等等。由多块实木板组成的家具，木板与木板之间必然存在颜色及木纹的差异。 扫盲小贴士实木木材一块原木，或多块实木拼接，非压制而成。 实木家具全实木，或绝大部份是实木，小量其他物料（胶水、五金件）作辅助。 实木家具较贴皮和人造板好这样说其实不公允。不过实木的确贵很多，其大自然气息和质感亦难以模彷。 木蜡油涂层与传统漆油涂层木蜡油: 天然健康环保，保留木材原有质感，可自行作局部修复，局限是防水力较差，易有水印。传统漆油: 把木材完全密封，表面较滑，保护性及防水力较高，缺点是失去原木质感，对于刮花等用户难以自行修复。 原木色与染色原色: 纯天然，随机的，如碰撞擦花，痕迹不明显。染色: 选择多，可做到颜色平均，可遮盖木材天然瑕疵。刮花痕迹很明显。 实木家具实木或原木家具有两类： 整块木板都是由一块原木制成。 由多块原木拼接而成，市面上绝大多数实木家具都是这样制成的。 为何要拼接？一整大块的木材供应有限。面积越大，其天然瑕疵一般会越多。由多块木板组成的大板，如果工艺良好，开裂的概率会较一整大块原木为低。 上图展示木材最天然的状态，没有染色，没有涂上任何涂层，由左至右分别是：黑胡桃木，红橡木，樱桃木，榉木及白蜡木。加上涂层后一般会变深色。 非实木类泛指人造板，胶合板（夹板），密度板，纤维板，颗粒板，刨花板等。 在人造板表面贴上彷木皮或真木皮，坊间称为贴皮或饰面（Veneer）。 在相对较便宜的实木上，贴上较贵重的真木皮。例如在桦木上贴上胡桃木皮，有些说法认为这还是实木，站于生产商角度是其道理，但是对于消费者来说，这是相当易于混淆的。当商家声称一张餐桌的木材是胡桃木，又说是实木，那消费者会很自然地理解为整张餐桌是胡桃木实木制，但原来只是胡桃木皮。所以为了减少误会，不把这些归纳为实木类。 表面涂层用于木器表面的涂料 (又称涂层，涂装，涂饰) 有很多，可粗略地分为油漆 (Varnish / Lacquer)及木蜡油 (Wax Oil)。 油漆即以石化物料为基材的化学涂料，种类及名称众多，如 PU 漆，PE 漆，NC 漆等。上漆后的家具表面会有一层透明漆膜，完全将木材密封。漆膜的厚度视乎油漆种类而定，如 NC 硝基漆的漆膜相对较薄。但有些很夸张的，就像有一层厚厚的透明硬胶把木材覆盖。 使用油漆的好处是保护性强，耐磨，防水性高，日常打理较易。缺点是再触摸不到木材肌理，降低原有触感。油漆会随着时间老化，如龟裂或起泡，修补时要把整个区域的涂料完全磨掉，很难作局部修补。 木蜡油即以天然植物制成的环保涂料，主要成份包括亚痳籽油，向日葵油，棕榈蜡等等。其中油的成份会渗透木材内部起滋润作用。蜡的成份与木材的纤维牢固结合，可轻度阻止液体渗入，略为増加表面硬度和光滑度。涂在木器上，不会形成漆膜，用者仍然可以触摸到木材本身，表面散发柔和自然光泽，更能展现木材的天然美感。对使用者非常健康，亦易于修复轻微刮花。其限制是，只适用于实木上，无遮丑功能，不会大幅度地增加木材的耐磨性。因木材可自由呼吸，外界环境温度可直接影响含水率，木材出现变形及开裂的机会会略高于传统油漆。随着人们对环保愈来愈重视，更崇尚大自然，木蜡油的使用在近几年愈来愈流行。比如德国品牌 OSMO 及比利时品牌 BIOHOUSE。 常见木材最常见用于制作实木家具的木材，包括松木，桦木及橡胶木，其成本相对较低。 品质较佳价格较高的，包括胡桃木，橡木，樱桃木，榉木，柚木，白蜡木等等。 这些木材性质各有不同，例如胡桃木很名贵 (供参考，北美胡桃木价格可以比松木贵 6 - 9 倍)，榉木及樱桃木较细滑等，不过在一般家用层面来说，分别是有但不至于很大，反而用户对木材的感觉才重要。另外，美国和德国是全球众多木材出产大国中，森林管理水平最高的两个国家，林木蓄量持续增长，应予以支持。 榉木清新活泼，色浅柔和，木纹细且长，触感十分光滑。欧洲最重要的出口木材之一，其中以德国的为佳。需要说明的是，目前我们讨论的榉木 橡木坚毅谦厚气息，色泽淡雅，鲜明山形纹，手感亲切自然，能确实感受到木纹的肌理。红橡，木髓线较细。白橡，跟白色是没有关系的，实物色是偏黄的，常用于葡萄酒桶。 胡桃木气质高贵，风度翩翩，色深而优雅，木纹呈抛物线，清晰别致，富有层次感，触感介于榉木与橡木之间，细腻饱满。又名黑胡桃木，最名贵的常用木材之一，不同地区出产的分别很大，北美的公认最好。 樱桃木它独特的微红色，羞涩中流露出一份温暖和喜悦，犹如恋爱中的女士。樱桃木制的家具在外国较流行，美国出产。 白蜡木其鲜明均匀的纹路，予以十分粗犷豪迈的感觉，纵使手感还没有橡木般原始。色淡，浅棕至乳白。坚韧而富弹性。与中国东北及俄罗斯的水曲柳很相似，美国的较贵。 常见木材价格旨在提供一个初步的概念，十分粗略的比较： 相对便宜: 松木，橡胶木，桐木，桦木，楸木，杉木 相对较贵: 榉木，榆木，柚木，水曲柳，白蜡木，红橡木，白橡木，樱桃木 相对昂贵: 胡桃木，花梨木，黑檀木 非实木一定便宜很多？不一定。家具的价格有时和是否用实木没有太直接的关系。比如有些日本或者欧洲大品牌，用人造夹板或贴木皮，卖的价格比其他小品牌的实木家具高好多。 榉木一定比橡木便宜？其实两者的原木材成本相差并不太大，而由于榉木木材的利用率一般较高，所以变相地榉木家具的售价会便宜一点。 实例：橡木餐桌右图中的餐桌是一家大型日本家具公司的橡木餐桌，木蜡油涂层，售价约一万五千元。这家公司所卖的产品一向品质优良，这里借这个大品牌的餐桌做个例子，说明实木家具的几个特质： 树结 树结及纹理等天然特质是树木的一部份，正如图中的橡木餐桌有不少天然树结。 拼板 木匠会挑选优质实木切割拼接，制作成我们常见的实木家具。拼接有其好处，例如依然会受热胀冷缩的影响，但稳定性相对已较高。使用一整块不经切割的大木板是非常少见的。 木色 木材天然颜色犹如人的皮肤，要找到两个肤色一样的很困难，就算是同一个人，脸部与颈部的肤色可能已很不同，木材亦如是。另外，橡木原色多是这样的，偏黄。有时我们看到一些很浅接近白色的木家具，需要仔细判断，有可能是人造板 / 贴木皮 / 染了色的。 木材树种名称在中国，实木家具市场非常混乱。首先从实木的木材名称上来说，非常混乱。这里我根据之前的一篇有关我国木材名称的三大相关标准的博文，以 《中国主要木材流通商品名称》 为准，整理了市场上常见木材的名称及其对应的树种和流通商品名。需要注意的是，下面列出的木材名字是以《中国主要木材流通商品名称》这一国标的名字为准。比如市面上所说的硬枫木，这是该木材的流通商品名，其正式名称为硬槭木。每种木材下面附带了一段知乎用户 逸杯酒 对该木材的概述。 Top2 级，消费级实木家具里面能遇到的最好最贵的材料，从各个方面来说，都和后面级别的木料有明显的区别，名副其实的名贵木材。 花梨 / 大果紫檀 木材名称：花梨树种中文名：越柬紫檀、安达曼紫檀、印度紫檀、大果紫檀、囊状紫檀、鸟足紫檀、刺猬紫檀树种拉丁名：Pterocarpus.macrocarpus 等商品名：Padauk ambila流通商品名：花梨木科 别：Fabaceae 蝶形花科材色及气干密度（g/cm³）：心材黄褐、红褐至紫红褐色。具深色条纹，边材浅黄色。气干密度大于 0.76产 地：东南亚、非洲等 目前我们在消费家具市场上能遇到最多的国标红木，比他更好一些的奥氏黄檀（白酸枝）、交趾黄檀（红酸枝）可能就需要去专门的红木渠道才能遇到，算作收藏级的产品了。大果紫檀木性稳定，花纹美丽，价格也比较高，因为红木一般是按重量计价，而且没有分级规范，大多是根据货品一货一价，笼统地说现在大果紫檀每吨在 20000 以上，换算成立方价格也在 16000 以上，做成家具比如一桌六椅，差不多是 18000 往上。市面上的大果紫檀基本还是以制作传统形制的家具为多，这样的家具，料是一方面，工可能更重要，一件工料俱全的红木家具，即使是放一件在家里点缀，也是极好的选择。 黑核桃 / 黑胡桃 木材名称：黑核桃树种中文名：黑核桃树种拉丁名：Juglans spp.J.nigra商品名：Black walnut流通商品名：黑胡桃科别：Juglandaceae 核桃科材色及密度：心材紫褐至黑褐色，具黑色条纹，边材窄，黄白色。气干密度 0.56~0.67产地：美国、加拿大、法国、意大利等 黑胡桃是西方世界传统的顶级用材，目前在国内也可以说是风头无二，特点是绚烂的花纹和温暖的色泽，同时还具有出众的稳定性，密度也比较适中，从各方面来说，都是完美的家具用材。北美材的特点就是非常规范，会从级别、厚度、林场、长度四个维度（有些还会加上宽度）来决定木材的品质和价格。具体来说，级别从上到下分为 FAS、1com、2com，品级决定成品家具的瑕疵水平和拼板宽度，其中 FAS 级的成品以少量瑕疵或者无瑕疵的 10cm 以上拼版为主，1com 以少量瑕疵或者无瑕疵的 4-6cm 左右拼版为主，2com 几乎不可避免的在成品上留有大量瑕疵。北美材厚度以英制记，一般用的比较多的是 4/4 也就是一英寸料，产出的成品大概是 2.2-2.3cm，更厚的木料不仅用料更多，而且单位体积的单价也会迅速增加，大部分商家都会采用多层拼接的工艺来生产。黑胡桃的林场基本分为四个档次，MidwestWalnut 的黑胡桃（俗称三撇黑胡桃）地位超然是第一档，Hartzell（俗称哈索）等算是第二档，其他的美国林场直接处理的成品锯材为第三档，进口原木国内切分处理的是第四档。林场影响的更多的是 NHLA 标准中难以被量化的花纹，颜色和光泽，每一档的价差可能在 10% 以上。长度决定的是大件家具的花纹完整性，是一段一段的，还是可以一起连起来的，这个指标比较奢侈了。 C9 级，少数几种接近 Top2 级别的木料，相对于 Top2 来说，他们往往不够全面，或者有一些弱点，但同时也有自己的显著特点，甚至一些专业有不弱 Top2 的品质。 樱桃木 木材名称：樱桃木树种中文名：甜樱桃、黑樱桃树种拉丁名：Prunus spp.商品名：Sweet cherry, Black cherry流通商品名：樱桃木科别：Rosaceae 蔷薇科材色及气干密度（g/cm³）：甜樱桃：心材红褐至褐色，久转红色，边材暗红色，易蓝变。气干密度 0.63黑樱桃：心材暗红褐色，边材白色，宽 3~4cm。气干密度 0.58产地：法国、意大利、美国、加拿大等 樱桃和黑胡桃可以称为北美家具木材的双壁，但是就像北乔峰南慕容一样，后面这个基本还是要低半档。樱桃木的特点是手感极其细腻，类似于细织物的感觉，木材特别稳定，几乎是常用材中最稳定的一种，花纹非常柔和优雅，一直深受追捧。但樱桃同时富含矿物线，有大量的小结疤，白皮也比较严重，色差比较大，同时，樱桃软，容易磕碰，时间长了使用痕迹也比较多，不太适合对外观完美程度比较高的人。 和黑胡桃一样，樱桃木的价格也是从品级，厚度、林场、长度来衡量，但是这里蹦出来一个叫 Gutchess 的林场，这个林场以提供顶级樱桃木和白蜡木著称，它觉得 NHLA 的 FAS 级还不足以描述自己樱桃的牛掰，于是又把 FAS 级细分成了 6 个级别，其中最高的，叫做 F&amp;BP 级。目前，4/4 厚度，Gutchess 的 F&amp;BP 级，7 英尺以上长度的樱桃，大概是 9000 出头。更多的普通 FAS 级樱桃木差不多是 ￥ 8000/m³。樱桃也是在阳光下变色最快的木材之一，夏天的阳光直射情况下，初期可以看到每天都在明显变红。 硬槭木 / 硬枫木 木材名称：硬槭木树种中文名：黑槭、糖槭树种拉丁名：Acer spp. A.nigrum, A.saccharum商品名：Hard maple流通商品名：硬枫木科别：Aceraceae 槭树科材色及气干密度（g/cm³）：心材乳白至淡红棕色，边材色浅。气干密度 0.70产地：俄罗斯、北美、欧洲、朝鲜 硬枫比樱桃更贵一些。但是要注意的是，除了极少几个品牌，你们在普通家具市场看到的枫木，都不是硬枫。从外观上说，可以把硬枫理解成白色的樱桃木，同样优雅的花纹，同样高的稳定性，而且硬度更高一些，在国内目前还算是小众的家具用材，硬枫的市场细节我并不是很了解，前几天专门询了一下价，4/4，FAS 级大概在 ￥ 10000/m³ 出头。如果喜欢打桌球的话，硬枫是美式桌球杆最好的材料。 白栎 / 白橡 木材名称：白栎树种中文名：美洲白栎、二色栎、加州白栎树种拉丁名：Quercus.spp. Q.alba, Q.bicolor, Q.lyrata商品名：White oak流通商品名：白橡科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材灰褐色，边材灰白色带褐色。气干密度 0.63~0.79产 地：俄罗斯、北美、朝鲜、欧洲 白橡木的故事基本就够写一篇了。在西方传统中白橡木的地位非常高，我们可以在各种文学作品、名胜古迹看到橡木。甚至，英国女王马车的皇冠（实际是白栎中的夏栎）和美国总统白宫办公桌都是白橡制作的。但同时，白橡家具在国内的价格又很低，我们在淘宝上 2、3 千块，可能就能买到一张白橡的床，为什么会这样？从渊源上讲，国内最初是韩国人 90 年代在山东开厂做白橡木家具，利用白橡木在欧美的传统地位加上国内的低加工成本，出口欧美低端市场。那个年代的 Made in China 都懂的，确实可以通过各种手段把成本做到极低，08 年以后，大量当地的代工厂把产能转向国内，所以一上来就把定位、品质和价格都压的非常低，这是第一方面。同时，“白橡”在定义上并不足够明确，一般我们说的白橡是指北美的白栎（Quercus alba），但是从广义上来说，白橡也可以是产于东北亚的蒙古栎（Quercus mongolica）也就是俗称的柞木，后者的价格会便宜非常多，而且涂装以后，两者区分也很困难，也造成了大量低价蒙古栎进入市场，把成本做的更低，你还并不能说人家就是假货。最后还有臭名昭著的橡胶木，很多橡胶木卖家直接把橡胶木叫做白橡，或者橡木，更进一步摧毁了白橡的市场形象。一个在欧美被追捧了数百年的高档家具用材，就这样在国内被做毁了。故事讲完，我们来说正经北美白橡的特点。一般认为北美白橡是所有白栎木中品质最高的，富含侵填物，极耐水耐腐蚀，几乎不会有虫害，材质坚硬，相对于红橡，又能细腻，花纹更内敛一些。顶级的白橡在透明涂装以后，是一种温润的淡黄色，非常自然耐看，被现代日式作为正色大量使用。比如在三里屯，畏研吾设计的瑜舍酒店，就大量使用了白橡木作为主要元素。橡木的缺点是木质不够稳定，而且形变力量非常大，制作白橡家具，要尽量避免限制形变，而是通过预留余量，让木材自由伸缩。同时白橡木色差相对比较大，出材困难，如果选料控制不佳，很容易出来乱七八糟的面板。美国几乎所有的木材公司都有白橡木的产品，除了 NHLA 分级标准对瑕疵的控制以外，白橡木好坏最大的区别就是色泽，越好的白橡颜色越纯，而普通品级的白橡会更多的在花纹间出现青色和灰色的部分。Augusta 和 Matson 的白橡一般认为拥有更高的品质，前段时间，FAS 级 4/4 的 Augusta 白橡报价居然超过了 9300/m³，压了 Gutchess 的 F&amp;BP 樱桃木一头，目前回落以后也在 8600 左右。其他普通品牌的更多在 7000 多到 8000 出头的区间。 白栎 / 白橡 木材名称：白栎树种中文名：欧洲栎树种拉丁名：Q.robur商品名：White oak流通商品名：白橡科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材灰褐色，边材灰白色带褐色。气干密度 0.63~0.79产 地：俄罗斯、北美、朝鲜、欧洲 小鞋木豆 / 斑马木 / 乌金木 木材名称：小鞋木豆树种中文名：小鞋木豆树种拉丁名：Microberlinia spp. M.brazzavillensis商品名：Zebrawood流通商品名：斑马木、乌金木科 别：Caesalpiniaceae 苏木科材色及气干密度（g/cm³）：心材浅褐色，具深浅相间黑褐色条纹，边材白色，宽 8cm~10cm。气干密度 0.73~0.80产 地：加蓬、喀麦隆等 乌金木很厉害，作为一个非洲产的非红木类散孔材，居然冲到了 C9 的档次，在他身后，985 和 211 里面也几乎找不到这样的木材。我先解释一下散孔材，我们从小认识的木材都是有年轮的，每一年一个圆圈，形成一个一个的同心圆，木材切开以后，这些同心圆，也就构成了木材上那些细细的抛物线，或者叫山形纹。但并不是所有的木材都是这样，只有环孔材和半环孔材才有明显的年轮，散孔材是没有的，所以切开以后也没有明显的细细的抛物线花纹，更多的是大块大块的色斑——就像斑马的纹路一样。乌金木更早在木材市场就叫斑马木，一直卖的不算好，改叫乌金木以后忽然就火遍了大江南北，价格一路往上，目前虽然有所回调，每立方价格也在 9000 以上，压了传统高档材樱桃和白橡一头。乌金的成功开了一个坏头，从那以后，非洲材东南亚材都不好好叫自己的名字了，各种金丝，黄金之类的名称开始泛滥，不过目前还没见哪个复制了乌金的成功。客观来说，乌金木光泽绚烂，材质干净，少见结疤瑕疵，目前市场接受度很高，价格也足够高，缺点是木质不太稳定，容易开裂，甚至在加工过程中，就容易因为内应力爆裂，对工艺要求比较高。 985 级，标准的高档材，虽然称不上名贵，当也是实木家具中的佼佼者，物理性质通常比较优秀，而且都具有优美的花纹，一般都是温带阔叶材。 白蜡木 木材名称：白蜡木树种中文名：美洲白蜡木树种拉丁名：Fraxinus spp. F.americana商品名：Ash流通商品名：白蜡木科 别：Oleaceae 木犀科材色及气干密度（g/cm³）：心材浅暗灰褐色，边材黄白色，宽 1~2cm，有酸臭气味，蜡质感强。气干密度 0.60~0.72产 地：加拿大、美国等 白蜡木是所很有特点的高校，首先他所在的城市特别好，收益于北美材良好的分级处理水平，这个产地的木料，自动就比别的地方高半档。综合实力上，白蜡木并不出众，这里我又要说一个边材和芯材的概念，绝大部分木材，靠近树心的局域和靠近树皮的区域，材质颜色差别很大，分别叫芯材和边材，一般来说，芯材比较深范围比较大，边材比较浅范围很小，实际中主要使用芯材，比如黑胡桃，比如樱桃，都一样。白蜡不是，白蜡浅色边材范围很大，是主要的使用部分，但是芯材是在内部，又很难去掉，这就造成了白蜡都是芯材边材混用，色差非常明显，出来的外观实在算不上好看。但是，这个学校有一个非常牛的专业，也就是 Gutchess 公司提供的 F&amp;B 级材（国内俗称特选白，是 Gutchess 公司对 FAS 级白蜡再细分四个档次以后最高的品级），这种材料在加工中几乎完全去掉了芯材，最后提供的成品，拥有几乎所有实木中最小色差。传说中的王牌专业就是这种。Gutchess 的 F&amp;B 材辨识度非常高，你看白蜡家具外表面几乎都是纯净的浅色就是了，其他林场的白蜡，一定有大块的深色斑痕。白蜡本身的物理性质中规中矩，木质相对粗一点，但是切面却又特别光滑，花纹特别大气硬朗，喜欢的很喜欢，也有很多人接受不了。价格上，4/4 的 Gitchess F&amp;B 白蜡的价格大概在 6900 左右，其他的林场，基本也就是 6000 出头这样。 红栎 / 红橡 木材名称：红栎树种中文名：美洲白栎树种拉丁名：Quercus.spp. Q.rubru商品名：Red oak流通商品名：红橡科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材暗红褐色，具深色条纹，边材近白色，宽 4cm~6cm。气干密度 0.66~0.77产 地：法国、土耳其、美国、加拿大等 红橡一直是作为白橡的替代材使用的。在前面已经说到白橡原料成本高，成品价格低，再加上色差比较大，出材率低，对家具制造商来说，不是一个好的选择，所以在 10 年前后，很多家具商就转头做那时候还很便宜的红橡。抛开这个以外，红橡也是一种非常理想的家具用材，北美材处理分级水准都比较高，红橡相对白橡色差小，瑕疵少。材质也同样比较坚硬，花纹更大更粗犷一点，虽然缺少侵填物，没有白橡的防水性能，但是作为家具其实也没什么影响。缺点可能是颜色偏红偏暖一些，调调稍微差了一筹。红橡由于本身品质比较均衡，也没有那种公认比较顶级的林场，目前 4/4 的 FAS 级材，价格基本也就是 6000 多一些，和普通白蜡类似，低于白蜡的王牌专业。另外我想说一句，市场上传说的“白橡不白，红橡不红”，前半句倒是没有太大问题，白橡确实是偏黄色更多一些，但是红橡明显相对更红，这个只要见过实物的人应该都能感受到。 211 级，这个级别里我们能够看到很多传统家具用材，之所以传统，很大程度上就是因为他们的物理性能比较适合制作家具使用，长时间里都被人们接受。这个级别里的一些木材和 985 的木料亲缘关系很近，只是因为产地问题品质略差一点，也很像那些同源不同城的高校一样。 水曲柳 木材名称：水曲柳树种中文名：水曲柳树种拉丁名：Fraxinus spp. F.mandshurica商品名：Ash流通商品名：水曲柳科 别：Oleaceae 木犀科材色及气干密度（g/cm³）：心材褐或浅栗褐色，边材黄白或黄褐色，宽 2cm。气干密度 0.68产 地：东北、华北、陕等 水曲柳和白蜡的性能高度接近，而且价格上涨迅速，目前好的水曲柳价格也已经到了 5000 多，和普通白蜡木相比，可能就是差一个产地，一个分级处理水平了。 扩展阅读：别再拿水曲柳当白蜡卖了 白栎 / 蒙古栎 / 橡木 木材名称：白栎树种中文名：柞木树种拉丁名：Q.mohgolica商品名：Mongolian oak流通商品名：橡木、蒙古栎科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材褐至暗褐色，有时带略黄，边材淡黄色带褐，宽 2cm。气干密度 0.63~0.79产 地：俄罗斯、朝鲜、蒙古等 首先要强调，这里说的白栎是主要产于俄罗斯和蒙古的柞木，大家在市场上听到的所谓欧洲橡木可能大多数是这种，而非欧洲橡木。真正的欧洲橡木，欧洲栎（Quercus rabur）产于西欧，又以卢浮栎、夏栎最为知名。简单说，蒙古栎的外观，性质和美国白橡都非常接近，很多会直接冒充美国白橡使用，区别是瑕疵多一些，所以板宽会窄一些，花纹间的灰色，青色填充物更多，颜色更深更暗一点，不过老实说，很多时候我也分不出来。除此以外，栎木类一般形变都比较大，好的白橡红橡成品锯材在美国经过非常严格的烘干处理，相对还好，蒙古栎很多都是从俄罗斯进口原木，国内处理，这方面做的还是差一些，后期问题可能会更大一些。北京西北郊的阳台山山脚附近有大量的槲栎、蒙古栎，喜欢爬山的朋友应该都是见过的。 榆木 / 青榆 / 黄榆 木材名称：榆木树种中文名：裂叶榆、大果榆树种拉丁名：Ulmus spp. U.laciniata, U.marcocarpa商品名：Elm流通商品名：青榆、黄榆科 别：Ulmaceae 榆科材色及气干密度（g/cm³）：心材黄褐至浅红褐色，边材浅黄至黄褐色。气干密度 0.54~0.66产 地：东北、华北、西北、青、甘、鲁、豫等 说榆木，就绕不开“老榆木”的概念，我们经常可以听到商家说，“别人家的榆木容易裂，我们家的是老榆木，都是旧房子几十年的房梁拆下来的，不会裂”。这话对不对？我们分成两部分说：有没有人真的拿拆房梁的老榆木做家具，不是老榆木是不是就真的容易裂。第一，有，我们现在仍然能够在传统家具作坊看到使用老榆木作为原材料，但是，如果是一个现代工业品牌，这个说法就扯淡了，靠拆老房子出来的那点料，根本不可能作为一个规模企业的稳定供应渠道，实际上目前市面上的规模企业，几乎都是使用的俄罗斯进口榆木。第二，不对，榆木因为自然干燥困难，过去只能通过几年，十几年的放置让他缓慢干燥，这样就可以减轻变形，也就老榆木不变形的说法的由来。但是实际上，在现代烘干工艺面前，榆木并不算什么特别难干燥的木料，合格处理的“新”榆木，完全可以作为合格的家具用材使用。同时，俄罗斯进口的“新”榆木，因为树径更大，普遍拥有更好的纹理，更小的色差，更纯净的颜色，甚至可以说也是一种理想的家具用材。 水青冈 / 欧洲山毛榉 木材名称：水青冈树种中文名：欧洲水青冈树种拉丁名：Fagus.spp F.sylvatica商品名：European beech流通商品名：欧洲山毛榉科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材浅黄褐色带微红，久转浅红褐色，边材白色，宽 2cm。气干密度 0.67~0.72产 地：法国、德国、比利时、美国等 也叫山毛榉，或者叫欧洲榉木，是一种壳斗科的木料，亲缘关系更接近橡木，我们可以在上面看到类似橡木的细小木射线。山毛榉的木材相对于橡木更加细腻一些，瑕疵更少，色差更小，但是花纹也更浅一些，几乎看不出来，做出来的家具没有那么好看，所以也要便宜很多。目前从德国和罗马尼亚进口的山毛榉价格大概在 4800-5100。物理性质上，山毛榉没有橡木那么爱裂，但是更爱翘曲形变，所以在制作的过程中，也要注意采用合理的结构和工艺。和蒙古栎一样，北京西郊阳台山山脚也有大量的山毛榉混植，挂的牌子是水青冈，秋天他们的果实会落的满地都是。 亚花梨 / 非洲紫檀 木材名称：亚花梨树种中文名：非洲紫檀树种拉丁名：P.soyauxii商品名：African padauk流通商品名：非洲紫檀科 别：Fabaceae 蝶形花科材色及气干密度（g/cm³）：心材黄褐、红褐至紫红褐色。边材蓝白色，宽 5cm~8cm 气，具波痕，略有香气。气干密度 0.50~0.72产 地：莫桑比克、坦桑尼亚、加蓬、喀麦隆等 实际上，市面上现在都直接叫非洲花梨，有些甚至直接叫花梨木了，不属于国标红木，但是也还可以，档次和榆木差不多，一般用来做低端的传统造型家具。 桤木 / 美国赤杨 / 赤桦 / 北美桤木 / 南美樱桃木 木材名称：桤木树种中文名：桤木树种拉丁名：Alnus spp.商品名：Alder流通商品名：科 别：Betulaceae 桦木科材色及气干密度（g/cm³）：木材乳黄至浅黄褐色。气干密度约 0.65产 地：北美 赤杨和黄杨是北美进口的阔叶林中价格最低的两种，其中，赤杨主要的用途就是仿冒樱桃木。赤杨的手感和花纹与樱桃非常相似，几乎可以乱真，密度略低，但是也还接近，主要区别在颜色和矿物线上，但是经过有色漆的涂装也都可以掩盖过去。如果存心造假，除非极有经验，否则很难分辨。即使被揭穿以后，很多商家也会说这是南美樱桃木搪塞过去。同时，南美樱桃木也可能是指另一种仿冒樱桃木的木材，这个会在后面介绍，国内木材名的混乱也可见一斑。 美国黄杨 / 北美鹅掌楸备注：此木材未在《中国主要木材流通商品名称》 WB/T1038-2008 标准上找到，对该木材的信息均引自知乎用户。 树种中文名：北美鹅掌楸树种拉丁名：Liriodendron tulipifera商品名：Yellow poplar科 别：Magnoliaceae 木兰科产 地：北美 得益于北美高水准的木材分级处理工艺，鹅掌楸这种传统主要做辅料的木料，现在使用的场景也越来越多了，而且价格不低。但老实说，鹅掌楸密度实在有些太低，强度也不太好，作为主材使用，物理性质还是稍差一些的。鹅掌楸本身色差也比较大，花纹很浅，外观不算好看，主要还是涂上深色漆做美式家具使用。 楸木 / 核桃楸 / 胡桃楸楸木是我们经常在家具市场听到的一个名词，但是也是最乱的一种。就跟柞木不是柞木一样，家具市场上的楸木并不是楸木： 树种中文名：楸木 / 梓木树种拉丁名：Catalpa spp. C.ovata duclouxii Dode商品名：梓树流通商品名：梓桐木科别：Bignoniaceae 紫葳科材色及气干密度（g/cm³）：心材深灰褐色，边材灰黄褐色。气干密度 0.47产地：滇、川、鄂、黔、闽、陕 理论上，家具市场上的楸木实际是核桃楸，这个： 树种中文名：核桃楸树种拉丁名：Juglans spp. J.mandshurica商品名：Walnut流通商品名：楸木科别：Juglandaceae 核桃科材色及气干密度（g/cm³）：木材红褐或粟褐色，具紫色条纹，久转巧克力色，边材前黄褐色或浅粟褐色。气干密度 0.52产地：东北各省、河北、陕西 真正的胡桃楸是非常好的家具用材，物理性质与黑胡桃类似，花纹也非常接近，只是缺少黑胡桃的光泽，同时颜色不是栗褐色或者紫褐色而是浅灰黄色。但是实际上我只在两家非常高端的家具品牌看到过真正的胡桃楸。市面上绝大多数的“胡桃楸”，其实是后面会讲到的各种东南亚进口的散孔材，XX 胡桃这种。普通消费者来说，听到“胡桃楸”，就当做是最后这种情况考虑就可以了。那么真的胡桃楸都去哪了呢——染成栗褐色冒充黑胡桃去了，因为质感外观都与黑胡桃高度接近，染色后的胡桃楸迷惑度很高。 普通本科，市面上最大量的实木家具落在这个级别，撑起了实木家具的大半个江山，他们通常是来自非洲南美和东南亚的散孔材，但是作为家具使用，其实也是很具有性价比的选择。这个级别的木料通常不会直接使用自己的本名出现在市场上，他们很热衷于给自己改名字，通常都是加上华丽的形容词再去抱一个名贵木材的大腿。而且名称还会经常变化，很容易就把人搞晕了。这类木材的特点是缺少细的清晰的抛物线花纹，多是粗且散乱的色斑，很多木材在涂装以后还会有亮亮的光泽。这个级别内的木材互相之间辨识度不高，很多时候甚至名字都会混用，价格基本也都在 2000 多到 4000 多的区间内，所以下面的部分我会写的比较简略，有特点的说特点，没特点就直接略过了。 印咖木 / 菠萝格 木材名称：印咖木树种中文名：印咖木树种拉丁名：Itsia spp. I.bijuga商品名：Merbau kwila流通商品名：菠萝格科 别：Caesalpiniaceae 苏木科材色及气干密度（g/cm³）：心材褐至暗红褐色，边材浅黄白色，含硫磺色沉积物。气干密度 0.80产 地：马来西亚、印尼、巴新、斐济 、所罗门群岛等 这种木材做大板桌或者地板比较多，很少用在家具上。 奥克榄 / 红檀木 / 奥古曼 树种中文名：奥克榄树种拉丁名：Aucoumea spp. A.Klaineana商品名：Okoume科 别：Burseraceae 橄榄科材色及气干密度（g/cm³）：心材橙红至浅红褐色，边材窄，灰白色。气干密度 0.48产 地：加蓬、喀麦隆、赤道几内亚等 也会叫做红胡桃，奥古曼的密度实在有点低，强度还不如松木，其实不太适合作为家具主材使用。 硬合欢 / 大叶合欢 木材名称：硬合欢树种中文名：大叶合欢树种拉丁名：Albizia spp. A.lebbek商品名：Kokko科 别：Mimosaceae 含羞草科材色及气干密度（g/cm³）：心材黑褐色，边材色浅。气干密度约 0.68~0.82产 地：东南亚 橡胶木 木材名称：橡胶木树种中文名：橡胶树树种拉丁名：Hevea spp. H.brasiliensis商品名：Rubber wood流通商品名：橡胶木科 别：Euphorbiaceae 大戟科材色及气干密度（g/cm³）：木材乳黄至浅黄褐色。气干密度约 0.65产 地：马来西亚、印尼、缅甸、越南、亚马逊等 关于橡胶木各种材料上已经够多了，一般认为橡胶木的稳定性不太好，所以绝大部分情况下会以指接板的形式使用。这里主要谈市面上关于橡胶木的两种说法。首先是卖家经常会说橡胶木是热带材，防水，所以特别适合浴室柜。荒谬，热带材和防水没有任何关系，橡胶木防水的说法，很大程度上是因为他经常自称橡木，而白橡木确实是有出众的防水能力的，但是这个能力和橡胶木没有任何关系。另一个说法是说，橡胶木都是用药水泡出来的，所以污染很大，实际上他们翻出来的所谓橡胶木泡药水的材料，是使用硼砂溶液对橡胶木进行杀虫反腐的过程，这个过程几乎所有的木材都会经历，上至 TOP2 也不例外，不会产生任何有机挥发物，和污染没有毛线关系。实际上市面上橡胶木产品往往污染很大，并不是橡胶木本身的问题，而是因为橡胶木定位低，价格便宜，所以配用的油漆通常都很差，又因为用在卫生间等潮湿区域，油漆又会刷的很厚，最后污染自然就大了。 专科院校，实木家具的有益补充，一般是作为辅料或者临时简易家具用料使用，很少直接作为成品主材。 桦木 木材名称：桦木树种中文名：高加索桦木树种拉丁名：Betula spp. B.medwediewii商品名：Birch bereza流通商品名：桦木科 别：Betulaceae 桦木科材色及气干密度（g/cm³）：木材黄白色略带褐，有淡红褐色假心材。气干密度 0.55~0.67产 地：俄罗斯等 桦木家具我们可能只有在宜家才能看到，再就是做软包沙发的内框了，材质脆，容易开裂，但是桦木的外观和樱桃木非常接近（另一个经常用来仿冒樱桃的美国赤杨也是桦木科），所以要小心那些便宜的离谱的“樱桃木”家具，很可能是桦木仿冒的。 泡桐 木材名称：泡桐树种中文名：泡桐树种拉丁名：Paulownia spp. P.fortunei.商品名：Paulownia流通商品名：泡桐科 别：Scrophulariaceae 玄参科材色及气干密度（g/cm³）：木材浅灰至浅灰红褐色，新材有奇臭气味。气干密度 0.24产 地：黄河流域西至秦岭 应该是我们能接触到的最便宜最轻最疏松的木材，因为过于疏松，吸水率也比较高，夏天下雨的情况下，容易有霉变黑斑，一般来说，不太建议使用。 硬松木 / 马尾松 / 松木 木材名称：硬松木树种中文名：马尾松树种拉丁名：Pinus spp. P.massioniana商品名：Hard pine流通商品名：松木（本松）科 别：Pineaceae 松科材色及气干密度（g/cm³）：心材红褐色，边材黄褐或浅红褐色，易蓝变，具油性感，有松脂香气。气干密度 0.44~0.64产 地：南方各省 硬松木 / 樟子松 木材名称：硬松木树种中文名：樟子松树种拉丁名：Pinus spp. P.syvestris商品名：Hard pine流通商品名：樟子松科 别：Pineaceae 松科材色及气干密度（g/cm³）：心材浅红褐色，边材窄，浅黄褐色，易蓝变，具树脂圈，有松脂香气。气干密度 0.44~0.47产 地：大兴安岭、内蒙古等 硬松木 / 云南松 / 青松 木材名称：硬松木树种中文名：马尾松树种拉丁名：Pinus spp. P.yunnanensis商品名：Hard pine流通商品名：青松科 别：Pineaceae 松科材色及气干密度（g/cm³）：心材浅红褐色，边材黄褐色，易蓝变，有松脂香气。气干密度 0.44~0.62产 地：云、贵、川、桂等 其他，暂未分类 水青冈 / 山毛榉 木材名称：水青冈树种中文名：水青冈树种拉丁名：Fagus spp. F.longipetiolata商品名：Beech流通商品名：山毛榉科 别：TFagaceae 壳斗科材色及气干密度（g/cm³）：心材红褐色，边材黄褐至浅红褐色，有时渐变。气干密度 0.78产 地：滇、鄂、川、陕、豫等 榉木 / 大叶榉 木材名称：榉木树种中文名：榉树树种拉丁名：Zelkova spp. Z.schneideriana商品名：Elm流通商品名：大叶榉科 别：Ulmaceae 榆科材色及气干密度（g/cm³）：心材暗褐至浅栗褐色，边材黄褐色，有微苦味。气干密度 0.79产 地：秦岭、长江流域中下游、闽、桂、滇 注意，这里的榉木并非市面上我们常见的榉木。一般我们买到的榉木是来自欧洲尤其以德国为主的山毛榉，即我们买到的榉木家具，木材都是进口自欧洲的欧洲山毛榉，或者称欧洲水青冈。木纹色浅柔和，可以看到细小射线的那种木材。具体可以参考前面提到的德国山毛榉。 杉木 木材名称：杉木树种中文名：杉木树种拉丁名：Cunninghamia spp. C.lanceolata商品名：Chinese fir流通商品名：杉木、杉树科 别：Taxodiaceae 杉科材色及气干密度（g/cm³）：木材浅栗褐或浅灰红褐色，边材浅黄褐或浅灰褐色微红，有浓郁杉木香气。气干密度 0.31~0.41产 地：南方各省 参考链接 现在实木家具价格排序和优缺点？ - 知乎 中国木材网 提供各种木材的实时报价 美国工程木材协会 提供工程木材方面的信息 craft wood products 做的很漂亮的一个有关木制品设计的网站 my harmony 一家来自香港的家具商 中国林业科学院木材工业研究所网站 如何购买实木复合地板 《中国人造板》杂志 网站现在已经没有运营了 木材的特点 关于中国主要木材的三大相关标准 如何选择家具的木材 youtube 上的一个木匠 家具木材科普 - HowStuffWorks 几种适合现代家具的实心木材 阅木 数据和资料并不准确，对木材的分级更是匪夷所思，比如橡胶木和白橡木分级完全一样。网页界面做的可以，需自行甄别，适度参考。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木材的特点]]></title>
    <url>%2Fpassages%2F%E6%9C%A8%E6%9D%90%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[木材为古老而又年轻的绿色环保材料，广泛应用于小到牙签、筷子，大到家具及室内装饰，与我们的生活密切相关。尤其是当前日益火爆的建材市场上，木材作为重要的建筑材料，对人体健康有着直接重要影响，更得到人们的十分关注，所以研究木材对人体健康的保健功效十分必要。木材作为一种生物材料，经研究，较常用的砖、石、水泥、金属、塑料有如下主要优异的住室功效： 视觉功效木材纹理美观，色泽丰富，又能有效地吸收对人体眼睛有害的紫外线，因此使人视觉舒服、健康。 触觉功效人与木材接触时，四季温度相近，在木地板上行走时，软硬适当，又富有弹性，木材均给人以良好的触觉。 听觉功效木材为天然的多孔性材料，吸声、隔音性能良好。因此，用木质材料装饰的住宅，回声小，隔音效果佳，给人以舒适的安静感。 嗅觉功效多种木材经常散发出令人欢快的特殊芳香。经试验，这些芳香可产生对人体健康的保健功效。例如：冷杉，可舒解肌肉疼痛，使人产生温暖感受；柏木，能镇痛，并能镇静神经、松弛精神；樟木，抗痉挛，又具有兴奋作用；桉木，有激励精神的作用；檀香木，有镇静神经、抗抑郁的功效。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红木知识]]></title>
    <url>%2Fpassages%2F%E7%BA%A2%E6%9C%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[红木知识问答，现在开始： 1、红色的木材就是红木吗？ 红色的木材不一定都是红木，红木心材的材色也不全是红色的。《红木》标准中共列出 8 类（紫檀木类、花梨木类、香枝木类、黑酸枝木类、红酸枝木类、乌木类、条纹乌木类和鸡翅木类），隶属于 5 属（紫檀属、黄檀属、柿属、崖豆属及铁刀木属），红木指的是这红木指的是这 5 属 8 类的心材。 2、红檀香属于红木吗？ 红檀香学名香脂木豆，归于香脂木豆属，心材红褐色至紫红褐色，结构甚细而均，木材具有香气。但是红檀香不属于《红木》标准中规定的 5 属 8 类 33 种木材，所以不属于红木范畴。 3、中国人为什么喜欢红木？ 历史性：中国古典家具有千余年的悠久历史。明清家具是我国家具发展的巅峰，经典明清代家具用材讲究，主要是采用降香黄檀（即黄花梨）、紫檀、酸枝、花梨木等珍贵木材。民族性：中国人自古以来对艺术品的审美追求较之西方人则更注重艺术品载体本身的质量。而载体质量的优劣往往又与稀有、名贵、美观、光润等视觉、触觉、乃至味觉等人所能全方位感受认知的价值有关。中国人自古以来有爱木、爱玉的传统，喜欢回归自然。思想性：明清家具是刻在红木上的文化，反映了中国人的“儒家之道”，“稳重、平和”，“天人合一”和“天圆地方”的理念。同时每件家具都具有美好的寓意的图案，通过雕刻来表达。雕刻主要有人物、山水、花鸟、历史故事、吉祥符号等形式。科学性：结构严谨，设计合理，符合人体工程学，如椅子背“S”曲线，让人坐着舒服。由于木材很硬重，基本无法使用钉子，所以产生了根据硬木特性产生的一系列制作工艺和表现形式。艺术性：从家具的线条和结构与精美的木材纹理与花纹，与中国的水墨画和书法的线条艺术吻合，符合中国人的审美情趣，每件红木制品具有变化莫测的唯一性自然美。实用性：红木家具为人类生活所必须的用品。 总之，中国人对红木文化有很深的情缘，因为她是中华民族文化的象征，大到购置各种红木家具，小至各种小的工艺品，如小盒、挂件、手串，表示人们喜爱红木，喜爱中华文化；崇拜自然，回归自然；有文化，有身份地位的象征。 摘录自:中国林业科学院木材工业研究所网站]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
        <tag>红木</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：原型与继承]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型每个 JavaScript 中的对象都有一个特殊的内部隐藏属性 [[prototype]]，它要么指向 null，要么指向另一个对象，我们称之为原型。当我们从一个对象上读取某个属性，如果在对象本身上没有找到，那么 JavaScript 引擎会尝试从它的原型中去寻找。 原型属性 [[prototype]] 虽然是内部隐藏的属性，但是有一些方法可以获取到它。 __proto__其中之一是 __proto__，但是 __proto__ 并不完全等同于原型，只是由于历史原因，各个浏览器包括 NodeJS 都部署了这一属性，实际开发中应该使用 ES 规范中的更现代的设置原型的方法，后面会提到。考虑如下代码： 12345678910111213// 代码片段 1const animal = &#123; eats: true&#125;;const rabbit = &#123; jumps: true&#125;;rabbit.__proto__ = animal;console.log(rabbit.jumps); // trueconsole.log(rabbit.eats); // true rabbit 对象本身没有 eats 属性，但是因为让它的原型指向了 animal 对象，这时我们可以说 animal 是 rabbit 的原型。所以引擎会在 rabbit 没有某个属性时从其原型 animal 上获取。 因此，我们可以将许多有用，但是更加通用的属性放到抽象程度更高的对象中，显然，在这里是 animal： 123456789101112131415// 代码片段 2const animal = &#123; eats: true, walk() &#123; alert("Animal walk"); &#125;&#125;;const rabbit = &#123; jumps: true, __proto__: animal&#125;;// walk is taken from the prototyperabbit.walk(); // Animal walk 现在 rabbit 通过原型，继承了 animal 的共同属性 eats 和 walk。原型链 prototype chain 还可以更长： 123456789101112131415161718192021// 代码片段 3const animal = &#123; eats: true, walk() &#123; alert("Animal walk"); &#125;&#125;;const rabbit = &#123; jumps: true, __proto__: animal&#125;;const longEar = &#123; earLength: 10, __proto__: rabbit&#125;;// walk is taken from the prototype chainlongEar.walk(); // Animal walkalert(longEar.jumps); // true (from rabbit) 现在，按照抽象程度由低到高形成了一条原型链：longEar -&gt; rabbit -&gt; animal。 原型链的限制对于原型链来说主要由下面 3 条限制： 原型链不能构成环，否则引擎将会抛出错误，在上面的例子中，即不能再将 animal 的原型指向 longEar。 __proto__ 的值类型要么是 null，要么是 Object，即另一个对象。所有基本类型的值会被忽略。 一个对象只能有一个原型，即不能继承两个父级。 this 的值当对象调用原型的方法时，this 的值是指代原型还是对象本身呢？下面的代码清晰的说明了这一问题： 123456789101112131415161718192021const user = &#123; name: "John", surname: "Smith", get fullname() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set fullname(value) &#123; [this.name, this.surname] = value.split(" "); &#125;&#125;;const admin = &#123; name: "Norah", surname: "Jones", isAdmin: true, __proto__: user&#125;;console.log(admin.fullname); // Norah Jonesadmin.fullname = "Michael Jackson";console.log(admin.fullname); // Michael Jackson 不管某个方法是在对象本身上，还是在其原型上，this 永远指向 . 运算符前面的对象。 F.prototype我们知道，对象除了可以使用字面量创建，还可以使用 new F() 形式的构造函数来创建。请注意，构造函数本质上依然是函数，JavaScript 中的每个函数都具有一个特殊的 prototype 属性。默认情况下，它是一个仅包含 constructor 属性的对象（不包括每个对象的隐藏属性 [[prototype]]，因为函数也是对象），其中 constructor 指向函数本身： 1234const F = function() &#123;&#125;;console.log(F.prototype); // &#123; constructor: f &#125;console.log(F.prototype.constructor === F); // true 如果我们让 F.prototype 指向一个对象，那么在使用 new 操作符调用构造函数 F 时，新创建的实例的原型 [[prototype]] 都将被指向这个对象。示例： 12345678910111213141516const animal = &#123; eats: true&#125;;const Rabbit = function(name) &#123; this.name = name;&#125;;Rabbit.prototype = animal; // 设置所有 Rabbit 创建的实例的原型为 animalRabbit.prototype.construtor = Rabbit; // 修正 Rabbit 原型的 constructor 的指向 (*)const rabbit = new Rabbit("white rabbit");console.log(rabbit.eats); // trueconsole.log(rabbit.__proto__ === animal); // trueconsole.log(rabbit.constructor === Rabbit); // true 上面的代码中，另一个需要注意的问题是 F.prototype.constructor 的值。改变构造函数 F.prototype 的默认指向，如果接下来（之前创建的实例不会受到影响）使用到其新创建的实例的 construtor 属性，会导致意想不到的错误。拿上面的例子来说，如果没有 (*) 这一行代码，rabbit.constructor 的值将会指向 animal，显然这在人意料之外，也不合理。所以，普遍的共识是：不要依赖 constructor 这一属性，因为它能被任意修改。 有时候，我们需要使用某个实例的构造函数来创建一个实例，但是却不知道它的构造函数。这时可以这样做，但是需要小心： 1234567const User = function(name) &#123; this.name = name;&#125;;const user = new User("Bill");const user2 = new user.constructor("Sunny");alert(user2.name); // Sunny 上面的代码可以如正常运行，因为构造函数 User 的 prototype 的指向是默认的，指向其自身。假如修改一下代码，改变其指向： 12345678const User = function(name) &#123; this.name = name;&#125;;User.prototype = &#123;&#125;;const user = new User("Bill");const user2 = new user.constructor("Sunny"); // (*)alert(user2.name); // undefined 我们来看看 (*) 这一行发生了什么： 首先引擎会在 user 对象上查找 constructor 属性，没有找到。 接着引擎会沿着原型链查找，user 的原型是 User.prototype，它是一个空对象 {}，没有找到。 空对象 {} 的原型是 Object.prototype，而 Object.prototype.constructor === Object。所以实际执行的是 new Object(&#39;Sunny&#39;)，而内置的对象构造函数会忽略所有参数，所以得到如上结果。 Object.prototype让我们来看下面的代码： 12const obj = &#123;&#125;;alert(obj); // [object Object] 为什么会有以上的输出？我们定义的对象是空的，是哪里来的代码生成了 [object Object] 这样的字符串信息？答案是内置的 toString 方法。通过字面量创建对象等同于使用对象构造函数 new Object()。而 Object 构造函数就像所有函数一样，也有一个 prototype 属性，它指向了一个很大的对象，上面部署了 constructor, toString, valueOf 等一系列所有对象通用的方法和属性。 以下代码可以检查上面所说： 1234const obj = &#123;&#125;;alert(obj.__proto__ === Object.prototype); // true// obj.toString === obj.__proto__.toString == Object.prototype.toString 另外，Object.prototype 这个内置的原型的 [[prototype]] 指向了谁呢？答案是 null: 1alert(Object.prototype.__proto__); // null 其他抽象程度稍低的一些内置对象，比如 Function，Array，Date 等，也部署了一些方法在其原型上。这样每一个函数实例，数组实例或者日期实例，都可以使用一些内置于其原型上的方法了。这样设计的目的非常利于节省内存。下面这张图局部地说明了这种关系。 我们可以手动地验证一下： 12345678910const arr = [1, 2, 3];alert(arr.__proto__ === Array.prototype); // truealert(arr.__proto__.__proto__ === Object.prototype); // truealert(arr.__proto__.__proto__.__proto__); // nullconst f = function() &#123;&#125;;alert(f.__proto__ === Function.prototype); // truealert(f.__proto__.__proto__ === Object.prototype); // true 基本类型的原型对于 String, Number, Boolean 这 3 种基本类型而言，当访问它们的属性时，会使用内置的构造函数（比如 Number()）创建一个临时的封装对象，然后访问这个临时封装对象原型上的属性或者方法，访问完成后临时对象就消失了，这一过程对我们来说都是不可见的。 对于 null 和 undefined 而言，不会有自动创建临时封装对象这一过程，因为它们没有可用的属性或者方法，也就没有内置的原型。 设置原型的现代方法我们应该只考虑以下 3 种现代的设置原型的方法： Object.create(proto [, descriptors]) - 以给定的 proto 作为原型，创建一个新的空对象，descriptors 是可选参数，代表属性描述符。 Object.getPrototypeOf(obj) - 返回对象的原型。 Object.setPrototypeOf(obj, proto) - 将 obj 的原型设为 proto。 让我们用更标准、现代的方法改写前面的例子： 1234567891011121314const animal = &#123; eats: true&#125;;const rabbit = Object.create(animal, &#123; jumps: &#123; value: true &#125;&#125;);alert(rabbit.eats); // truealert(Object.getPrototypeOf(rabbit) === animal); // trueObject.setPrototypeof(rabbit, &#123;&#125;); // 改变 rabbit 的原型，使其原型为一个空对象 使用原型方法进行浅拷贝123const origin = &#123;...&#125;;const clone = Object.create(Object.getPrototypeOf(origin), Object.getOwnPropertyDescriptors(origin)); 上面的代码，以源对象的原型为原型，加上源对象的所有属性描述符选项，复制了所有源对象的属性，不管是可枚举属性还是不可枚举属性，数据属性还是访问属性，也包括了 Symbol 属性；同时有着相同的原型。 让我们看一个详细的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 源对象const origin = Object.create(null, &#123; name: &#123; value: "Sheldon", writable: true, enumerable: true, configurable: true &#125;, surname: &#123; value: "Cooper", writable: true, enumerable: true, configurable: true &#125;, fullname: &#123; get() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set(value) &#123; [this.name, this.surname] = value.split(" "); &#125; &#125;, [Symbol("id")]: &#123; value: 9527, writable: false, configurable: true, enumerable: true &#125;, toString: &#123; value: function() &#123; return "custom toString!"; &#125;, writable: true, enumerable: false, configurable: true &#125;&#125;);// 浅拷贝const clone = Object.create( Object.getPrototypeOf(origin), Object.getOwnPropertyDescriptors(origin));// 可枚举属性和 Symbol 属性复制成功console.log(clone); // &#123; name: 'Sheldon', surname: 'Cooper', [Symbol(id)]: 9527 &#125;// 不可枚举属性复制成功console.log(clone.toString()); // custom toString!// 访问属性复制成功console.log(clone.fullname); // Sheldon Cooper// 原型复制成功console.log(Object.getPrototypeOf(clone) === null); // true 上面代码的源对象是一个出于演示目的而定制的，包含了可枚举属性和不可枚举属性，数据属性和访问属性，以及 Symbol 属性，从最后的打印结果可以看到，拷贝对象全部成功地复制了过来。 不要轻易在初始化更改原型设置以上面的代码为例，如果我们在一开始让 rabbit 以 animal 为原型，接下来不要轻易更改 rabbit 的原型，因为引擎会对已有的原型继承做很多属性读取之类的优化，更改原型会破坏这些已有的优化，导致运行速度变慢。 纯字典对象假设我们想要实现一个纯字典对象，即包含一切合法字符串为键的键值对，使用通常的字面量对象会有一个问题：有一个特殊的字符串 __proto__ 无法如预期般奏效。 123456const dictionary = &#123; __proto__: "some value"&#125;;alert(dictionary.__proto__); // [object Object]alert(dictionary.__proto__ === Object.prototype); // true 上面的属性读取无法得到预期的 some value 结果，因为通常字面量创建的对象，默认原型是 Object.prototype ，而因为历史原因 __proto__ 这一特殊属性被当做访问原型的途径。如果将其赋值为基本类型值，赋值操作将会被忽略。 如何解决上面的问题？有两种方式： 使用 Map，通常这是更加推荐的做法。 使用 Object.create(null) 从所有原型的顶端 null 继承，这样创建的对象是一个真正的纯对象，不会包含一般对象内置的 toString，valueOf，__proto__ 等属性。 属性遍历方法比较 Object.keys(obj) / Object.values(obj) / Object.entries(obj) – 返回一个包含对象自身的可枚举字符串属性的键 / 值 / 键值对的数组。不包含继承属性，不包含 Symbol 属性。 Object.getOwnPropertySymbols(obj) – 返回一个包含自身所有 Symbol 属性的数组。 Object.getOwnPropertyNames(obj) – 返回一个包含自身所有字符串属性的数组。 Reflect.ownKeys(obj) – 返回一个包含自身所有属性的数组。 obj.hasOwnProperty(key) - 如果自身（非继承）包含该属性，返回真。 for...in 循环 - 遍历所有可枚举的字符串属性，包括自身属性和继承属性。不包括不可枚举属性，不包括 Symbol 属性。 基于原型实现继承虽然 ES6 引入了 class 关键字，但那只是一种语法糖。JavaScript 中继承的实现本质上是基于原型的。原型继承的实现参考以下代码： 12345678910111213141516171819202122232425262728function Animal(name) &#123; this.name = name;&#125;Animal.prototype.eat = function() &#123; console.log(`$&#123;this.name&#125; eats`);&#125;;Animal.prototype.walk = function() &#123; console.log(`$&#123;this.name&#125; walks`);&#125;;function Rabbit(name) &#123; this.name = name;&#125;Rabbit.prototype.walk = function() &#123; console.log(`$&#123;this.name&#125; bounces`);&#125;;// 让 Rabbit 继承 AnimalObject.setPrototypeOf(Rabbit.prototype, Animal.prototype);// 或者这样写： Rabbit.prototype = Object.create(Animal.prototype);// 不推荐写法： Rabbit.prototype.__proto__ = Object.prototypeconst rabbit = new Rabbit("white rabbit");rabbit.walk(); // white rabbit bouncesrabbit.eat(); // white rabbit eats]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：对象的属性描述符]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 中的对象属性，并不只是简单的键值对，通过属性描述符 property descriptor ，我们可以更加灵活的配置对象属性以控制属性的行为，包括是否可枚举、是否可写、是否可配置，实现更强大的功能。实际上，对于对象而言，一共有 2 种属性： 数据属性 data property 访问属性 accessor property 数据属性通常我们见到的属性都是这样的：12345// 代码片段 1const user = &#123; name: 'Sheldon', age: 29&#125;; 上面的 name 和 age 都是数据属性。 访问属性还有另一种形式，比如：123456789101112131415// 代码片段 2const user = &#123; name: 'Bill', surname: 'Gates', get fullname() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set fullname(value) &#123; [this.name, this.surname] = value.split(','); &#125;&#125;;user.fullname // Bill Gatesuser.fullname = 'Sheldon Cooper';user.name // Sheldon 上面的 name 和 surname 是数据属性，fullname 则是访问属性。即凡是使用 get prop() 或者 set prop() 定义的属性，都是访问属性，不再是数据属性。 数据属性的描述符对于数据属性而言，其描述符由 4 个 flag 组成： value 属性的值 writable 是否可写 enumerable 是否可枚举，在类似 for...in 遍历中是否忽略 configurable 是否可配置，即是否可以编辑描述符的 flag 对于使用字面量声明的对象属性而言，除了 value 之外的 3 个 flag 的默认值都为 true。使用 Object.getOwnPropertyDescriptor(obj, prop) 方法可以获取对象上某属性的描述符。比如获取上面代码片段 1 中 user 对象 name 属性的描述符：12345678// 代码片段 3const descriptor = Object.getOwnPropertyDescriptor(user, 'name');// &#123;// "value": "Sheldon",// "writable": true,// "enumerable": true,// "configurable": true// &#125; 如果想要精确地控制属性的行为，使用 Object.defineProperty(obj, prop, descriptor) 方法。使用这种方式，如果属性的某个 flag 没有显式指定，则默认值将是 false 。123456789101112131415// 代码片段 4const user = &#123;&#125;;Object.defineProperty(user, 'name', &#123; value: 'Sheldon', writable: true&#125;)const descriptor = Object.getOwnPropertyDescriptor(user, 'name');console.log(JSON.stringify(descriptor, null, 2));// &#123;// "value": "Sheldon",// "writable": true,// "enumerable": false,// "configurable": false// &#125; 可以看到，除了显式指定的 writable ，其他未指定的 flag 的都是默认为 false。 可枚举性描述符的 enumerable 属性，称为“可枚举性”，如果该属性为 false，就表示某些操作会忽略当前属性。目前，有四个操作会忽略 enumerable 为 false 的属性。 for...in 循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。 可配置性描述符的 configurable 属性，表示该属性的 flag 是否可配置，一旦设为 false 不可逆。用的很少。 访问属性的描述符访问属性的描述符不同于数据属性的描述符，没有 value 和 writable 这 2 个 flag，多了 get 和 set，所以一个访问属性的描述符可能有如下组成： get – 无参数函数，当属性被读取时被调用 set – 单参数函数，当属性被设置时被调用 enumerable – 与数据属性一致 configurable – 与数据属性一致 访问属性的 getter/setter 可以直接使用字面量声明（如上面的代码片段 2 所示），也可以使用 Object.defineProperty，如下：1234567891011121314// 代码片段 5const user = &#123; name: 'Bill', surname: 'Gates'&#125;;Object.defineProperty(user, 'fullname', &#123; get() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set(value) &#123; [this.name, this.surname] = value.split(','); &#125;&#125;) getter/setter 应用使用 get 和 set 访问属性描述符，我们可以更加灵活控制属性的读写行为。比如对于 user 对象而言，可以限制 name 的长度：12345678910111213// 代码片段 6const user = &#123; get name() &#123; return this._name; &#125;, set name(value) &#123; if (value.length &gt; 4) &#123; alert('用户名长度不能超过 4 位'); return; &#125; this._name = value; // 这里使用 this._name 是一种广泛的通用约定 &#125;&#125; 数据属性或访问属性需要注意的是，一个属性要么是数据属性，要么是访问属性，不能两者皆是。相应地，如果同时给属性设置 value 和 get 这 2 个 flag 会报错。123456789// 代码片段 7// Error: Invalid property descriptor. Cannot both specify accessors and a value or writable attributeObject.defineProperty(&#123;&#125;, 'prop', &#123; get() &#123; return 1 &#125;, value: 1&#125;); 参考链接 ES6 入门 - 阮一峰 Modern Javascript Tutorial]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么 0.1 + 0.2 !== 0.3]]></title>
    <url>%2Fpassages%2F%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3%2F</url>
    <content type="text"><![CDATA[JavaScript 中的数字以 64 位浮点数的格式表示，遵从IEEE 754-1985这一用二进制表示数字的工业标准。其中的 52 位用于分数部分，即存储精度；11 位用于指数部分，即表示小数点的位置；1 位用于符号位，表示正负。如下图所示： 对于 64 位双精度数字而言，维基百科上给出了如下信息： Width: 64 bits Range at full precision: ±2.23×10e308 to ±1.80×10e308 Precision: Approximately 16 decimal digits 即在保证精度不丢失的前提下，64 位浮点数最多能表示 16 位的十进制数，超出这一限制则导致精度丢失。回到标题抛出的问题：0.1 + 0.2 !== 0.3，我们可以试着运行以下代码： 123456console.log((0.1).toFixed(16))// 0.1000000000000000console.log((0.1).toFixed(17))// 0.10000000000000001console.log((0.1).toFixed(20))// 0.10000000000000000555 这进一步说明超过 16 位的十进制数，使用 64 位浮点数的二进制表示会产生精度丢失。与此同时，我们注意到：十进制数 0.1 是无法用二进制来精确表示的，这正如 1 / 3 无法在十进制下用有限位数来精确表示，是一样的道理。这里引出了一个问题，什么样的数字在十进制下无法精确表示？什么样的数字在二进制下无法精确表示？ 个人对进制的思考进制即进位计数制，十进制即逢十进一，二进制即逢二进一，N 进制即逢 N 进一；从相反的一面来看，N 也是基数，即在 N 进制下如果要产生小数，便是用 N 为基数去分割。为了方便说明，这里以十进制为例。在十进制下，要产生可以精确表示的小数就是用基数 10 去分割，所以 1 / 10 是可以精确表示的，又由于 10 本身并非素数，可以由 2 x 5 得来，所以十进制下，只有分母表述成如下方式的小数才能精确表示： 122 ** x * 5 ** y// x 和 y 为 非负整数 考虑常见的 1 / 2 到 1 / 10: 1234567891 / 2 -&gt; 2**1 * 5**01 / 3 -&gt; fail1 / 4 -&gt; 2**2 * 5**01 / 5 -&gt; 2**0 * 5**11 / 6 -&gt; fail1 / 7 -&gt; fail1 / 8 -&gt; 2**3 * 5**01 / 9 -&gt; fail1 / 10 -&gt; 2**1 * 5**1 引申到二进制的环境下，只有分母表述成如下方式的二进制小数才能精确表示： 122 ** x// x 为非负整数 所以对于十进制数 0.1, 0.2, 0.3都无法用二进制来精确表示，当两个数字求和时，它们丢失的精度会加起来，这便是 0.1 + 0.2 !== 0.3 的原因。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>精度丢失</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Bash 常用命令集锦]]></title>
    <url>%2Fpassages%2FGit%20Bash%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[Git Bash 是将 GNU 开源软件下的命令移植到了 Windows 下面。同时不仅可以使用大部分常用的 linux shell 命令，也集成了部分 Windows 下的命令。比如显示当前目录下的文件和文件夹，ls以及dir都是可用的。下面列出了我在 linux shell 下的常用命令。 路径查找和切换1234567891011121314151617181920212223242526pwd# print working directory, 打印当前工作目录ls# list,查看当前目录下的文件，不包括隐藏文件，仅显示文件名称ls -a# list all, 查看当前目录下的所有文件，包括隐藏文件ll(ls -l)# 查看当前目录下的文件详细信息，包括时间、读写权限等cd &lt;path&gt;# change directory, 改变目录，后面尖括号内是目标目录的路径cd# 当不加参数时，跳转到设定的默认启动目录cd ~# 在 Linux 下面，~ 表示当前用户账户的根目录cd ..# 跳转到上一级目录cd ./project/static# 跳转到当前目录的下一级目录project/static 文件操作类123456789101112131415161718192021222324252627rm path/to/file.ext# remove,删除 path/to 目录下的 file.ext 文件，注意： rm 命令只能用于删除文件rm -r path/to/folder# 删除 path/to/folder 文件夹， -r 必须要加，表示 recursive,即递归的删除rm -rf path/to/folder# rm -r -f path/to/folder# 删除 path/to/folder 文件夹，-f 表示 force，即强制删除mv path/to/file.ext different/path/file.ext# move,移动文件mv old-filename.ext new-filename.ext# mv 命令同样可以用来重命名文件cp file-to-copy.ext# copy,复制文件mkdir new-folder# make directory,新建文件夹touch file.ext# 新建文件，默认在当前目录touch path/to/file.ext# 在指定的目录下新建文件 产生输入类12345678echo text-will-be-echo# echo 的意思是回音，这条指令相当于打开了一条读写流echo text-will-be-written-to-file &gt; file.ext# 将内容写入到文件中，后面写入的内容将覆盖之前的内容echo text-will-be-written-to-file &gt;&gt; file.ext# 将内容写入到文件中，后面写入的内容将追加到之前的内容末尾 产生输出类1234567cat file.ext# 查看文件内容，一次性显示全部内容。less file.ext# 查看文件内容，显示当前命令行窗口可以展示的内容。# 接着每按下一次 回车键 ，继续显示一行信息。# 按下空格键显示下一页信息，按下 b 键显示上一页信息，按下 q 键退出显示。 网络类1234curl name=bill&amp;age=18 https://example.com:8080# 发送 GET 请求到 https://example.com:8080,第二个参数是可选的 GET 请求参数curl -d name=bill&amp;age=18 https://example.com:8080# 发送 POST 请求到 https://example.com:8080,这里的 -d 表示的 POST 请求,第三个参数是可选的 POST 请求参数 增强开发体验类123456789101112131415clear# 清屏alias# 别名，相当于给一个命令设置快捷方式。比如 alias ll='ls -l'Tab 键位# 神奇的键位，在命令行主要用作自动补全，比如自动补全路径Arrow 键位# 命令行保存了你之前输入过的命令，上下箭头分别向前和向后显示你输入过的命令Ctrl 键位# Ctrl + A 将光标定位到当前行的开头， Ctrl + E 将光标定位到当前行的末尾# 在 Windows下，你也可以用 Home键 和 End键 实现相同功能 其他参考链接Linux Commands 集合]]></content>
      <tags>
        <tag>Git Bash</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['=='与'===']]></title>
    <url>%2Fpassages%2F%E2%80%98%3D%3D%E2%80%99%E4%B8%8E'%3D%3D%3D'%2F</url>
    <content type="text"><![CDATA[JavaScript 中有两个用于判断两个值相等的符号：== 和 === 。分两种情况来考虑：基本数据类型和对象。 基本数据类型对于基本数据类型而言，=== 直接比较两个基本数据类型的值是否相等，不做类型转换，== 会试图进行类型转换再比较。 123456789101112131415const s1 = '1'const s2 = '1'const n1 = 1const n2 = 1.0const b = trueconsole.log(s1 === s2) // trueconsole.log(s1 === n1) // falseconsole.log(s1 == n1) // trueconsole.log(n1 === n2) // trueconsole.log(n1 === b) // falseconsole.log(s1 == b) // trueconsole.log(n1 == b) // true 对象对于对象而言， == 和 === 效果完全一样，都是用于判断两个对象是否是同一个对象。 1234567const o1 = &#123;&#125;const o2 = &#123;&#125;const o3 = o1 // 此时 o1 和 o3 指向堆内存中的同一个对象console.log(o1 == o2) // falseconsole.log(o1 === o2) // falseconsole.log(o1 === o3) // true 总结对于对象而言，== 和 === 效果是一样的，而且是比较两个对象变量是否指向内存中的同一块区域。对于基本数据类型而言，== 在面对两个不同类型的数据时，会试图进行类型转换再比较，而===则不会，直接比较值是否相等。 图片测试]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>宽松相等与严格相等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的求值策略]]></title>
    <url>%2Fpassages%2FJavaScript%20%E4%B8%AD%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[计算机科学中有个概念，叫做求值策略 Evaluation Strategy。它决定了变量之间，函数的实参与形参之间，值是如何传递的。求值策略主要有以下两种：按值传递和按引用传递。 按值传递与按引用传递 按值传递（call by value）是最常用的求值策略，函数的形参是被调用时函数实参的副本，修改函数的形参不会影响实参。 按引用传递（call by reference）是另一种求值策略，函数的形参是被调用时函数实参的隐式引用，不再是函数实参的副本，修改函数的形参会相应地影响到实参，因为函数实参传递给函数形参是引用本身。 按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的 BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。首先明确一点，在 JavaScript 中，不存在按引用传递。那么，是不是 JavaScript 中，变量之间，函数形参与实参之间都是按值传递呢？这是一个有些争议的问题，可以近似认为，JavaScript 中的值都是按值传递。下面分基本类型的值和引用类型的值两种情况来看。 基本类型的值对于基本类型的值，情况非常简单清晰，考虑以下代码： 12345678// 示例1let name = 'Bill'const f = function(name) &#123; name = 'Sunny'&#125;f(name)console.log(name) // Bill 上面代码说明，基本类型按照值传递，函数实参只是函数形参的一个副本。也就是说，函数被调用时，引擎会分配一块新的内存来存放从函数实参复制来的函数形参，所以接下来函数内部对形参所做的所有操作都是基于这块新的内存，函数实参自然不会受到影响。 引用类型的值对于引用类型的值，也就是对象，情况有些不一样。考虑以下代码： 12345678910// 示例2let user = &#123; name: 'Bill'&#125;const f = function(user) &#123; user.name = 'Sunny'&#125;f(user)console.log(user.name) // Sunny 上面的代码说明，传入的对象 user 被函数 f 改变了，那么是否说明对于引用类型的值，是按照引用传递的吗？再考虑以下代码： 12345678910111213// 示例3let user = &#123; name: 'Bill'&#125;const f = function(user) &#123; user = &#123; name: 'Sunny' &#125; // user = null, 结果一样&#125;f(user)console.log(user.name) // Bill 如果 JavaScript 中的对象确实是按引用传递，传入的对象 user 的指向将被改变，那么上面代码最后一行应该打印 Sunny 。然而，实际打印出的仍然是 Bill ，这说明 JavaScript 中对象的值也不是按照引用传递的。事实上，对于对象而言，JavaScript 中函数实参传递给函数形参的是对象地址的一个副本，此时函数实参和形参都指向内存中同一块区域。所以在示例 2 中，修改 user.name 的值才会影响到原 user 对象。 总结对于这种求值策略，一种观点认为本质上仍然是按值传递，另一种观点认为是按共享传递。叫什么术语其实不重要，重要是理解其内在机制，即调用函数传参时，函数实参传递给函数形参的，是对象的内存地址的副本，既不是按值传递的对象副本，也不是按引用传递的内存地址本身。 参考链接Evaluation Strategy Call by value Call by reference Call by sharing http://dmitrysoshnikov.com/-Evaluation Strategy http://www.cnblogs.com/bosnma/p/4256108.html]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>求值策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源政策与跨域问题]]></title>
    <url>%2Fpassages%2F%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同源政策与跨域问题什么是浏览器的同源政策？维基百科对同源政策的定义。简单来说，为了保护用户的数据安全，浏览器规定，对于不同源的网页，它们之间以下的资源交互行为是被禁止的： 持久化数据无法获取，包括 Cookie, LocakStorage, IndexDB DOM 无法获取 AJAX 请求不能发送 仔细想想，以上 3 种行为对于用户安全来说，都是非常危险的。持久化数据通常含有用户的身份信息、登录态信息；至于 DOM 和 AJAX 这两者的权限都可能导致网页被植入恶意代码。 同源的严格定义如果说两个网页同源，是指以下 3 个部分都相同： 协议 主机 端口 举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是 80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 不受同源政策限制的资源交互行为需要明确的一点是，同源政策对于 HTML 标签是没有限制的，这使得网页可以从远程服务器获取资源文件，主要有以下标签： script 标签用来获取远程脚本文件，JSONP 跨域方式就是利用了这一点 link 标签用来获取远程 CSS 文件 image 标签用来获取远程图片文件 audio 标签用来获取远程音频文件 video 标签用来获取远程视频文件 如何规避同源政策来实现数据获取？在实际开发中，需要突破同源政策的限制来获取数据，主要是在使用 AJAX 向非同源服务器发送请求的场合。主要使用下面的几种方式来规避同源政策获取数据： 跨域资源共享 JSONP 服务器代理转发 跨文档通信 Cross-document messaging。这是 HTML5 为了解决跨文档通信引入的新 API：window.postMessage，但是这种方式能获取的内容是作了严格限制的，原因仍然是出于安全考虑。 WebSocket 跨域资源共享即 Cross-Origin Resource Sharing。这是一个很大的话题，而且基本由后端实现 CORS 的支持，详情见参考链接 3 和 4，两篇文章讲的非常清晰。 JSONPJSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script') script.setAttribute('type', 'text/javascript') script.src = src document.body.appendChild(script)&#125;window.onload = function() &#123; addScriptTag('http://example.com/ip?callback=foo')&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip)&#125; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; ip: '8.8.8.8'&#125;) 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。此外， JSONP 的方式仅限于 GET 方法的网络请求。 架设代理服务器，转发请求架设一个同源的服务器，浏览器向该同源服务器发送 AJAX 请求，再由该服务器转发请求到外部非同源服务器。 跨文档通信WebSocket参考链接 同源政策及其规避方法 Same-origin policy 跨域资源共享 CORS 详解 - 阮一峰 CORS - MDN]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>同源政策</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活美学大师的 5 个锦囊]]></title>
    <url>%2Fpassages%2F%E7%94%9F%E6%B4%BB%E7%BE%8E%E5%AD%A6%E5%A4%A7%E5%B8%88%E7%9A%84%205%20%E4%B8%AA%E9%94%A6%E5%9B%8A%2F</url>
    <content type="text"><![CDATA[生活美学大师的 5 个锦囊，让你告别无趣的生活. 给事物排名的乐趣 每年给自己的屋子做点改变 第二天感恩 附身的魔力 看看大街上的镜子 给身边的事物排名不仅可以提升生活的乐趣，还能提升你的观察能力，总结分析能力。这种做法不是为了争强好胜，而是为了给生活加点调料，增加乐趣。比如，你可以尝试自己的排名。身边的十大美食，十大书籍，十大电影，十大当地景点等。 每年给自己的屋子做点改变在阳台上加一盆自己喜爱的盆栽也是一点改变. 第二天感恩第二天感恩是一个泛指，别人给你推荐了一本好书，或者旅行回来给你带了点小零食，在过了几天或一段时间后，你觉得不错甚至受益匪浅，那么要把这份美好的心情和感激告诉别人。这同时可以增加我们自己的生活乐趣，维持一种好的社交氛围。 附身的魔力有一个人以前一直害怕坐飞机，后来每次坐飞机都将自己想象成飞行员，以此来克服恐惧心理。 看看大街上的镜子在街上，通过车窗玻璃，商场镜子等，不时的照照镜子，给自己一个正面、积极的心理暗示。 书籍：《非常非常好》作者：松浦弥太郎]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass 快速入门]]></title>
    <url>%2Fpassages%2FSass%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Sass 快速入门What is Sass?Sass 是 CSS 的一个扩展，它使得 CSS 的使用更加优雅和强大 Why Sass?Sass 的以下特性使得 Sass 成为一个成熟、稳定、强大的 CSS 扩展语言解析器。 变量变量声明在 Sass 中，使用 $ 前缀符号来表明这是一个变量。同时，变量是存在作用域的。 123456789101112$highlight-color: #f90;nav &#123; $width: 100px; width: $width; color: $highlight-color;&#125;/* 编译后 */nav &#123; width: 100px; color: #f90;&#125; 变量引用变量可以引用另一个变量 1234$highlight-color: #f90;.selected &#123; bodrer: 1px solid $highlight-color;&#125; CSS 规则嵌套选择器嵌套1234567891011121314151617181920212223242526272829/* sass */#content &#123; background: #555; article &#123; h1 &#123; color: #333; &#125; p &#123; margin-bottom: 1.4em; &#125; &#125; aside &#123; background: #eee; &#125;&#125;/* 编译后 */#content &#123; background: #555;&#125;#content article h1 &#123; color: #333;&#125;#content article p &#123; margin-bottom: 1.4em;&#125;#content aside &#123; background: #eee;&#125; 父选择器的标识符&amp;Sass 提供父选择器的标识符 &amp; 主要是为了解决例如 :hover 等伪类的特殊情况。考虑下面这个情况： 1234567891011121314article a &#123; color: blue; :hover &#123; color: red; &#125;&#125;/* 编译后，这与我们预期不符 */article a &#123; color: blue;&#125;article a :hover &#123; color: red;&#125; 使用父选择器的标识符 &amp; 可以解决这个情况，&amp; 指代父选择器本身。 1234567891011121314article a &#123; color: blue; &amp;:hover &#123; color: red; &#125;&#125;/* 编译后 */article a &#123; color: blue;&#125;article a:hover &#123; color: red;&#125; 群组选择器的嵌套12345678910111213141516171819202122232425/* sass */.container &#123; h1, h2, h3 &#123; margin-bottom: 0.8em; &#125;&#125;nav,aside &#123; a &#123; color: blue; &#125;&#125;/* 编译后的css */.container h1,.container h2,.container h3 &#123; margin-bottom: 0.8em;&#125;nav a,aside a &#123; color: blue;&#125; 属性嵌套123456789101112131415/* sass */nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125;/* 编译后的css */nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125; 属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。 导入在原生 CSS 中，有一个不常用的特性是 @import 规则，它允许在 .css 文件中导入其他的 .css 文件，但是这种导入的运行机制是：只有当执行到@import 语句时，浏览器才会去下载指定导入的 .css 文件，这导致页面加载起来会特别慢。 Sass 中实现的 @import 规则在生成 .css 文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个 CSS 文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。 嵌套导入12345678910/* blue-theme.scss文件 */aside &#123; color: blue; background: white;&#125;/* base.css文件 */.blue-theme &#123; @import 'blue-theme';&#125; 静默注释CSS 的标准注释会被保存在网页内，大多数时候这不是我们想要的结果。Sass 提供了另一种类似 C 语言风格的注释，称之为静默注释，因为这类注释不会被保存在网页内，即浏览网页的用户看不到它们。 123456body &#123; color: #999; /* 这是CSS的标准注释 */ background: white; // 这是Sass提供的静默注释&#125; 混合器 mixinSass 提供了混合器来实现多组样式规则的复用。比如下面定义了一个简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后你可以使用 @include 来使用混合器： 1234567891011121314.notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass 最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 何时使用混合器利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式（严谨的描述是：几条样式规则），那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。 判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个简洁的名字来描述这些属性修饰的样式，比如 rounded-corners, fancy-font, 或者 no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。 混合器在某些方面跟 CSS 类选择器很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在 html 文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述 html 元素的含义而不是 html 元素的外观。而另一方面，混合器是展示性的描述，用来描述一条 CSS 规则应用之后会产生怎样的效果。 在之前的例子中，.notice 是一个有语义的类名。如果一个 html 元素有一个 notice 的类名，就表明了这个 html 元素的用途：向用户展示提醒信息。rounded-corners 混合器是展示性的，它描述了包含它的 CSS 规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用可以写出整洁的 HTML 和 CSS，因为使用语义化的类名也可以帮你避免重复使用混合器。为了保持你的 HTML 和 CSS 的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 有时候仅仅把属性放在混合器中还远远不够，可喜的是，Sass 同样允许你把 CSS 规则放在混合器中。 混合器中的 CSS 规则混合器中不仅可以包含属性，也可以包含 CSS 规则，即包含选择器和选择器中的属性： 123456789101112131415161718192021222324252627// 定义一个混合器@mixin no-bullets &#123; list-style: none; li &#123; list-style-type: none; list-style-image: none; margin-left: 0; &#125;&#125;// 引用这个混合器ul.plain &#123; color: #444; @include no-bullets;&#125;// 编译后的 cssul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-type: none; list-style-image: none; margin-left: 0;&#125; 给混合器传参数，定制样式当 @include 混合器时，参数其实就是可以赋值给 CSS 属性值的变量。如果你写过 JavaScript，这种方式跟 JavaScrip t 的 function 很像： 123456789101112131415161718192021222324252627@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;// 引入混合器a &#123; @include link-colors(blue, red, green);&#125;// 编译后的CSSa &#123; color: blue;&#125;a:hover &#123; color: red;&#125;a:visited &#123; color: green;&#125; 给混合器设置默认参数值为了在 @include 混合器时不必传入所有的参数值，可以给参数指定一个默认值。这个默认值可以是任何有效的 CSS 属性值，甚至是其他参数的引用。比如： 12345678910111213141516171819202122232425262728293031// 定义指定参数默认值的混合器// 类似JavaScript中的函数@mixin link-colors($normal, $hover: $normal, $visited: gray) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;// 引用混合器a &#123; @include link-colors(red);&#125;// 编译后的CSSa &#123; color: red;&#125;a:hover &#123; color: red;&#125;a:visited &#123; color: gray;&#125; 选择器的继承选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过 @extend 语法实现，如下代码: 123456789.error &#123; border: 1px red; background-color: #fdd;&#125;.serious-error &#123; extend .error; border-width: 3px;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于写日记]]></title>
    <url>%2Fpassages%2F%E5%85%B3%E4%BA%8E%E5%86%99%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘录一篇关于写日志的文章。 写日记是可以加快你的个人成长速度的最简单而又最强大的工具之一。把你头脑中的想法写出来，能让你得到不这样做所无法获得另一种看待事物的视角。 超越你的思维极限虽然你的大脑可以同时处理许多信息，但你清醒地思考时却做不到。思绪是一个接着一个出现的，是一个序列。一个想法激发下一个想法，如此往复。有时这些序列会产生一些分支，但它们仍然受时间线的限制，在任何给定的时刻，你都追随着这些分支思绪中的一个。这些思绪序列都有一个开始，一个发展，和一个结束，当你陷在一个思绪系列中重复回想这些想法时，要想理清思路是近乎不可能的。 在这个方面，写日记便能给你提供巨大的便利。写日记可以让你从思维序列中解放出来，让你以一个鸟瞰你的想法的视角去审视你的想法。当把你的序列思维复制在一种有形的介质中，你就可以回过头来以一个旁观者的身份回顾这些想法。但当你在复制这些想法时，你仍处于第一人称模式之中。而当你回顾它们的时候，你就能以客观的而非主观的视角看待它们。这种客观的视角，再加上你从主观视角中学到的东西，能让你更进一步地看清你所面对的处境。 写日记的其他好处下面是写日记的另外 3 种好处： 解决棘手的问题当你陷在一种主观的，第一人称的视角时，一些问题是很难得以解决的。只有当你将情景复制下来，然后从一个旁观者的角度重新审视问题时，解决方案才能变得清晰明了。有时问题的解决方法是如此显而易见，以至于连你自己也会为自己当初没有及时想到而感到震惊。 理清思路当你思绪混乱，不知该做什么的时候，是非常适合写日记的。你该辞职还是创业？你该和你的现任男/女朋友结婚吗？当你把这些问题写下来，然后再去思考，你对事情就会更有把握。 见证你的进步翻出几年前写的日记，看看自己这几年来取得的实质性的进步，是一件无比美妙的事。当你感到沮丧，看不到对明天的希望时，就翻出你在几年前写的日记——这能彻底改变你的观点。即便在你感觉自己似乎在原地踏步的时候，这也能帮助你意识到你其实正在进步、正在改变。 虽然一些人写日记用来记录生活中的一些事情，但我一般都不写这样的日记，而且我甚至很少回头去看过去写的日记。对我来说，写日记主要是一个解决问题的工具，一种帮助我面对复杂的问题时理清思路的方法。我每月平均会写 5-10 篇日记，我通常会以一个提问或一个我想要解决的问题开始一篇新的日记。然后我就会去探索解决问题的可能方案。有时这些问题是非常简单的，如“下一篇文章我该选择什么主题？”其它时候我会探索更广泛的内容，如“2015 我想去哪里？为了做到这一点我现在就要开始/停止去做的事情有哪些？”有时我会天马行空地写下所有可能的解决方案；有时我会写下一个问题，然后从不同的角度思考它，希望更全面地理解这个问题。例如，我会问自己，“爱因斯坦会怎样解决这个问题？达·芬奇？”或者，我会问自己，“这个问题的积极面是什么？我要怎么做就可以不必解决这个问题？这个问题的最优解决方案一定要具备什么？” 我发现，像这样的练习是非常有价值的。当我想尝试解决一个问题的时候，如果它是一个简单的问题，我通常只要好好思索一番就能够解决它；但面对更加复杂的问题时，大多数想要把问题想明白的尝试都以失败告终。要么我根本就没有找到一个满意的解决方案，要么我对这个问题缺乏全面的理解而对我找到的解决方法没有把握，或者有的时候我找到了一个满意的解决方法，但睡了一个晚上之后再去看它时却觉得它不那么可行。所以在面对那些重大的、复杂的问题的时候，我不会光在脑子里思考，我会把它们写下来。思维往往会定型，我们的大脑总有一种想要下定论的趋势；例如，我们总是按照事物的模式对其进行分类，来达到简化问题的目的。但是，有的时候我们不可以过早的将一个问题简化为我们以前解决的某个问题，我们还要考虑产生这个问题的新的因素，这是非常重要的。例如，如果你管理着一个公司，发现你们的销售业绩有暂时下降的趋势，像这样的问题以前也发生过，也被你们解决过，但你仍然有必要考虑引发这个问题的新的因素，而不是套用过去的解决方法。 将问题写在纸上加以探索，我就可以避免定性思维，而且这也能让我更容易地发现存在于可能的解决方案中的尚未被考虑到的因素。当我在纸上从某一个特地的角度探索某一个问题，写完之后我就可以先放下它，然后从另一个角度去考察它。因为我把它们都写在纸上，而且又是从不同的角度去思考的，所以我总是可以非常容易地看到这个问题的各个侧面，这能帮助我作出明智的决定。所以从本质上来说，写日记帮助我克服了思维上的局限性，允许我更全面地考察待解决的问题。 一些问题超出了我们所能理解的范围，我们只能够对这些问题的一小部分进行思索。我们的大脑非常强大，但我们的心智在处理多个并发的想法时仍然显得很有局限性。例如，你可以闭上眼睛然后想象一棵苹果树，但你可以从一百个不同的角度同时想象出这棵苹果树的样子吗？即便是一个非常简单问题，如“晚餐吃什么？”也足以让我们犹豫一番。要想作出一个最好的决定，我们就必须把所有我们可能会在晚餐时吃的食物都考虑一遍，并对它们的口味、营养价值、价格等进行排序。面对这个相对而言非常简单的决定，我们可能会有三至四个选择，然后再从中选择最好的一个。但假如我们所面对的是一个更加重大，能带来更深远影响的决定，那我们对我们所作出的决定是否接近于最优决定抱有信心就显得更加重要了。生活中充满了这样的选择。我该选择哪一条职业道路？我该在哪里生活？我该离婚还是保持这段不快乐的婚姻？这些都是可以改变人生的决定。你当然可以随意地、不假思索作出一个决定，但你一定是承担后果的那一个人。 即便是写日记也无法克服我们心智上的主要极限——系统地思考成千上万种可能的解决方案——但写日记至少是我们朝着正确的方向迈出的一小步。我们仍然要把我们制定决策时的大部分工作交给我们的潜意识，直觉和情绪。但我们进行这个练习——将纸或电脑屏幕作为我们的意识的延伸——的次数越多，我们就可以更清晰、更有把握地确定最适合我们的决定。而且从长期来看，坚持锻炼我们的心智并作出更清醒的决定，我们就能够收获更美好的结果。 写日志要遵守的条件写日记必须遵守的三个条件 ：一是坚持，尤其开始时每天都写，来不及就第二天补写，绝不偷懒，这样才能形成为习惯。二是感悟，感触要仔细写，努力寻找确切的表达，绝不马虎，绝不敷衍。三是坦诚，不给人看，这样在写日记时才能坦然面对自己，句句都写真心话。]]></content>
      <tags>
        <tag>百科知识</tag>
        <tag>生活</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活要有不较劲的智慧]]></title>
    <url>%2Fpassages%2F%E7%94%9F%E6%B4%BB%E8%A6%81%E6%9C%89%E4%B8%8D%E8%BE%83%E5%8A%B2%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[昨天，在网易云音乐的电台上听到一篇周国平的文章，《生活要有不较劲的智慧》，觉得很有意思。其中很多观点我也深以为然。 他提出了一个也许并不新奇的观点：人生的三大意义。我想这兴许不是他独创，古今中外，无数哲人可能都思考过类似的问题。人生的第一重意义：世俗的意义，即幸福。人生的第二重意义：精神的意义，即道德。人生的第三重意义：也是终极意义，即死亡。 昨天的这篇文章里，周国平主要谈了人生的第一重意义：幸福。在世俗的生活里，人的一切行为都指向一个目标—幸福。那么，什么是幸福？两种观点，快乐主义和完善主义。 快乐主义，追求身体无痛苦，灵魂无烦恼。中国的道家就接近于快乐主义。这种观点认为，幸福本应当是简单纯粹的，身体和灵魂都应保持简单，拥有持久的活力。庄子的《养生》和《逍遥游》都表达了类似的人生态度。 完善主义，讲究世俗生活应追求简单，而精神世界要保持丰富。即提倡后天培养属于自己的精神家园，孔子的思想是接近完善主义的代表。 说起自己的幸福，周国平回忆道：他的人生中，有两段时光最是幸福。一是刚进大学时，少年人情窦初开，周围有许多漂亮的女同学，只要有一个女同学对他微笑，他晚上回去都要写上不少情书，这是初尝幸福的滋味；二是初为人父，女儿出生的时候。 听完这段，我不由自主的回忆起自己这近三十载人生，有哪段时光让我尝到了幸福的滋味呢？细想下来，大致和周国平的两段时光一致。我想，像我这种性格偏内向，农村出生的男孩子，说起幸福的时光，大致也是这两段时期吧。我这么说，主要是出于精神生活的考量，而非物质生活。幸福是需要人的主观意识去感知的，农村的内向孩子，大多心智晚熟，物质匮乏本身倒无大碍，但是由此导致的精神生活的缺位，却大大影响了孩子的意识觉醒。所以，回忆起童年的时光，要说基本无忧无虑，我没有异议，但是说到幸福，我却不以为然。童年对于我，只是一段意识尚未完全觉醒，懵懂，简单的时光，与幸福无关。 情窦初开的年纪，那种男女间懵懂的情愫，是荷尔蒙带来的幸福。近而立之年，主观意识已经觉醒，初为人父的我，真切地尝到了幸福的滋味。我的宝贝女儿窈窈，到今天已经 58 天了。她的一颦一笑都那么可爱，惹人怜爱。这个新生命牵动着全家人的神经。 上面谈到的是感知到的幸福，那么如何追求幸福呢？简单来说，觅得一个相爱的伴侣，组成一个和谐温馨的家庭，有三两个真挚的好友，做自己喜欢做的事业，过着不至于奢侈但还算富足的日子，这便足矣。然而，以上几点都不是那么容易达成。相爱的伴侣不仅需要机缘，需要你自身有进取心，有变得优秀的潜力和决心，还需要你修身养性，与人为善，有生活的智慧。不然，你如何承诺你的伴侣共建一个美好的家庭呢？你又如何吸引到真挚、优秀的良师益友呢？可见，首先要修炼好自身。至于事业，有一句话说的切中要害，让自己的能力在一个领域里得到最好的施展，那这个领域就是你的事业。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习编程的心态辅导]]></title>
    <url>%2Fpassages%2F%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BF%83%E6%80%81%E8%BE%85%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[当你选择学习编程，你的业余时间都会被它所占据，随着学习曲线逐渐变陡，你会感到枯燥、迷茫、自卑以及脑汁耗竭的痛苦。这是非常正常的。许多人在学习一门新技术时，都会遇到类似问题。对此，我个人的解决办法有： 找点乐子当你看完基础语法，对继续往下挖掘感到枯燥时，别勉强自己，翻翻书本，找一些有趣的练习题练练手，或者编写、修改一些简单有趣的小项目，跟你朋友讲你学到的新内容，给自己找点成就感。 专注在当前的学习目标上没有技术背景的人，学习编程容易被复杂的技术体系吓到，网上经常会出现“一定要读这本书”、“最好先有 XX 基础再看这篇教程”之类的警告，结果常会出现这种情况：本来你只打算学编写网页 ，结果却开始苦读《精通正则表达式》。 别担心，你无需掌握所有分支，很多时候，你只要知道在需要某个知识点时，能从这类教程中找到对应用法即可。 习惯无知无论学习什么，往往越深入就觉得自己无知。这并不是坏事，它能让你保持谦虚，但千万不要被吓得不敢继续前进。 觉得写出来的代码不忍直视？正常，因为你看过的例子和学到的知识增进了你的眼界，但编程技能和思想需要在练习中成长，所以千万不要因此而自卑，继续尝试，相信自己。 注意休息人的认知能力是会随着时间流逝而耗竭的，别逞能，站起来走动走动，呼吸一下新鲜空气吧！]]></content>
      <tags>
        <tag>学习方法</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出差及旅游注意事项]]></title>
    <url>%2Fpassages%2F%E5%87%BA%E5%B7%AE%E5%8F%8A%E6%97%85%E6%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[以下是我在若干次出差及旅游亲身经历中简单归纳出的一些建议: 防被坑类 不要住在火车站和高铁站附近的酒店或者宾馆。这些酒店由于地理位置有优势，通常高价低质，服务差。 在旅游区，不要做任何没有第三方担保的交易。 不要相信任何口头承诺，因为合同都不一定能执行，更遑论口头承诺。 景区的导游、出差地点的出租车司机带你去的饭馆和特产店等，极大可能存在利益关系。 生活细节类 提前了解景区或者目的地未来几天的天气，根据需要带好：防晒霜、保湿露、花露水。 带好自己的清洁个护用品，包括牙刷、牙膏、卫生纸等。 不要试图在高铁站、火车站、机场等人流量极大的地方上大厕，因为坑位太紧张，几乎等不到。尽量在酒店提前做好排便。 带几个袋子，用于收纳穿过的衣服和袜子。 带一个有盖子的水杯，如果是冬天可以带保温杯。机场、火车站等地方一般都有开水供应。 如果是出差需要报销车票，在乘车前就去自动售票机打印报销凭证，否则之后需要专门再跑一趟到高铁站自助打印。]]></content>
      <tags>
        <tag>设计</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
