<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优化博客的网页性能]]></title>
    <url>%2Fpassages%2F%E4%BC%98%E5%8C%96%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[未优化前的性能指标使用 Google 的 PageSpeed Insights 评估，移动设备得分：91，各项指标如下： 指标 时间（估算值） 首次内容绘制时间 1.9 秒 速度指数 3.5 秒 可交互前的耗时 3.6 秒 首次有效绘制时间 3.0 秒 首次 CPU 闲置时间 3.4 秒 输入延迟（估算值） 30 毫秒 优化建议这些优化建议可以加快网页加载速度。 优化建议 有望节省的总时间（估算值） 1. 适当调整图片大小 4.05 s 2. 采用新一代格式提供图片 2.4 s 3. 移除阻塞渲染的资源 0.93 s 4. 移除未使用的 CSS 0.3 s 使用 gulp 压缩 html, css, js 等gulp 让你用代码实现一组任务的串行或者并行执行。 一个典型的 gulpfile.js 可能是这样的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const &#123; src, dest, parallel &#125; = require('gulp')const minifycss = require('gulp-minify-css')const uglify = require('gulp-uglify')const htmlmin = require('gulp-htmlmin')const htmlclean = require('gulp-htmlclean')const imagemin = require('gulp-imagemin')const minifyHtml = () =&gt; src('./public/**/*.html') .pipe(htmlclean()) .pipe( htmlmin(&#123; removeComments: true, minifyCSS: true, minifyURLs: true, minifyJS: true &#125;) ) .pipe(dest('./public'))const minifyCss = () =&gt; src('./public/**/*.css') .pipe( minifycss(&#123; compatibility: 'ie8' &#125;) ) .pipe(dest('./public'))const minifyJs = () =&gt; src('./public/**/*.js') .pipe(uglify()) .pipe(dest('./public'))const minifyImage = () =&gt; src('./public/images/*.*') .pipe( imagemin( [ imagemin.gifsicle(), imagemin.jpegtran(), imagemin.optipng(), imagemin.svgo() ], &#123; verbose: true &#125; ) ) .pipe(dest('./public/images'))const build = parallel(minifyHtml, minifyCss, minifyJs, minifyImage)module.exports = &#123; default: build&#125; 参考链接 PageSpeed tools - Google 分析网站的性能，展示详细的结果并给出详细的建议 Pingdom Website Speed Test Hexo performance optimizations]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 问题之居中一个元素]]></title>
    <url>%2Fpassages%2FCSS%20%E9%97%AE%E9%A2%98%E4%B9%8B%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[来自 freeCodeCamp 的 这篇文章 已经写的非常好了。 动手实践：使用 CSS 画一颗心 See the Pen heart by BillWen (@cddbysj) on CodePen.]]></content>
  </entry>
  <entry>
    <title><![CDATA[买一张木桌]]></title>
    <url>%2Fpassages%2F%E4%B9%B0%E4%B8%80%E5%BC%A0%E6%9C%A8%E6%A1%8C%2F</url>
    <content type="text"><![CDATA[如何根据自己的需求买到一张合适的木桌？ 通过抽象，桌子主要有以下三种形式： 假如人在桌子旁边： 我们来看上图，3 张桌子的间距其实是一致的，但 2 个人偶站居其中以拟人心态去体验的话，第一张桌子的预期伤害系数更低，第二第三张桌子因为来自桌面的横向张力，人类会自主的更加小心同时给出更大的避让空间。哪怕他们造成伤害的系数一致。这是人基于潜在意识里的经验，给自身的心理暗示。 3 种形式的桌子并无优劣之分，但放置在不同条件的空间里其匹配性就各有千秋了。 显而易见，第一张桌子，即四平桌，这种形式对于小户型而言更优。不管是在人的视觉感知层面还是实际空间上，四平桌都更具优势。 视觉感知：四平桌较低的视觉张力，使得人的潜意识认为行动通行空间更宽裕。 实际空间：考虑到小户型的桌子摆放位置，桌面至少有一边是靠墙的。这样四平桌的两个桌腿和一个桌面都与墙面贴合，显得更加融合、安静，实际占据的空间也确实更小。 通常来说，对于小户型而言，第一种场景是最常见也是最合适的。 另外，很多卖场、展示和体验店，都是这种四面平桌的形式，对于流动空间和展示都是最好的应用。 四腿内收与四腿不内收前面的三张桌子，代表了桌子的两大类型，四腿内收和四腿不内收。第一张桌子是四腿不内收的代表；后两张桌子都是四腿内收的代表。这2种形式在功能和工艺上各有长处。较早之前桌子四腿不内收的典型代表是四面平和八仙桌，内收的条案。国外反而几乎见不到四平桌，基本都是内收。或者至少是留一些桌面的边缘。 工艺对比： 四腿内收在基于实木材料上，实现难度更低，工艺成本也更低，精度配合要求非常低。 而以四平桌为代表的四腿不内收形式，在桌面缩胀的基础上要保持 4 面望板和 4 腿的配合都是 3 个部件的配合，工艺难度非常大。 从零到一所以，一个理想中的，剥离了所有装饰元素，最极致简约的四平卓是这样的： 然而，这样的桌子几乎无法使用。最直观的一点是，棱角过于锋利，桌子的使用者极易被磕碰到。所以有了下图： 在前面的基础上，减少器物与人体交互时动作的干涉： 围边的斜面，减少起身动作时与胸部以下躯干和服饰的刮擦； 桌腿内侧斜面去掉了 90 度棱线，以面代线与人体接触； 外侧桌面与桌腿圆角大于股骨直径，降低磕碰强度； 桌腿上宽下细，偏移受力垂直轴心，更加稳固； 以上线面的变化，无不是功能逻辑出发，并非装饰，最终在桌腿上交汇、过渡、衔接，运用车体设计的渐消锋面技法，GO-G3 级曲面结合的变化也使光影更为丰富； 桌面边缘 2.5D 曲面，使桌面边缘棱线与桌面落差 5 毫米，大于前臂真皮厚度，不会压迫皮肤和血管。 所有这些细节的设计无不是从逻辑出发，为舒适服务。 大部分家具是弱交互的器具。比如桌子，没有人为了用桌子而用桌子，一定是在桌上从事某项动作。不舒适也许会有响应，舒适反而察觉不到。如此，便是存在感的进一步弱化。 框架结构 除了入户最后装配的4条桌腿为五金链接，主体框架结构全是榫卯。 产品照 这里应该再写一些其他的东西，待补上。 然后我在天猫上的一家网红实木家具店，找到了 同款桌子。 餐桌椅目标一：铜师傅安格尔黑胡桃原木餐桌椅不得不说，小米的产品，对产品的描述做的很用心。仔细看了一番，发现有以下几点是值得注意的： 从产品图片来看，以及商品未明确指出非指接板工艺，这套黑胡桃木餐桌椅应该是使用了指接板工艺，而非长度方向或者宽度方向的大板直拼。 有关商品的选材，产品描述中只提到美国黑胡桃木，而未提及木材的分级。可以排除使用了最高级的 FAS 的可能性，较大可能采用了 1com 普通一级的木材。 以上 2 点，说明 这套餐桌椅 在选材上的成本并不是很高。不过它的工艺应该比天猫上几个网红实木家具店（源氏木语、林氏木业、原始原素、维莎等）用心可靠。 这里顺带说一下这几个实木家具网店的共同点： 在选材上，极大概率夸大了材质，比如都宣称采用北美的 FAS 级白橡木，但是根据北美相关规范的定义，餐桌直拼板的宽度明显达不到规范内的要求，普遍偏小了。 产品的宣传重点主要在两个方面：一是反复强调实木，无指接板，无人造板，无贴皮，北美白橡木和美国黑胡桃木如何优秀等；二是强调使用的木蜡油是某知名品牌，既好用又环保健康。但是对自身产品的工艺，极少提到，比如桌板与桌腿之间如何衔接固定等。具体来说，你几乎看不到一张将桌子翻过来的产品细节图。 产品设计十分单一，多是几个重复的、高度同化的爆款产品。 外部链接 设计故事 - 木桌]]></content>
  </entry>
  <entry>
    <title><![CDATA[平面设计的 4 个基本原则]]></title>
    <url>%2Fpassages%2F%E5%B9%B3%E9%9D%A2%E8%AE%BE%E8%AE%A1%E7%9A%84%204%20%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[摘录自《写给大家看的设计书》。这本书出自一位世界级设计师之手。复杂的设计原理在书中凝炼为亲密性、对齐、重复对比 4 个基本原则。作者以其简洁明快的风格，将优秀设计所必须遵循的这 4 个基本原则及其背后的原理通俗易懂地展现在读者面前。这 4 个基本原则是: 对比 Contrast 对比的基本思想是，要避免让页面上的元素太过相似。要让页面引人注目，对比通常是最重要的一个因素。 重复 Repetition 让设计中的视觉要素在整个作品中重复出现，可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片等。这样一来，既可以增加条理性，也能加强统一性。 对齐 Alignment 任何东西在页面上都不能随意安放。如果某些元素存在某种联系，那么这些元素间也应该具有视觉上的联系。这样能建立一种清晰、精巧而且清爽的外观。 亲密性 proximity 彼此相关的项应该靠近，组织在一起。如果多个项之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个孤立的元素。这有助于组织信息，减少混乱，为读者提供清晰的结构。 亲密性思想的真实含义是：如果某些元素在理解上存在关联，或者它们相互之间存在某种关系，那么这些元素在视觉上也应该存在关联。除此之外，其他孤立的元素或元素组则不应存在亲密性。位置是否靠近可以体现出元素之间是否存在关系。 书籍：《写给大家看的设计书》作者：Robin Williams]]></content>
      <tags>
        <tag>设计</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十分钟学会的小技能]]></title>
    <url>%2Fpassages%2F%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%9A%84%E5%B0%8F%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[国外的问答网站 Quora 上面有这样一个问题: What can I learn right now in just 10 minutes that could be useful for the rest of my life? 有一个回答在 Quora 获得一万多赞。以下是某位网友翻译的。 十分钟就能学会但是终生受用的技能： 人们倾向于记住最先发生的事情和最后发生的事情。中间的事情记不清楚。所以，如果你要做自我介绍的话，最好做第一个或者最后一个。面试的时候，也是一样的。 如果你在酒吧或者前台工作，在你身后放一面镜子。这样的话，当顾客发脾气的时候，就能从镜子里看到自己的丑恶嘴脸。一面镜子可以显著降低他们无理取闹的概率。 报价之后，不再说话。如果你是做销售工作的，这项技巧很有用。在其他领域，这项技巧也很有用。我之前干过一份工作，是在一家体育馆卖会员卡。有个老家伙就是这么指导我的，他说，一旦你和顾客寒暄完毕，报出了你的价格。从此时开始，先开口的那个就输了。看起来好像毫无根据，但确实是这个样子的。通常会有很长时间的尴尬沉默，但是，最终，顾客会买的。 如果你问了别人一个问题，然后他们回答了一半，你等着，他们会说完的。只要等着，保持眼神接触，最终，他们会开口讲完的。 公开讲话或者蹦极之前这种会紧张的时刻，嚼口香糖就好了。据说是因为人类在危险的时候会自动停止咀嚼（吃东西），所以吃东西的时候就是安全的，大脑就是这么告诉你的。反正这招对我很管用。 人们最终记住的不是你说过的话，而是你让他们产生的感觉。几乎所有的人都喜欢谈论自己的事情，所以，多问问题。 当你学习新东西的时候，尝试着教给朋友们，或者让他们问你相关的问题。如果你能教给人一杯水，你自己一定会有一桶水。 如果你看到某人时，很开心，溢于言表的开心，那么他们以后看到你也会手舞足蹈的。第一次也许不是这样，但第二次一定是。 身体对压力的反应——呼吸加速，心跳加快——和鼓起勇气时的反应是一样的。所以是好是歹，全在你一念之间。反正你的身体已经都准备好了，你看着办吧。 注意别人的脚。当你加入别人的谈话时，发现别人只是把上半身转过来了，脚还是维持原来的方向，那就说明他们不欢迎你的加入。类似的，你和你的同事谈话时，你觉得他在专心和你谈话，他的身体也面向你，但他的脚却不是朝向你的，他可能早就已经受不了这场谈话了。 装出牛逼的样子，直到你做到了；信心比知道更重要。别被任何人吓住，生活不易，全靠演技，那些吓你的人也在演戏。 你假装成什么样子，你最终就会成为什么样子。装逼得逼，求仁成仁，念念不忘，必有回响。 虽然不是要你去吓人，但如果你一定要厚颜无耻的盯着某人，视线聚集在他的两只眼睛中间，等着他们害羞。如果他们移开视线，他们就不会再看着你。这个时候，你就可以肆无忌惮的盯着他们的眼睛了。至少有 45 秒的时间哦。 建立人际网络。成为朋友们的信息源，当然，他们也会是你的信息源。和前同事一起喝杯酒吧，也是好的。 如果你前面的车子慢的像是老爷爷在开，你恨不得杀了他。假装他真的是你的亲爷爷。 然后你的怒气就全消了。 站得直。 不许没精打采，不许手插兜，头要高高抬起。不要觉得这是陈词滥调。你自己会因此觉得很好，而且周围的人也会感受到你的自信。 不要说“我觉得”、“我认为”，除非真的有必要。这些词语会让你和自信无缘，对你可没什么好处。 焦虑的时候，收拾一下家里或者工作桌。你会比之前更开心、更有感觉。 第一次饭，第一支酒，你请。你都不知道你自己会因此而自我感觉良好多久。 为人父母者请注意：给孩子们选择的权利，让他们认为自己掌控自己的生活。比如我想让孩子自己穿鞋的时候，我会问他“你是想穿那双星星的，还是鲨鱼的？”。值得注意的是，这招对成年人也管用。 态度决定行动，可是行动也决定态度。就像我以前的一个老师说的那样：你可以因为高兴而跳起舞来，也可以故意跳起舞来让自己高兴。 一群人在大笑的时候，人们会立刻看向这群人里最亲近的人。 如果你想和某人建立密切的关系，或者获得某人的信任，学习他的身体的姿势。 本杰明·富兰克林效应。借给别人钱的人会比欠别人钱的记得更清楚，而且会不由自主地对借贷者产生好感。调情的时候也很有用。“同学，借我一根铅笔”。或者开玩笑似的让女孩请你喝支酒。这可是一石三鸟的事情：你得到了好处；她会下意识的更喜欢你；将来她接受你的“帮助”也会更加没有负担。]]></content>
      <tags>
        <tag>百科知识</tag>
        <tag>生活</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家具木材指南之人造板篇]]></title>
    <url>%2Fpassages%2F%E5%AE%B6%E5%85%B7%E6%9C%A8%E6%9D%90%E6%8C%87%E5%8D%97%E4%B9%8B%E4%BA%BA%E9%80%A0%E6%9D%BF%E7%AF%87%2F</url>
    <content type="text"><![CDATA[人造板是以木材或其他非木材植物为原料，经一定机械加工分离成各种单元材料后，施加或不施加胶粘剂和其他添加剂胶合而成的板材或模压制品。主要包括胶合板、刨花（碎料）板、纤维板三大类产品，其延伸产品和深加工产品达上百种。人造板的诞生，标志着木材加工现代化时期的开始。此外，人造板还可提高木材的综合利用率，1立方米人造板可代替3～5立方米原木使用。 –百度百科 胶合板胶合板，LVL(Laminated Veneer Lumber)，更通用的英文用语是 Plywood。是由蒸煮软化的原木，旋切成大张的薄木片，然后使上下相邻两层木片的纤维方向相互垂直放置，用酚醛胶、脲醛胶或者三聚氰胺胶粘结，再经加压、干燥、锯边、表面修整而成的板材。其层数通常为奇数，一般为3-13层，分别称三合板、五合板等。用来制作胶合板的树种有椴木、桦木、水曲柳、榉木、色木、柳桉木等。 注意上图中，相邻木片的纹理强度方向交错胶合（顺向-亮色）（断面-暗色）。 使用胶合板代替木板的普遍原因是因为胶合板具有很强的抗破裂、抗收缩、抗扭曲和普通的高强度属性。LVL 区别于 Glulam，Glued laminated timber。 为了尽量改善天然木材各向异性的特性，使胶合板特性均匀、形状稳定，一般胶合板在结构上都要遵守两个基本原则：一是对称；二是相邻层单板纤维互相垂直。对称原则就是要求胶合板对称中心平面两侧的单板，无论木材性质、单板厚度，层数、纤维方向，含水率等，都应该互相对称。在同一张胶合板中，可以使用单一树种和厚度的单板，也可以使用不同树种和厚度的单板；但对称中心平面两侧任何两层互相对称的单板树种和厚度要一样。面背板允许不是同一树种。要使胶合板的结构同时符合以上两个基本原则，它的层数就应该是奇数。所以胶合板通常都做成三层，五层、七层等奇数层数。胶合板各层的名称是：表层单板称为表板，里层的单板称为芯板；正面的表板叫面板，背面的表板叫背板；芯板中，纤维方向与表板平行的称为长芯板或中板。在组成腔台板板坯时，面板和背板必须紧面朝外。 种类按使用途径我国新制订的国家标准(报批草案)根据胶合扳使用情况，将胶合板分为： 涂饰用胶合板 – 用于表面需要涂饰透明涂料的家具、缝纫机台板和各种电器外壳等制品 装修用胶合板 – 用作建筑、家具，车辆和船舶的装修材料 一般用胶合板 – 适用于包装，垫衬及其它方面用途 薄木装饰胶合板 – 用作建筑，家具，车辆，船舶等的高级装饰材料 按照国家标准中的术语定义按照国标 普通胶合板 GB/T 9846-2015 中的术语，有以下 3 类胶合板： I 类胶合板 - class I plywood II 类胶合板 - class II plywood III 类胶合板 - class III plywood 名称 定义 国标 I 类胶合板 能够通过煮沸试验，供室外条件下使用的耐气候胶合板。 GB/T 18259-2009，定义 2.2.1.18 II 类胶合板 能够通过 63 ℃ ± 3 ℃ 热水浸溃试验，供潮湿条件下使用的耐水胶合板。 GB/T 18259-2009，定义 2.2.1.19 III 类胶合板 能够通过 20 ℃ ± 3 ℃ 冷水浸泡试验，供干燥条件下使用的不耐潮胶合板。 GB/T 209846-2015，定义 3.3 外观质量胶合板按成品板面板上可见的材质缺陷和加工缺陷的数量和范围分成优等品、一等品、合格品 3 个等级。详情见普通胶合板 GB/T 9846-2015 国标。 理化性能胶合板的物理化学性能，主要从 5 个维度来评估： 含水率 胶合强度 浸渍剥离 静曲强度和弹性模量 甲醛释放量 含水率 (%) 胶合板板种 I 、II 类 III 类 阔叶树材 5~14 5~16 针叶树材 5~14 5~16 胶合强度 (MPa) 树种名称／木材名称／国外商品材名称 I 、II 类 III类 椴木、杨木、拟赤杨、泡桐、橡胶木、柳安、奥克榄、白梧桐、异翅香、海棠木、桉木 ≥ 0.70 ≥ 0.70 水曲柳、荷木、枫香、槭木、榆木、柞木、阿必东、克陈、山樟 ≥ 0.80 ≥ 0.70 桦木 ≥ 1.00 ≥ 0.70 马尾松、云南松、落叶松、云杉、辐射松 ≥ 0.80 ≥ 0.70 浸渍剥离当胶合板相邻层单板木纹方向相同时，应进行浸渍剥离试验，每个试件同一胶层每边剥离长度累计不超过 25 mm。 静曲强度和弹性模量略，详情见标准。这里 是一份普通胶合板 GB/T 9846-2015 PDF 格式的存档。 甲醛释放量按照 室内装饰装修材料 人造板及其制品中甲醛释放限量 GB 18580-2017 规定执行。 装饰单板贴面胶合板装饰单板贴面胶合板是室内装修最常使用的材料之一。由于该产品表层的装饰单板是用优质木材经刨切或旋切加工方法制成的，所以比胶合板具有更好的装饰性能。我国装饰单板贴面胶合板标准规定装饰单板贴面胶合板分为优等品、一等品、合格品三个等级。在此提醒厂家和消费者其他分等形式均不符合我国装饰单板贴面胶合板标准，例如有的厂家标识等级为“AAA”，这是企业行为。 国家标准对装饰单板贴面胶合板的性能要求：我国现行的是推荐标准 GB/T 15104-2006 《装饰单板贴面人造板》，绝大部分企业的生产执行此标准。该标准对装饰单板贴面胶合板在外观质量、加工精度、物理力学性能三个方面规定了指标。其物理力学性能指标有：含水率、表面胶合强度、浸渍剥离。GB 18580-2017 《室内装饰装修材料 人造板及其制品中甲醛释放限量》还规定了该产品的甲醛释放限量指标。 通常天然木质单板饰面板所贴饰面单板往往是花纹好，身价高的树种，比如柏木、橡木、花梨木、水曲柳等。但是在商品名称中应当予以说明，比如称为“柏木贴面胶合板”，或者“水曲柳切片胶合板”，或者“樱桃木饰板”。几种称法中“贴面”、“切片”、“饰板”都反映了“饰板”的基本特征。但是不能以柏木三合板、水曲柳三合板等简称，因为这些简称泛指胶合板的面板、底板都由柏木或水曲柳制成。 纤维板纤维板是将树皮、刨花、树枝等以木质纤维或其他植物素纤维为原料经破碎、浸泡、研磨成木浆，施加脲醛树脂或其他适用的胶粘剂，经加压成型、干燥处理而制成的板材。因成型时温度和压力不同，可以分为硬质、半硬质、软质三种。又名密度板，按照密度对应前面三种又称为高密度纤维板、中密度纤维板、低密度纤维板。纤维板具有材质均匀、纵横强度差小、不易开裂等优点。 刨花板刨花板是利用施加或未施加胶料的木刨花或木纤维料压制成的板材。刨花板密度小、材质均匀，但易吸湿、强度低。 与人造板有关的国家标准 普通胶合板 GB/T 9846-2015本标准规定了普通胶合板的术语和定义、分类、要求、测量及试验方法、检验规则以及标志、包装、运输和贮存等。本标准适用于普通胶合板，不适用于细木工板、单板层积材等不同结构和特殊性能要求的胶合板。 装饰单板贴面人造板 GB/T 15104-2006本标准规定了装饰单板贴面人造板（又称薄木贴面人造板）的术语和定义、分类、要求、试验方法、检验规则以及标志、包装、运输和贮存等。本标准适用于以普通单板、调色单板、集成单板和重组装饰单板等为饰面材料，以人造板为基材经胶合制成的未经涂饰加工的装饰单板贴面人造板。 室内装饰装修材料 人造板及其制品中甲醛释放限量 GB 18580-2017本标准规定了室内装饰装修用人造板及其制品中甲醛释放限量要求、试验方法。本标准适用于纤维板、刨花板、胶合板、细木工板、重组装饰材、单板层积材、集成材、饰面人造板、木质地板、木质墙板、木质门窗等室内用各种类人造板及其制品的甲醛释放限量。 中密度纤维板 GB/T 11718-2009本标准规定了中密度纤维板的术语、定义和缩略语、分类和附加分类、要求、测量和试验方法、检验规则、标志、包装、运输和贮存等。本标准适用于干法生产的中密度纤维板。 室内装饰装修材料 胶粘剂中有害物质限量 GB 18583-2008本标准规定了室内建筑装饰装修用胶粘剂中有害物质限量及其试验方法。本标准适用于室内建筑装饰装修用胶粘剂。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检验检测机构的资质认定.md]]></title>
    <url>%2Fpassages%2F%E6%A3%80%E9%AA%8C%E6%A3%80%E6%B5%8B%E6%9C%BA%E6%9E%84%E7%9A%84%E8%B5%84%E8%B4%A8%E8%AE%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[检验检测机构的资质认定在我国，评判一个检测实验室或者其他类型的检验检测机构的资质，主要看是否获得以下两个认证： CMA - China Metrology Accredidation CNAS - China National Accreditation Service for Conformity Assessment CMA一般称为中国计量认证或者中国实验室资质认证。是依据《中华人民共和国计量法》、《中华人民共和国认证认可条例》等有关法律、法规的规定，对为社会出具公证数据的检验机构进行强制考核的一种手段，是政府对第三方实验室的行政许可，是政府权威部门对检测机构进行规定类型检测所给予的正式承认。实验室获得 CMA，才具备向用户、社会及政府提供公正数据的条件和资格。CMA 证书备有所批准合格的检测项目附表，取得 CMA 证书的检测机构只能按照附表中所批准的项目进行检测业务。 国家质量监督检验检疫总局《检验检测机构资质认定管理办法》（总局令第163号）：第四十一条 检验检测机构未依法取得资质认定，擅自向社会出具具有证明作用数据、结果的，由县级以上质量技术监督部门责令改正，处3万元以下罚款。第四十五条 检验检测机构有下列情形之一的，资质认定部门应当撤销其资质认定证书：（一）未经检验检测或者以篡改数据、结果等方式，出具虚假检验检测数据、结果的；（二）违反本办法第四十三条规定，整改期间擅自对外出具检验检测数据、结果，或者逾期未改正、改正后仍不符合要求的；（三）以欺骗、贿赂等不正当手段取得资质认定的；（四）依法应当撤销资质认定证书的其他情形。被撤销资质认定证书的检验检测机构，三年内不得再次申请资质认定。 我国的 CMA，由国家认证认可监督管理委员会（CNCA）统一管理，分国家和省两级实施。国家认证认可监督管理委员会统一管理、监督和综合协调实验室的资质认定工作，国家级实验室的资质认定由国家认监委负责实施；各省、自治区、直辖市人民政府质量技术监督部门和各直属出入境检验检疫机构按照各自职责负责所辖区域内的实验室的资质认定和监督检查工作，地方级实验室的资质认定，由地方质检部门负责实施。 CNAS即中国合格评定国家认可委员会，是根据《中华人民共和国认证认可条例》的规定，由国家认证认可监督管理委员会（英文缩写为：CNCA）批准成立并确定的认可机构，统一实施对认证机构、实验室和检验机构等相关机构的认可工作。 取得 CNAS 证书意味着认可机构批准实验室从事特定的校准或检验活动, 经认可的实验室或认证、审核机构表明其具有从事特定任务的能力。通过国家实验室认可的检测技术机构，证明其符合国际上通行的校准与检测实验室能力的通用要求，即 CNAS 认可对实验室的法律地位没有限制，可以是企业内部的实验室，也可以是独立的第三方实验室。 CMA 与 CNAS 的区别 评审组织机构的区别CNAS 的评审组织机构和发证机构是中国合格评定国家认可委员会。CMA 分省级和国家级的，国家级实验室的资质认定由国家认监委负责，非国家级的实验室一般由所在地省级的质量技术监督局负责组织评审和发证。 评审原则的区别CNAS 秉承的是自愿、非歧视的原则。CMA 是针对为社会出具公证数据的检验机构进行的强制考核。 对实验室的法律地位要求的区别CNAS 认可对实验室的法律地位没有限制，可以是企业内部的实验室，也可以是独立的第三方实验室。CMA 认定的对象，需要是独立的第三方实验室、政府相关部门下属的事业单位实验室等。 报告有效范围的区别通过 CNAS 认可的实验室在其认可范围内出具的带 CNAS 标识的报告，可在全球的多个国家和地区通行（双方签署了互认协议 MRA）。通过 CMA 资质认定的实验室在其认定范围内出具的报告只在国内有效。 总结我国国内从事检验检测的机构必须取得 CMA 资质认证，否则为违法行为。也就是说，CMA 资质认定是强制考核的。CNAS 资质认定则是自愿性质的，同时 CNAS 可在全球的多个国家和地区通行，所以在国际上更具竞争力。 链接 CNCA - 中国国家认证认可监督管理委员会 国家计量认证实验室名录查询 全国认证认可信息公共服务平台]]></content>
  </entry>
  <entry>
    <title><![CDATA[好物日志]]></title>
    <url>%2Fpassages%2F%E5%A5%BD%E7%89%A9%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[这里记录我买过的好东西。 SONY 头戴式无线降噪耳机 WH-900NIRIS OHYAMA 日本爱丽思迷你空气循环扇 SONY 头戴式无线降噪耳机型号是 WH-900N。对机器发出的杂音(比如引擎发出的噪音)降噪效果不错，对人声降噪效果一般。另外这款耳机，不适合在比较热的环境里佩戴。淘宝购入。 IRIS OHYAMA 日本爱丽思迷你空气循环扇简约精致的空气循环扇.最小的一档是静音挡,声音确实比一般的风扇要小,同时它的送风距离较一般风扇更长.搭配空调使用效果更佳.]]></content>
      <tags>
        <tag>生活</tag>
        <tag>好物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国主要木材名称的三大相关标准]]></title>
    <url>%2Fpassages%2F%E4%B8%AD%E5%9B%BD%E4%B8%BB%E8%A6%81%E6%9C%A8%E6%9D%90%E5%90%8D%E7%A7%B0%E7%9A%84%E4%B8%89%E5%A4%A7%E7%9B%B8%E5%85%B3%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[《中国主要木材流通商品名称》WB/T1038-2008、《中国主要木材名称》GB/T16734-1997、《中国主要进口木材名称》GB/T18513-2001 标准出台后，三大标准配套使用，给各类木材企业的生产、经营、进出口等带来便利，也给各类商检、质检、专业机构与院校的执法与教学提供依据。 《中国主要木材名称》 GB/T16734-1997标准简介本标准共收载我国380类(个)木材名称(中、英名)及其树种名称(包括中名、别名、拉丁名)、科别、产地和备注。380类木材名称是由907个树种归纳而来，其归类的原则是以树木学(或植物学)的属为基础，把材性和用途相近木材树种名称统一，以便利木材生产、利用、贸易、造林、营林、科研、教学等的应用。907个树种隶属99科(针叶树材8科、阔叶树材91科)、347属(针叶树材33属、阔叶树材314属)，基本上覆盖了我国重要木材树种。 木材树种名称按科以拉丁学名的字母顺序排列，既保持针、阔叶树材和科的完整性，又便于查找。科的范围，针叶树材参照郑万钧等《中国植物志》第七卷的系统概念，阔叶树材参照哈钦松的《有花植物科志》一书的概念，个别种的处理略有不同。在科内、属内木材树种名称原则上也按属及种以拉丁学名的字母顺序排列。 范围 本标准规定了中国主要木材的名称(中、英名)，树种中名、别名、拉丁名。 本标准适用于木材的科研、教学、木材生产和使用、贸易等部门。 《中国主要进口木材名称》 GB/T18513-2001标准简介本标准为首次发布。本标准共收集世界各国423个(类)木材名称，它们是由1010个树种归纳而来。1010个树种隶366属(针叶树材19属;阔叶树材347属)、84科(针叶树材4科;阔叶树材80科)，基本上包括了世界各国重要商品材树种。 范围 本标准规定了中国主要进口木材的木材名称、树种名称(树种中文名、树种拉丁文名)。 本标准适用于木材生产、贸易、科研及教学等。 《中国主要木材流通商品名称》 WB/T1038-2008标准简介本标准为首次发布。本标准共收集了目前中国市场上流通的主要国内外木材416个树种。按照科学性与实用性相结合的原则，根据树木分类科、属系统归纳成340类(个)。 木材流通商品名称按其所在科、属、种拉丁名字母顺序分级排列，同时介绍了科别、材色及密度和产地。本标准分进口针叶树材、进口阔叶树材和国产针叶树材、国产阔叶树材四部分。 范围 本标准规定了中国主要商品木材的木材名称、树种名称(中文名、拉丁名)、商品名、流通商品名。 本标准适用于木材生产、贸易、科研及教学等。 各种标准的下载地址]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 问答]]></title>
    <url>%2Fpassages%2Fevent%20loop%20%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[问答 像 V8 这样的 JavaScript 引擎，除了 call stack 和 heap，是否还有一个 callback queue(message queue/task queue)?答：JavaScript 引擎只有一个 call stack 和 一个 heap，callback queue 是由 JavaScript runtime 实现的，比如 Chrome 浏览器或者 NodeJS。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
        <tag>Event loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the V8 engine + 5 tips on how to write optimized code]]></title>
    <url>%2Fpassages%2FInside%20the%20V8%20engine%20%2B%205%20tips%20on%20how%20to%20write%20optimized%20code%2F</url>
    <content type="text"><![CDATA[接上一篇关于 JavaScript 的引擎、运行时、调用栈的技术文章，这篇文章主要集中于 V8 引擎以及写出高性能代码的 5 个小建议。原文链接在这里此外，这里是一篇中文翻译。 The first post of the series focused on providing an overview of the engine, the runtime and the call stack. This second post will be diving into the internal parts of Google’s V8 JavaScript engine. We’ll also provide a few quick tips on how to write better JavaScript code. OverviewA JavaScript engine is a program or an interpreter which executes JavaScript code. A JavaScript engine can be implemented as a standard interpreter, or just-in-time compiler that compiles JavaScript to bytecode in some form. This is a list of popular projects that are implementing a JavaScript engine: V8 — open source, developed by Google, written in C++ Rhino) — managed by the Mozilla Foundation, open source, developed entirely in Java SpiderMonkey — the first JavaScript engine, which back in the days powered Netscape Navigator, and today powers Firefox JavaScriptCore — open source, marketed as Nitro and developed by Apple for Safari KJS) — KDE’s engine originally developed by Harri Porten for the KDE project’s Konqueror web browser Chakra(JScript9)) — Internet Explorer Chakra(JavaScript)) — Microsoft Edge Nashorn) - open source as part of OpenJDK, written by Oracle Java Languages and Tool Group JerryScript — is a lightweight engine for the Internet of Things. Why was the V8 Engine created?The V8 Engine which is built by Google is open source and written in C++. This engine is used inside Google Chrome. Unlike the rest of the engines, however, V8 is also used for the popular Node.js runtime. V8 was first designed to increase the performance of JavaScript execution inside web browsers. In order to obtain speed, V8 translates JavaScript code into more efficient machine code instead of using an interpreter. It compiles JavaScript code into machine code at execution by implementing a JIT (Just-In-Time) compiler like a lot of modern JavaScript engines do such as SpiderMonkey or Rhino (Mozilla). The main difference here is that V8 doesn’t produce bytecode or any intermediate code. V8 used to have two compilersBefore version 5.9 of V8 came out (released earlier this year), the engine used two compilers: full-codegen — a simple and very fast compiler that produced simple and relatively slow machine code. Crankshaft — a more complex (Just-In-Time) optimizing compiler that produced highly-optimized code. The V8 Engine also uses several threads internally: The main thread does what you would expect: fetch your code, compile it and then execute it There’s also a separate thread for compiling, so that the main thread can keep executing while the former is optimizing the code A Profiler thread that will tell the runtime on which methods we spend a lot of time so that Crankshaft can optimize them A few threads to handle Garbage Collector sweeps When first executing the JavaScript code, V8 leverages full-codegen which directly translates the parsed JavaScript into machine code without any transformation. This allows it to start executing machine code very fast. Note that V8 does not use intermediate bytecode representation this way removing the need for an interpreter. When your code has run for some time, the profiler thread has gathered enough data to tell which method should be optimized. Next, Crankshaft optimizations begin in another thread. It translates the JavaScript abstract syntax tree to a high-level static single-assignment (SSA) representation called Hydrogen and tries to optimize that Hydrogen graph. Most optimizations are done at this level. InliningThe first optimization is inlining as much code as possible in advance. Inlining is the process of replacing a call site (the line of code where the function is called) with the body of the called function. This simple step allows following optimizations to be more meaningful. Hidden classJavaScript is a prototype-based language: there are no classes and objects are created using a cloning process. JavaScript is also a dynamic programming language which means that properties can be easily added or removed from an object after its instantiation. Most JavaScript interpreters use dictionary-like structures (hash function based) to store the location of object property values in the memory. This structure makes retrieving the value of a property in JavaScript more computationally expensive than it would be in a non-dynamic programming language like Java or C#. In Java, all of the object properties are determined by a fixed object layout before compilation and cannot be dynamically added or removed at runtime (well, C# has the dynamic type which is another topic). As a result, the values of properties (or pointers to those properties) can be stored as a continuous buffer in the memory with a fixed-offset between each. The length of an offset can easily be determined based on the property type, whereas this is not possible in JavaScript where a property type can change during runtime. Since using dictionaries to find the location of object properties in the memory is very inefficient, V8 uses a different method instead: hidden classes. Hidden classes work similarly to the fixed object layouts (classes) used in languages like Java, except they are created at runtime. Now, let’s see what they actually look like:123456function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2); Once the new Point(1,2) invocation happens, V8 will create a hidden class called C0. No properties have been defined for Point yet, so C0 is empty. Once the first statement this.x = x is executed (inside the Point function), V8 will create a second hidden class called C1 that is based on C0. C1 describes the location in the memory (relative to the object pointer) where the property x can be found. In this case, x is stored at offset 0, which means that when viewing a point object in the memory as a continuous buffer, the first offset will correspond to property x. V8 will also update C0 with a class transition which states that if a property x is added to a point object, the hidden class should switch from C0 to C1. The hidden class for the point object below is now C1. Every time a new property is added to an object, the old hidden class is updated with a transition path to the new hidden class. Hidden class transitions are important because they allow hidden classes to be shared among objects that are created the same way. If two objects share a hidden class and the same property is added to both of them, transitions will ensure that both objects receive the same new hidden class and all the optimized code that comes with it. This process is repeated when the statement this.y = y is executed (again, inside the Point function, after the this.x = x statement). A new hidden class called C2 is created, a class transition is added to C1 stating that if a property y is added to a Point object (that already contains property x) then the hidden class should change to C2, and the point object’s hidden class is updated to C2. Hidden class transitions are dependent on the order in which properties are added to an object. Take a look at the code snippet below:123456789101112function Point(x, y) &#123; this.x = x; this.y = y;&#125;var p1 = new Point(1, 2);p1.a = 5;p1.b = 6;var p2 = new Point(3, 4);p2.b = 7;p2.a = 8; Now, you would assume that for both p1 and p2 the same hidden classes and transitions would be used. Well, not really. For p1, first the property a will be added and then the property b. For p2, however, first b is being assigned, followed by a. Thus, p1 and p2 end up with different hidden classes as a result of the different transition paths. In such cases, it’s much better to initialize dynamic properties in the same order so that the hidden classes can be reused. Inline cachingV8 takes advantage of another technique for optimizing dynamically typed languages called inline caching. Inline caching relies on the observation that repeated calls to the same method tend to occur on the same type of object. An in-depth explanation of inline caching can be found here. We’re going to touch upon the general concept of inline caching (in case you don’t have the time to go through the in-depth explanation above). So how does it work? V8 maintains a cache of the type of objects that were passed as a parameter in recent method calls and uses this information to make an assumption about the type of object that will be passed as a parameter in the future. If V8 is able to make a good assumption about the type of object that will be passed to a method, it can bypass the process of figuring out how to access the object’s properties, and instead, use the stored information from previous lookups to the object’s hidden class. So how are the concepts of hidden classes and inline caching related? Whenever a method is called on a specific object, the V8 engine has to perform a lookup to the hidden class of that object in order to determine the offset for accessing a specific property. After two successful calls of the same method to the same hidden class, V8 omits the hidden class lookup and simply adds the offset of the property to the object pointer itself. For all future calls of that method, the V8 engine assumes that the hidden class hasn’t changed, and jumps directly into the memory address for a specific property using the offsets stored from previous lookups. This greatly increases execution speed. Inline caching is also the reason why it’s so important that objects of the same type share hidden classes. If you create two objects of the same type and with different hidden classes (as we did in the example earlier), V8 won’t be able to use inline caching because even though the two objects are of the same type, their corresponding hidden classes assign different offsets to their properties. The two objects are basically the same but the a and b properties were created in different order. Compilation to machine codeOnce the Hydrogen graph is optimized, Crankshaft lowers it to a lower-level representation called Lithium. Most of the Lithium implementation is architecture-specific. Register allocation happens at this level. In the end, Lithium is compiled into machine code. Then something else happens called OSR: on-stack replacement. Before we started compiling and optimizing an obviously long-running method, we were likely running it. V8 is not going to forget what it just slowly executed to start again with the optimized version. Instead, it will transform all the context we have (stack, registers) so that we can switch to the optimized version in the middle of the execution. This is a very complex task, having in mind that among other optimizations, V8 has inlined the code initially. V8 is not the only engine capable of doing it. There are safeguards called deoptimization to make the opposite transformation and reverts back to the non-optimized code in case an assumption the engine made doesn’t hold true anymore. Garbage collectionFor garbage collection, V8 uses a traditional generational approach of mark-and-sweep to clean the old generation. The marking phase is supposed to stop the JavaScript execution. In order to control GC costs and make the execution more stable, V8 uses incremental marking: instead of walking the whole heap, trying to mark every possible object, it only walk part of the heap, then resumes normal execution. The next GC stop will continue from where the previous heap walk has stopped. This allows for very short pauses during the normal execution. As mentioned before, the sweep phase is handled by separate threads. Ignition and TurboFanWith the release of V8 5.9 earlier in 2017, a new execution pipeline was introduced. This new pipeline achieves even bigger performance improvements and significant memory savings in real-world JavaScript applications. The new execution pipeline is built on top of Ignition, V8’s interpreter, and TurboFan, V8’s newest optimizing compiler. You can check out the blog post from the V8 team about the topic here. Since version 5.9 of V8 came out, full-codegen and Crankshaft (the technologies that have served V8 since 2010) have no longer been used by V8 for JavaScript execution as the V8 team has struggled to keep pace with the new JavaScript language features and the optimizations needed for these features. This means that overall V8 will have much simpler and more maintainable architecture going forward. These improvements are just the start. The new Ignition and TurboFan pipeline pave the way for further optimizations that will boost JavaScript performance and shrink V8’s footprint in both Chrome and Node.js in the coming years. Finally, here are some tips and tricks on how to write well-optimized, better JavaScript. You can easily derive these from the content above, however, here’s a summary for your convenience: How to write optimized JavaScript Order of object properties: always instantiate your object properties in the same order so that hidden classes, and subsequently optimized code, can be shared. Dynamic properties: adding properties to an object after instantiation will force a hidden class change and slow down any methods that were optimized for the previous hidden class. Instead, assign all of an object’s properties in its constructor. Methods: code that executes the same method repeatedly will run faster than code that executes many different methods only once (due to inline caching). Arrays: avoid sparse arrays where keys are not incremental numbers. Sparse arrays which don’t have every element inside them are a hash table. Elements in such arrays are more expensive to access. Also, try to avoid pre-allocating large arrays. It’s better to grow as you go. Finally, don’t delete elements in arrays. It makes the keys sparse. Tagged values: V8 represents objects and numbers with 32 bits. It uses a bit to know if it is an object (flag = 1) or an integer (flag = 0) called SMI (SMall Integer) because of its 31 bits. Then, if a numeric value is bigger than 31 bits, V8 will box the number, turning it into a double and creating a new object to put the number inside. Try to use 31 bit signed numbers whenever possible to avoid the expensive boxing operation into a JS object. Resource https://docs.google.com/document/u/1/d/1hOaE7vbwdLLXWj3C8hTnnkpE0qSa2P--dtDvwXXEeD0/pub https://github.com/thlorenz/v8-perf http://code.google.com/p/v8/wiki/UsingGit http://mrale.ph/v8/resources.html https://www.youtube.com/watch?v=UJPdhx5zTaw https://www.youtube.com/watch?v=hWhMKalEicY]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[an overview of the engine, the runtime, and the call stack]]></title>
    <url>%2Fpassages%2Fan%20overview%20of%20the%20engine%2C%20the%20runtime%2C%20and%20the%20call%20stack%2F</url>
    <content type="text"><![CDATA[转载一篇国外开发者写的技术文章，关于 JavaScript 的引擎、运行时、调用栈。 OverviewAlmost everyone has already heard of the V8 Engine as a concept, and most people know that JavaScript is single-threaded or that it is using a callback queue. In this post, we’ll go through all these concepts in detail and explain how JavaScript actually runs. By knowing these details, you’ll be able to write better, non-blocking apps that are properly leveraging the provided APIs. If you’re relatively new to JavaScript, this blog post will help you understand why JavaScript is so “weird” compared to other languages. And if you’re an experienced JavaScript developer, hopefully, it will give you some fresh insights on how the JavaScript Runtime you’re using every day actually works. The JavaScript EngineA popular example of a JavaScript Engine is Google’s V8 engine. The V8 engine is used inside Chrome and Node.js for example. Here is a very simplified view of what it looks like: The Engine consists of two main components: Memory Heap — this is where the memory allocation happens Call Stack — this is where your stack frames are as your code executes The runtimeThere are APIs in the browser that have been used by almost any JavaScript developer out there (e.g. setTimeout). Those APIs, however, are not provided by the Engine. So, where are they coming from? It turns out that the reality is a bit more complicated. So, we have the Engine but there is actually a lot more. We have those things called Web APIs which are provided by browsers, like the DOM, AJAX, setTimeout and much more. And then, we have the so popular event loop and the callback queue. A runtime environment is the execution environment provided to an application by the operating system. In a runtime environment, the application can send instructions or commands to the processor and access other system resources such as RAM, DISK etc. JS engine, Event queues, Event loop and Web/Dom APIs forms the Runtime Environment. The Call StackJavaScript is a single-threaded programming language, which means it has a single Call Stack. Therefore it can do one thing at a time. The Call Stack is a data structure which records basically where in the program we are. If we step into a function, we put it on the top of the stack. If we return from a function, we pop off the top of the stack. That’s all the stack can do. Let’s see an example. Take a look at the following code:12345678910function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); Running code on a single thread can be quite easy since you don’t have to deal with complicated scenarios that are arising in multi-threaded environments — for example, deadlocks. But running on a single thread is quite limiting as well. Since JavaScript has a single Call Stack, what happens when things are slow? Concurrency &amp; the Event LoopWhat happens when you have function calls in the Call Stack that take a huge amount of time in order to be processed? For example, imagine that you want to do some complex image transformation with JavaScript in the browser. You may ask — why is this even a problem? The problem is that while the Call Stack has functions to execute, the browser can’t actually do anything else — it’s getting blocked. This means that the browser can’t render, it can’t run any other code, it’s just stuck. And this creates problems if you want nice fluid UIs in your app. And that’s not the only problem. Once your browser starts processing so many tasks in the Call Stack, it may stop being responsive for quite a long time. And most browsers take action by raising an error, asking you whether you want to terminate the web page. ow, that’s not the best user experience out there, is it? So, how can we execute heavy code without blocking the UI and making the browser unresponsive? Well, the solution is asynchronous callbacks. This will be explained in greater detail in Part 2 of the “How JavaScript actually works” tutorial: “Inside the V8 engine + 5 tips on how to write optimized code”.]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中的 Event Loop]]></title>
    <url>%2Fpassages%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%20Event%20Loop%2F</url>
    <content type="text"><![CDATA[Event loop 是针对运行时而非引擎首先，我们要弄清楚一点，event loop 是针对 JavaScript runtime environment 的，而非 JavaScript engine。对于 NodeJS 这一 runtime environment 来说，它的 JavaScript engine 是 V8，对于 Chrome 这一 runtime environment 来说，它的 JavaScript engine 是 V8 ；对 Firefox 这一 runtime environment 来说，它的 JavaScript engine 是 SpiderMonkey。event loop 是浏览器和 NodeJS 这两个 JavaScript runtime environment 处理异步的机制，它不属于 JavaScript 引擎的运行机制。另外，浏览器和 NodeJS 的 event loop 是不一样的，这篇文章将集中讨论浏览器这一运行时环境。另外要说明的是，浏览器除了包含 JavaScript runtime environment 之外，还负责 HTML 和 CSS 的解析以及最后渲染图形在屏幕上等工作。 JavaScript Engine负责解析和执行 JavaScript 代码。最开始的时候，JavaScript 的 engine 只是一个解释器，后来以 V8 为代表的现代引擎实现了一种叫做 JIT(just-in-time) 的及时编译技术，拥有更好的性能。 引擎由以下两个主要部分组成： Memory Heap 堆内存，负责内存分配。 Call Stack 调用栈，主要用于记录函数调用的位置。 下图是 Chrome 内的 V8 引擎示意图： JavaScript runtime EnvironmentJavaScript runtime environment 的示意图如下（以 Chrome 为例）： JavaScript Engine - JavaScript 引擎。 Web APIs - 由浏览器提供的 APIs，主要包括 DOM、BOM、AJAX、定时器。 Callback Queue - 回调队列。也叫作 task queue 或者 message queue。 event loop 是 JavaScript runtime 实现异步的一种机制，负责协调调度以上三者。它的工作是不停地查看调用栈和回调队列，一旦调用栈为空，就通知回调队列将下一个回调函数发送到调用栈，等引擎执行完回调函数，它再进行下一轮循环。 为什么需要 event loop?Event loop 的存在，是为了协调事件、用户交互、脚本、UI 渲染、网络处理等行为，防止主线程阻塞。注意下面这段话： The event loop, the web APIs and the message queue/task queue are not part of the JavaScript engine, it’s a part of browser’s JavaScript runtime environment or Nodejs JavaScript runtime environment (in case of Nodejs). In Nodejs, the web APIs are replaced by the C/C++ APIs.more ECMAScript 规范主要是写给 JavaScript 这门语言的引擎实现者看的，而引擎的主要工作是解析并执行脚本。所以 event loop 在实现上的标准没有写在 ECMAScript 规范，而是写在 HTML 规范 中，是 Web application APIs 的组成部分，供各大浏览器厂商参考。总而言之，event loop 是 JavaScript runtime environment 对于异步的实现，而非 JavaScript engine。 下面这些都是不属于 JavaScript 语言特性的 Web APIs： setTimeout, setInterval, setImmediate 等定时器，按朴灵的说法，其本质仍然是事件。定时器并不是特例。到达时间点后，会形成一个事件（timeout 事件）。不同的是，一般事件是靠底层系统或者线程池之类的产生事件，但定时器事件是靠事件循环不停检查系统时间来判定是否到达时间点来产生事件。 DOM 网页文档对象模型，主要给 JavaScript 的编程接口。 BOM 浏览器对象模型，主要是一些浏览器的 API。 XMLHttpRequest。 上面提到的这些 APIs，与 DOM 相关的挂载在 document 对象上，与 BOM 相关的挂载在 window 对象上，而 document 对象也被挂载在 window 对象上。另外，属于语言特性的全局属性（包括全局值属性、全局函数属性、全局对象属性）也挂载在 window 对象上，请看下面的代码： 123456789// 以下比较都为 truewindow.Infinity === Infinity // 全局值属性window.parseInt === parseInt // 全局函数属性window.Array === Array // 全局对象属性window.setTimeout === setTimeoutwindow.Promise === window.Promisewindow.document === documentwindow.XMLHttpRequest === XMLHttpRequestdocument.location === window.location Browsing Context即浏览器执行上下文，是一个向用户呈现 Document 对象的环境。通常来说，浏览器的每一个标签页包含一个 browsing context，每一个 &lt;iframe&gt; 标签也包含一个 browsing context。每个 browsing context 具有如下属性： 一个相对应的 WindowProxy 对象。可以理解为一个封装了浏览器全局对象 window 的对象，包含了在浏览器环境执行 JavaScript 代码所需的初始化信息，比如： Infinity, NaN, undefined 等值属性 eval(), isFinite(), isNaN(), parseFloat(), encodeURI() 等函数属性 Array, Date, Object, Function, Error, Promise 等构造器属性 另外，必然还有 DOM 和 setTimeout 等各种 Web API。 一个 opener browsing context 属性，它的值是 null 或者另一个 browsing context。初始值为 null。 一个 disowned 布尔属性，初始值为 false。 一个 is closing 布尔属性，初始值为 false。 一个 session history 属性，可以认为包含的是该标签页的会话历史信息。 每一个 browsing context 都有一个 event loop 在调度各种任务间的协同工作。 详解 Event Loop按照 HTML 规范，Event Loop 有如下 3 种类型： window event loop worker event loop worklet event loop 这里我们主要关注第一种 event loop，即一个浏览器标签页包含一个 event loop 或者一组同源的标签页共享一个 event loop 的情况。下面提到的 event loop 也均指 window event loop。 浏览器的 event loop 至少包含两个队列，macrotask 队列和 microtask 队列。按照 HTML 规范，Event loop 的实现应该至少使用一个队列用于处理 macrotasks，至少一个队列处理 microtasks。Event loop 的实际实现通常分配几个队列用于处理不同类型的 macrotasks 和 microtasks。这使得可以对不同的任务类型进行优先级排序。例如优先考虑一些性能敏感的任务如用户输入。另一方面，因为实际上存在很多 JavaScript 宿主环境，所以有的 event loop 使用一个队列处理这两种任务也不应该感到奇怪。 MacrotaskMacrotasks 包含生成 DOM 对象、解析 HTML、执行主线程 JavaScript 代码、更改当前 URL 还有其他的一些事件如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，macrotask 代表一些离散的独立的工作。当执行完一个 task 后，浏览器可以继续其他的工作如页面重渲染和垃圾回收。 MicrotaskMicrotasks 则是完成一些更新应用程序状态的较小任务，如处理 promise 的回调和 DOM 的修改，这些任务在浏览器重渲染前执行。Microtask 应该以异步的方式尽快执行，其开销比执行一个新的 macrotask 要小。Microtasks 使得我们可以在 UI 重渲染之前执行某些任务，从而避免了不必要的 UI 渲染，这些渲染可能导致显示的应用程序状态不一致。 对于浏览器这个 JavaScript runtime environment 来说，microtask 主要包括以下两项： promise 的回调函数 MutationObserver 的回调函数，DOM 规范指出 step 5 of queuing a mutation record 会将 MutationObserver 的回调函数放置在 microtask 中。 Event Loop TickEvent loop 的每一轮循环称为 tick。如下图所示（图片来自 secrets of javascript ninja 这本书）： 这张图也不错： 如上图所示，在一次 tick 中，event loop 首先检查 macrotask 队列，如果有一个 macrotask 等待执行，那么执行该任务。当该任务执行完毕后（或者 macrotask 队列为空），event loop 继续执行 microtask 队列。如果 microtask 队列有等待执行的任务，那么 event loop 就一直取出任务执行直到 microtask 队列为空。这里我们注意到处理 microtask 和 macrotask 的不同之处：在一次 tick 中，一次最多处理一个 macrotask （其他的仍然驻留在队列中），然而会一次性处理完所有的 microtask 直至 microtask 队列为空。 紧接着，当执行完所有 microtask 即 microtask 队列为空时，event loop 检查是否需要执行 UI 重渲染，如果需要则重渲染 UI。这样就结束了当次循环，继续从头开始检查 macrotask 队列。 上图还包含了一些细节： 两个任务队列都放置在 event loop 外，这表明将任务添加和任务处理行为分离。在 event loop 内负责执行任务（并从队列里删除），而在 event loop 外添加任务。如果不是这样，那么在 event loop 里执行代码时，发生的任何事件都被忽略，这显然不是我们想要的，因此我们将添加任务的行为和 event loop 分开进行。 两种类型的任务同时只能执行一个，因为 JavaScript 基于单线程执行模型。任务一直执行到完成而不能被其他任务中断，这一特性叫做 run-to-completion。只有浏览器才能停止任务的执行；例如如果某个任务消耗了太多的内存和时间的话，浏览器可以中断其执行。 所有的 microtasks 都应该在下次渲染前执行完，因为其目的就是在渲染前更新应用状态。 浏览器通常每秒尝试渲染页面 60 次，以达到每秒 60 帧（60 fps），这个帧速率通常被认为是平滑运动的理想选择。这意味着浏览器尝试每 16ms 渲染一帧。上图中update rendering操作在 event loop 中进行，这是因为在呈现页面时，页面内容不应该被另一个任务修改。这意味着如果我们想要实现平滑的 UI 效果，单个 event loop 中不能占据太多时间。单个任务和由该任务生成的所有 microtasks 应该在 16 毫秒内完成。 当浏览器完成页面渲染后，event loop 的下一次 tick 中可能发生三种情况： event loop 在另一个 16ms 之前执行的 is rendering needed 的判断处。因为更新 UI 是一个复杂的操作，如果没有明确要求渲染页面，浏览器可能在本次迭代中不执行 UI 渲染。 event loop 在上次渲染后约 16ms 处达到 Is rendering needed 判断处。在这种情况下，浏览器更新 UI，用户会认为应用比较流畅。 执行下次任务（及其所有相关的 microtask）花费时间大大超过 16ms。这样浏览器将无法按照目标的帧速率重新渲染页面，UI 也将不会更新。如果运行任务代码不占用太多时间（超过几百毫秒），这种延迟甚至可能感知不到，尤其是对于没有太多动画的页面。另一方面，如果我们花费太多时间，或者页面中含有动画，用户可能认为网页缓慢和没有响应。在最坏的情况下，如果任务执行超过几秒钟，用户的浏览器会显示无响应脚本消息。 处理事件时应注意其发生的频率和处理所需时间。如在处理鼠标移动事件时应该格外小心。移动鼠标会导致大量的事件排队，因此在该鼠标移动处理程序中执行任何复杂的操作都可能导致应用变得很不流畅。 Task Queue (Callback Queue / Message Queue)根据 HTML 规范，event loop 具有一个或多个 task queue，即任务队列。任务队列是一个有序的任务列表，这些任务是指负责以下工作的算法： 事件 解析 HTML 回调 获取网络资源 对 DOM 操作作出反应 每个任务都被定义为来自特定的任务源。来自同一个任务源的所有任务（例如，由文档的定时器生成的回调、由鼠标在文档上移动而触发的事件、为该文档的解析器排队的任务）必须始终添加到同一任务队列中，但是来自不同任务源的任务可以被放置在不同的任务队列中。 Generic task sources以下任务源被本规范和其他规范中许多几乎不相关的特性使用： DOM 操作任务源此任务源用于对 DOM 操作做出反应的功能，例如在将元素插入文档时以非阻塞方式发生的事件。 用户交互任务源此任务源用于对用户交互做出反应的功能，例如键盘或鼠标输入。响应用户输入而发送的事件(例如点击事件)必须使用在用户交互任务源中排队的任务来触发。 网络任务源此任务源用于响应网络活动而触发的功能。 历史遍历任务源这个任务源是用来对 history.back() 及类似的 API 进行排队。 浏览器的异步处理模型目前在网络上找到的一些中文资料无法完全说服自己，而 HTML 规范主要给出的是详实严谨的算法，所以试着按照自己的理解梳理下：通常情况下，每一个浏览器的标签页都有一个独立的 browsing context。这个 browsing context： 有一个 execution context stack 执行上下文栈 至少有一个而且通常只有一个与之关联的 event loop。 而这里 event loop 有一个 microtask queue 和至少一个 task queue。当一个浏览器标签页加载时，通常是做以下几件事情（按照 HTML 规范是 task 任务）： 解析 HTML 当遇到 &lt;script src=&#39;...&#39;&gt;, &lt;link&gt;, &lt;img&gt; 等标签时发起网络请求。如果有 defer 属性浏览器则会并行发起网络请求，并在 HTML 解析完毕后执行脚本；如果有 async 属性浏览器则会并行发起网络请求，在脚本资源加载完成后执行。 当遇到内嵌的 script 脚本时，执行脚本内的代码，即将脚本内的代码会形成若干执行上下文，被压入执行上下文栈 渲染 UI 这里需要注意的是，script 脚本内执行的诸如 setTimeout 定时器的回调、通过 XMLHttpRequest 发起的异步网络请求、onclick 等事件触发的回调、通过脚本动态操作 DOM 等，这些操作或者说任务，实际上与上面提到的 task 任务是平行的。也就是说，我们写在 script 标签内的 author code，如果里面包含 setTimoutout 等非 JavaScript 语言特性的代码，JavaScript 引擎会调用外部的 Web APIs，将这些任务放置到 task queue 中。根据 HTML 规范，一个浏览器标签页至少有一个 task queue；而遇到 Promise 或者 MutationObserver，则浏览器会将其放置到 miscrotask queue 中。 简而言之，对于浏览器来说，event loop 这种机制，将 JavaScript 引擎的执行上下文栈（也叫 call stack 调用栈）、Web APIs、task queue 这三者进行协调。下面是一个浏览器的 event loop 的示意简图： Event loop 实例推荐使用文章末尾参考链接给出的两个将 event loop 在线可视化工具，非常赞。下面的一组图片清晰的展示了如下代码在浏览器的 JavaScript runtime 中是如何运行的（可点击图片以幻灯片形式查看）： 1234567console.log('Hi')setTimeout(function() &#123; console.log('there')&#125;, 5000)console.log('Designvelopers') 初始状态： 执行 console.log(&quot;Hi&quot;);，在控制台打出 Hi 后，该函数的调用帧（执行上下文）从调用栈中弹出。另外，这里的 main() 函数模拟一个 .js 文件的全局调用帧： 执行 setTimeout(...)，调用 Web APIs 中针对 setTimeout() 的接口，开始比对系统时间与定时器设置的延迟时间。接着 setTimeout(...) 从调用栈中弹出。 执行 console.log(&quot;Designvelopers&quot;);，在控制台打出 Designvelopers 后，该函数的调用帧从调用栈中弹出。与此同时，Web APIs 仍在另一个线程中比对时间，显然这时还没有到达定时器所设置的 5 秒延迟时间。 脚本的同步代码都已经执行完，此时调用栈为空。当到达定时器设置的时间后，Web APIs 将定时器的回调函数放入回调队列中排队。 此时调用栈为空，并且回调队列中只有定时器回调函数这一个任务，直接取出定时器回调在调用栈中执行，形成两个调用帧： 执行完 console.log(&quot;there&quot;); 后，该函数的调用帧从调用栈弹出： 定时器的回调函数只有一行代码，所以紧接着，回调函数的调用帧也从调用栈弹出： 完毕。 性能优化从性能优化的角度出发，压倒一切的指导方针是，以下几种情况必须并行执行，否则可能会导致阻塞 event loop，这包括但不限于： 执行繁重的计算； 显示面向用户的提示； 执行可能需要外部系统参与的操作(即退出流程)。 参考链接和外部资料 菲利普·罗伯茨：到底什么是 Event Loop 呢？ | 欧洲 JSConf 2014youtube 上面关于 event loop 播放量最高的一个视频，对 event loop 讲解非常清晰（因为是 2014 年发布的，所以没有涉及到 miscrotask），更可贵的是作者针对这一机制做了可视化。下面的链接是一个将 event loop 可视化的在线网站。 Event loop 在线可视化工具 Jake Archibald: In The Loop - JSConf.Asia 20182018 年发布的有关浏览器的 event loop 机制的视频，涉及到了 miscrotask。作者是一名来自 Google 的开发者。下一个链接也是他的文章。 tasks-microtasks-queues-and-schedules作者是一名来自 Google 的开发者，这篇文章里包含了可视化 event loop 机制的工具，很赞。 The JavaScript Event Loop - Concurrency in the Language of the Web使用 Google 办公套件的 PPT 描述的 event loop，讲述了 JavaScript 这门单线程语言是如何处理异步的。里面有两张对 event loop 的图解，非常赞。 All you need to know about the JavaScript event loop一组关于 Event Loop 的幻灯片 the-javascript-event-loop-explained/写于 2013 年对 event loop 的解释。 how-browsers-work发布于 2011 年 8 月 5 日的一篇深度好文，作者是一名以色列开发者，用了几年收集整理有关浏览器内部原理的资料，同时阅读了非常多的浏览器源码，最终形成了这篇文章，详细讲述了以 Chrome 为主的浏览器的工作原理，你在网络看到绝大多数有关浏览器原理的文章和图片可能都是取材于这篇文章的。 understanding-asynchronous-javascript-the-event-loop 重新认识 script 标签 - HTML specification HTML specification HTML draft Event Loop - MDN JavaScript 中的事件循环 Event Loop JavaScript 运行机制详解：再谈 Event Loop - 阮一峰 【朴灵评注】JavaScript 运行机制详解：再谈 Event Loop HTML 系列：macrotask 和 microtask - 知乎专栏]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
        <tag>浏览器原理</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 规范阅读笔记之全局对象]]></title>
    <url>%2Fpassages%2FECMAScript%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ECMAScript 规范中全局对象的阅读笔记。 根据 ECMAScript 的规范，全局对象： 在代码控制流进入任何执行上下文之前，它会被创建。 它没有构造器 [[Constructor]] 这个内部方法；所以不能用 new 操作符创建全局对象的实例。 它没有调用 [[Call]] 这个内部方法；所以不能作为函数调用。 它有一个 [[Prototype]] 内部插槽，其值与各种实现有关。 除了本规范定义的属性，可能还有基于宿主环境定义的属性。 值属性 Infinity NaN undefined 函数属性 eval() isFinite() isNaN() parseFloat() parseInt() URI 专用处理函数 decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() 构造器属性 Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Init8Array Init16Array Init32rray Map Number Object Promise Proxy RangeError ReferenceError RegExp Set SharedArrayBuffer String Symbol SyntaxError TypeError Uinit8Array Uinit8ClampedArray Uinit16Array Uinit32Array URIError WeakMap WeakSet 其他属性 JSON Math Reflect]]></content>
      <tags>
        <tag>ECMAScript specification</tag>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习资源索引]]></title>
    <url>%2Fpassages%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[这篇文章的目的是为了给自己更清晰地罗列出优秀的前端学习资源，以备日后需要时随时参考。 规范最原始、权威的第一手资料，内容非常详细、严谨。 ECMAScript specification HTML draft HTML specification DOM specification CSSOM specification W3C standards The WHATWG specification index. 权威速查手册适合想要了解某个属性或者方法的详细信息时使用。 Mozilla manual 第三方教程 The Modern JavaScript Tutorial ES6 入门教程 - 阮一峰 CSS tricks 其他 Google Web 开发者文档]]></content>
      <tags>
        <tag>学习资源</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闪电计划]]></title>
    <url>%2Fpassages%2F%E9%97%AA%E7%94%B5%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[为了自身的健康，为了买了个表，我决定开启这项闪电计划，目标只有一个：通过科学合理的方式，将体重从目前的 78 Kg 减轻到 73 Kg。 措施措施主要分两个部分：控制饮食和持续运动。 控制饮食 早餐以燕麦搭配牛奶为主 严格控制晚餐的食物摄入量，一碗饭 晚饭后刷牙，之后除了喝水不吃任何东西 除少量水果外，不吃任何零食 不喝除牛奶、酸奶、咖啡之外的任何饮料 持续运动 工间休息 开合跳 蹲下起立 晚上的运动 热身：平板支撑 有氧运动：跳绳 无氧运动：俯卧撑 战利品华为运动手表]]></content>
      <tags>
        <tag>健身</tag>
        <tag>自我管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：异步编程]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为什么需要异步编程？在我们的程序中，类似下面这样的代码，是由计算机的处理器一次性执行完毕的。代码的运行速度也很大程度上取决于计算机处理器的速度。1234567891011const sumTo = function(n) &#123; let sum = 0; for (let i = 0; i &lt;= n; i++) &#123; sum += i; &#125; return sum;&#125;;sumTo(10000); 但是，还有很多其他程序需要在处理器外面与其他设备交互。比如，有些程序可能需要通过计算机网络进行通信，或者从硬盘读取数据，而这些都比从内存读取代码慢得多了。 当这样的情形发生时，让处理器处于空闲状态是非常浪费资源的，因为可能有不少其他工作需要处理器在这时来处理。某种程度上来说，这取决于你的操作系统，它会切换处理器运行多个不同的程序。但是，当我们在运行单个程序，遇到等待网络请求的情形时，我们没法让处理器去做其他事情。 在同步编程的模型里，事情一件接着一件地执行。当调用一个性能开销很大的函数时，只有当函数内的操作都完成了才会返回。在这个函数运行期间，程序只能原地待命。 异步编程的模型允许多个事情在同一时间发生。当我们开始一项任务（比如从硬盘读取数据），我们的程序可以继续运行。当这个任务完成时，程序会通知我们并返回一个结果。 我们可以用一个小例子来对比同步编程和异步编程：一个程序从网络获取两个资源文件然后组合成需要的结果。 在一个同步的环境里，只有当网络请求全部完成时，请求函数才会返回。执行上面那个例子的最简单方式就是：一个接一个地发出网络请求。这样做的缺点是：第二个网络请求只有在第一个网络请求全部完成时才会开始。那么，完成上述例子的时间将是至少两项网络请求所需时间之和。12345// 先请求第一个资源文件request(resourceOne);// 当上面的网络请求完成，才会继续执行第二个网络请求request(resourceTwo); 针对这类问题的解决方式，在一个同步的环境里就是增加额外的线程。线程是指另一个运行中的程序，它的执行可能通过操作系统与另外的程序交织在一起。鉴于大多数现代计算机都包含多个核心的处理器，多个线程可能同时由不同的处理器核心来运行。对于上面的小例子来说，增加的第二个线程可以用来发起第二个网络请求，接着让两个线程都等待返回的结构，然后两个线程实现同步，再组合成需要的结果。 两个重量级的 JavaScript 平台，浏览器和 NodeJS 都需要进行一些费时的异步操作，而不是依赖于多线程。鉴于多线程编程是众所周知的难，所以这通常被认为是个好事情。 回调 Callback异步编程的其中一种方式是：当函数执行耗时较长的操作时，增加一个额外的参数，即回调函数。当这个耗时的操作开始，等待它结束并返回一个结果时，回调函数以这个结果为参数被调用。 举个例子，在 NodeJS 和浏览器环境中都已实现的 setTimeout 函数，等待一段时间（以毫秒为单位）后再调用回调函数。1setTimeout(() =&gt; console.log("Tick"), 500); 回调实例：加载脚本一个典型的用例：动态加载一个脚本，并在脚本加载完成后使用该脚本。在浏览器的 Web API 中，像 Window，XMLHttpRequest，&lt;script&gt;，&lt;img&gt; 等元素都部署了 onload 事件处理接口，当资源加载完成后被触发。这里以加载 &lt;script&gt; 元素的资源为例：12345678910111213141516171819202122const loadScript = function(src, callback) &#123; const script = document.createElement("script"); // 执行这一行代码，浏览器会发起网络请求获取脚本资源 script.src = src; // 资源加载成功时执行 script.onload = () =&gt; callback(null, script); // 资源加载失败时执行 script.onerror = () =&gt; callback(new Error(`Script load error for $&#123;src&#125;`)); document.head.appendChild(script);&#125;;// 使用loadScript("/my/script.js", (error, script) =&gt; &#123; // “错误优先”风格的回调， 在 NodeJS 生态中被广泛使用 if (error) &#123; // 处理错误 &#125; else &#123; // 脚本加载成功 &#125;&#125;) 回调地狱有的时候，我们需要按照一定的顺序来执行一连串的异步任务。如果使用回调函数的方式来处理，就会形成嵌套的异步任务。假设我们现在要依次获取 3 个脚本资源，那么就会形成下面这样的代码：12345678910111213141516171819202122232425loadScript("one.js", (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; one(); // 继续获取第 2 个脚本 loadScript("two.js", (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; two(); // 继续获取第 3 个脚本 loadScript("three.js", (error, script) =&gt; &#123; if (error) &#123; // 处理错误 &#125; else &#123; three(); // 获取到所有脚本资源 // ... &#125; &#125;) &#125; &#125;) &#125;&#125;) 上面的代码即构成了回调金字塔，或者称回调地狱。这样的代码不仅不易阅读，后续维护成本也高。 Promise为了解决回调地狱，Promise 诞生了。一个 Promise 的实例，是一个代表着最终会完成或者失败的异步操作的对象。新建一个 Promise 实例的语法如下：123const promise = new Promise((resolve, reject) =&gt; &#123; // executor&#125;); 上面这种新建 Promise 实例的方式，通常只会在封装基于回调处理异步操作的陈旧代码时用到（绝大部分时候，我们是 Promise 实例的使用者）。后面会给出详细例子。 executor传递给 new Promise 的参数是一个叫做 executor 的函数，它会在 promise 被创建的时候自动立即执行。executor 函数接受 2 个参数，resolve 函数 和 reject 函数，它们是由引擎预定义的，我们不必创建它们。我们应当在执行成功时调用 resolve 函数，执行失败时调用 reject 函数。 创建的 Promise 实例具备 2 个内部属性： state 初始值为 pending，之后会转变为 fulfilled 或者 rejected。 result 初始值为 undefined，之后会转变为结果或者错误对象 不可逆过程每个 Promise 实例可能的状态有 3 种：初始状态 pending，完成状态 fulfilled 和 rejected。即一个 Promise 实例要么由 pending 变成 fulfilled，要么由 pending 变成 rejected，并且此过程不可逆，一旦到了完成状态就无法改变。如下图所示： resolve 实例1234const promise = new Promise((resolve, reject) =&gt; &#123; // 模拟一项任务，1 秒后完成，成功并返回结果 "done" setTimeout(() =&gt; resolve("done"), 1000);&#125;); reject 实例1234const promise = new Promise((resolve, reject) =&gt; &#123; // 模拟一项任务，1 秒后完成，失败并返回错误对象 setTimeout(() =&gt; reject(new Error("error occurs")), 1000);&#125;); resolve 与 reject 注意事项resolve 函数或者 reject 函数其中任意一个只会被调用一次，后续的调用都将会忽略：123456const promise = new Promise((resolve, reject) =&gt; &#123; resolve("done"); reject(new Error("…")); // 忽略，不会执行 setTimeout(() =&gt; resolve("…")); // 忽略，不会执行&#125;); resolve 函数或者 reject 函数都只接受一个参数，多余的参数将会忽略。 then本质上，Promise 做的事情是，将一项耗费时间的任务（我们传入的 executor 函数）自动立即执行，然后在任务完成后将这项任务的结果保存到内部属性 result。这个结果可能是我们传入 resolve 函数的任意值，也可能是我们传入 reject 函数的错误对象。并且这个结果一旦形成就不会再改变。 我们可以通过 Promise 实例的 then 方法来获取结果。它可能被成功解决，返回一个结果：12345678const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve("done!"), 1000);&#125;);promise.then( result =&gt; alert(result), // shows "done!" after 1 second error =&gt; alert(error) // doesn't run); 也可能失败，返回错误对象：123456789const promise = new Promise(function(resolve, reject) &#123; setTimeout(() =&gt; reject(new Error("Whoops!")), 1000);&#125;);// reject runs the second function in .thenpromise.then( result =&gt; alert(result), // doesn't run error =&gt; alert(error) // shows "Error: Whoops!" after 1 second); 链式调用Promise 的 then 方法支持链式调用。注意下面代码中 then 方法内的返回值。123456789101112new Promise(resolve =&gt; &#123; resolve(1);&#125;).then(result =&gt; &#123; console.log(result); // 1 return result * 2; // 返回一个基本数据类型的值&#125;).then(result =&gt; &#123; console.log(result); // 2 return new Promise(resolve =&gt; resolve(100)); // 返回一个 Promise 的实例&#125;).then(result =&gt; &#123; console.log(result); // 100 return &#123; a: 1 &#125;; // 返回一个对象&#125;).then(result =&gt; console.log(result); // &#123; a: 1 &#125; thenable事实上，then 方法只要返回一个部署了 then 方法的任意对象，引擎就会将它当做 Promise 的实例来看待。第三方库可以利用这一点来兼容原生的 Promise。12345678910111213141516class Thenable &#123; constructor(num) &#123; this.num = num; &#125; then(resolve, reject) &#123; alert(resolve); // function() &#123; native code &#125; // resolve with this.num*2 after the 1 second setTimeout(() =&gt; resolve(this.num * 2), 1000); // (**) &#125;&#125;new Promise(resolve =&gt; resolve(1)) .then(result =&gt; &#123; return new Thenable(result); // (*) &#125;) .then(alert); // shows 2 after 1000ms catch本质上是基于 then 实现的，只不过专注于错误处理。由于链式调用 then 方法可以传递结果和错误，所以最佳实践通常是这样：123456789new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve("done"), 1000);&#125;).then(result =&gt; &#123; // ....&#125;).then(result =&gt; &#123; // ...&#125;).catch(error =&gt; &#123; // 最后统一处理错误&#125;) finally与 try...catch...finally 类似，主要用于做一些清理扫尾的工作，略。 Promise 实例：加载脚本使用 Promise 改写上面使用回调实现的加载脚本实例：123456789101112131415161718192021const loadScript = function (src) &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement("script"); script.src = src; script.onload = () =&gt; resolve(script); script.onerror = () =&gt; reject(new Error(`error when load script for $&#123;src&#125;`)); document.head.appendChild(script); &#125;)&#125;;// 使用const promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");promise.then( script =&gt; alert(`$&#123;script.src&#125; is loaded!`), error =&gt; alert(`Error: $&#123;error.message&#125;`));promise.then(script =&gt; alert("One more handler to do something else!")); Promise 串行加载资源链式调用 Promise 实例的 then 方法可以规避上面提到的回调地狱。使用 Promise 改写上面的按照顺序获取脚本资源的例子：123456789101112131415// 串行获取资源loadScript("one.js") .then(script =&gt; &#123; one(); return loadScript("two.js"); &#125;) .then(script =&gt; &#123; two(); return loadScript("three.js"); &#125;) .then(script =&gt; &#123; three(); // 获取到了全部脚本 // ... &#125;); 串行执行异步操作可以改写成更聪明简洁的写法：1234567const asyncFn1 = x =&gt; x + 1;const asyncFn2 = x =&gt; x + 10;const asyncFn3 = x =&gt; x + 100;const asyncs = [asyncFn1, asyncFn2, asyncFn3];asyncs.reduce((p, f) =&gt; p.then(f), Promise.resolve(1)) .then(result3 =&gt; console.log("result3:", result3)); // result3: 112 上面的代码等同于：1Promise.resolve(1).then(asyncFn1).then(asyncFn2).then(asyncFn3)。 还可以进一步抽象出一个组合函数，这个组合函数以一组函数为参数，按照参数的顺序依次执行，上一个函数的输出结果作为下一个函数的输入参数。这通常被使用在函数式编程中：1234567const applyAsync = (acc, val) =&gt; acc.then(val);// 尝试从该函数的调用者的角度去思考，更易读懂下面这行代码const composeAsync = (...funcs) =&gt; x =&gt; funcs.reduce(applyAsync, Promise.resolve(x));// 使用const transformData = composeAsync(fn1, fn2, fn3);const result3 = transformData(data); Promise 实例：fetchPromise 通常被用于网络请求。这里我们以 fetch 方法为例，从远程服务器获取用户数据 user.json。fetch 方法的基本用法如下：1const promise = fetch(url); // 返回一个 Promise 的实例 详细的例子如下：12345678910fetch("https://javascript.info/article/promise-chaining/user.json") // 下面的 then 方法在服务器响应时执行 .then(response =&gt; &#123; // 当我们接收到服务器发送的全部响应信息，response.text() 返回一个包含全部响应结果的新的 Promise 实例 return response.text(); &#125;) .then(text =&gt; &#123; // text 即是服务器发送过来的响应内容 alert(text); // &#123;"name": "iliakan", isAdmin: true&#125; &#125;); response 还有一个 response.json() 方法，它会读取服务器的响应内容并将之解析为 JSON。很多时候使用它来代替 response.text() 会更加方便：123fetch("https://javascript.info/article/promise-chaining/user.json") .then(response =&gt; response.json()) .then(user =&gt; alert(user.name)); // iliakan 接着让我们进一步扩展上面的例子，比如使用获取的用户数据做点什么。这里我们用获取到的用户名，查询该用户的 GitHub 信息，然后在网页上显示用户的头像：123456789101112fetch("https://javascript.info/article/promise-chaining/user.json") .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/user/$&#123;user.name&#125;`)) .then(response =&gt; response.json()) // 用户的头像地址在 githubUser.avatar_url .then(githubUser =&gt; &#123; const img = document.createElement("img"); img.src = githubUser.avatar_url; document.body.append(img); setTimeout(() =&gt; img.remove(), 3000); // (*) &#125;) 注意到上面代码中 (*) 这一行，用户头像显示 3 秒后将被移除。为了让代码更具有扩展性，即可以继续往下链式调用，同时传递数据，我们可以让第 4 个 then 方法返回一个新的 Promise 实例：12345678910111213141516fetch("https://javascript.info/article/promise-chaining/user.json") .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/users/$&#123;user.name&#125;`)) .then(response =&gt; response.json()) .then(githubUser =&gt; new Promise((resolve, reject) =&gt; &#123; // (*) const img = document.createElement("img"); img.src = githubUser.avatar_url; document.body.append(img); setTimeout(() =&gt; &#123; // 先移除头像 img.remove(); // 接着往下链式传递之前的数据 resolve(githubUser); // (*) &#125;, 3000) &#125;)) 通常来说，最好让每一个异步操作都返回 Promise 的实例，这样的代码更具扩展性，即使我们现在不需要继续往下链式调用，可能将来会用到。最后，让我们优化上面的代码，将部分代码抽象成可复用的函数：123456789101112131415161718192021222324252627282930313233const loadJson = function(url) &#123; return fetch(url).then(response =&gt; response.json());&#125;;const loadGithubUser(name) &#123; return fetch(`https://api.github.com/users$&#123;name&#125;`).then(response =&gt; response.json());&#125;;const showAvatar(githubUser) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = document.createElement("img"); img.src = githubUser.avatar_url; img.onload = () =&gt; &#123; // 图片加载完成 3 秒后移除图片，并继续往下链式传递该 GitHub 用户数据 setTimeout(() =&gt; &#123; img.remove(); resolve(githubUser); &#125;, 3000); &#125;; document.body.append(img); &#125;)&#125;;// 使用loadJson("https://javascript.info/article/promise-chaining/user.json") .then(user =&gt; loadGithubUser(user.name)) .then(githubUser =&gt; showAvatar(githubUser)) // 可简写为 .then(showAvatar) .then(githubUser =&gt; new Promise(resolve =&gt; &#123; console.log(`Finished showing $&#123;githubUser.name&#125;`); resolve(githubUser); &#125;)); Promise 错误处理Promise 实例的错误可以沿着 then 方法往下链式传递，所以最佳实践通常是在最后统一处理错误，以上面的例子为例可以这样做：12345678loadJson("https://javascript.info/article/promise-chaining/user.json") .then(user =&gt; loadGithubUser(user.name)) .then(githubUser =&gt; showAvatar(githubUser)) // 可简写为 .then(showAvatar) .then(githubUser =&gt; new Promise(resolve =&gt; &#123; console.log(`Finished showing $&#123;githubUser.name&#125;`); resolve(githubUser); &#125;)) .catch(error =&gt; console.log(error.message)); 隐式的 try...catchPromise 实例的 executor 函数和 then 函数内都存在一个隐式的 try...catch。即如果出现错误，后续 .catch 会自动捕获所有错误：123new Promise((resolve, reject) =&gt; &#123; throw new Error("Whoops!");&#125;).catch(alert); // Error: Whoops! 实际上相当于以下代码：123new Promise((resolve, reject) =&gt; &#123; reject(new Error("Whoops!"));&#125;).catch(alert); // Error: Whoops! 在 then 方法内抛出错误，也是一样，会被传递到最近的 .catch：12345new Promise((resolve, reject) =&gt; &#123; resolve("ok");&#125;).then((result) =&gt; &#123; throw new Error("Whoops!"); // rejects the promise&#125;).catch(alert); // Error: Whoops! 不仅是抛出的错误，对于所有错误也是如此：12345new Promise((resolve, reject) =&gt; &#123; resolve("ok");&#125;).then((result) =&gt; &#123; blabla(); // no such function&#125;).catch(alert); // ReferenceError: blabla is not defined 实例以上面的 fetch 方法请求用户数据为例，类似下面的错误处理方式，效果依然很不理想：123456fetch("no-such-user.json") // (*) .then(response =&gt; response.json()) .then(user =&gt; fetch(`https://api.github.com/users/$&#123;user.name&#125;`)) // (**) .then(response =&gt; response.json()) .catch(alert); // SyntaxError: Unexpected token &lt; in JSON at position 0 // ... 最后的 .catch 方法捕获的错误非常宽泛，无法直观的看出究竟是哪里出了错误，以及进一步的错误信息。对于上面的代码而言，可能有如下错误： 请求 no-such-user.json数据，服务器返回的响应是一个 404 或者 500 的错误提示页面。 成功拿到用户数据，但是请求 GitHub 用户信息接口的时候，返回的响应是一个 404 或者 500 的错误提示页面。 我们可以增加一个步骤，检查 response.status 代表的 HTTP 状态码是否为 200。如果不是则抛出一个定制的 HttpError 错误：1234567891011121314151617class HttpError extends Error &#123; constructor(response) &#123; super(`$&#123;response.status&#125; for $&#123;response.url&#125;`); this.name = "HttpError"; this.response = response; &#125;&#125;fetch(".../no-such-user.json") .then(response =&gt; &#123; if (response.status === 200) &#123; return response.json(); &#125; else &#123; throw new HttpError(response); &#125; &#125;) .catch(err =&gt; console.log(err)); // 404 for .../no-such-user.json 再看一个针对特定错误进行处理的例子：12345678910111213141516171819const demoGithubUser = function () &#123; let name = prompt("Enter a name?", "iliakan"); return loadJson(`https://api.github.com/users/$&#123;name&#125;`) .then(user =&gt; &#123; alert(`Full name: $&#123;user.name&#125;.`); return user; &#125;) .catch(err =&gt; &#123; if (err instanceof HttpError &amp;&amp; err.response.status == 404) &#123; // (*) alert("No such user, please reenter."); return demoGithubUser(); &#125; else &#123; throw err; // (*) &#125; &#125;);&#125;demoGithubUser(); 上面的代码，注意 (*) 这一行，当没有查询到对应名字的 GitHub 用户时，弹出没有此用户的信息并让用户重新输入有效的 GitHub 用户名。而对于其他错误，重新抛出。 unhandled rejections对于 Promise 内未处理的错误，比如 catch 重新抛出的错误，或者根本没有 catch 方法，大多数引擎都会追踪到这些未处理错误，并创建一个全局的错误。对于浏览器环境而言，我们可以通过监听全局事件 unhandledrejection 来访问错误并作出处理。NodeJS 环境也有类似的机制离开处理未处理的 Promise 错误。12345678window.addEventListener("unhandledrejection", event =&gt; &#123; alert(event.promise); // [object Promise] - the promise that generated the error alert(event.reason); // Error: Whoops! - the unhandled error object&#125;);new Promise(resolve =&gt; &#123; throw new Error("whoops");&#125;) Promise 静态方法Promise 一共有以下 4 个静态方法： Promise.resolve Promise.reject Promise.all Promise.race Promise.resolve主要使用场景：将一个值封装为 Promise 的实例。举例，下面的代码实现的功能是：假如某个 url 的资源之前已经获取过，可以通过 then 方法直接返回资源。12345678910111213141516171819const loadCached = function (url) &#123; const cache = loadCached.cache || (loadCached.cache = new Map()); if (cache.has(url)) &#123; // 封装缓存结果，保证返回的是 Promise 实例 return Promise.resolve(cache.get(url)); &#125; return fetch(url) .then(response =&gt; response.text()) .then(result =&gt; &#123; cache.set(url, result); return result; &#125;);&#125;;// 使用loadCached("https://example.com/user.json") .then(result =&gt; /* do something with result */) Promise.reject用于创建包含错误对象的 Promise 实例，很少用到。 Promise.all并发执行异步操作，会等待所有异步任务完成，返回的结果是由各项异步任务返回结果组成的数组；如果其中任意一个异步任务出错，直接返回错误作为最终结果，其他异步任务的结果将被忽略。基本用法：12Promise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) =&gt; &#123; /* use result1, result2 and result3 */ &#125;); 考虑如下代码：123456Promise.all([ new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2 new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)), // 3 4, // 被自动封装为 Promise.resolve(4)]).then(alert); // 3 秒后，返回的结果是 [1, 2, 3, 4] then 方法返回的结果是一个数组，数组成员为传入 Promise.all 的 Promise 实例 resolve 的结果，顺序也与 Promise.all 的参数顺序一致，而与异步操作的时间无关。 一个常用的技巧是，将一组任务的数据映射为一个成员为 Promise 实例的数组，然后使用 Promise.all 来并发执行异步任务：12345678910111213141516let urls = [ 'https://api.github.com/users/iliakan', 'https://api.github.com/users/remy', 'https://api.github.com/users/jeresig'];// 映射为 Promise 实例const requests = urls.map(url =&gt; fetch(url));// 等待所有异步操作完成// 如果其中有一个异步操作失败，将立即返回对应的错误对象Promise.all(requests) .then(responses =&gt; &#123; responses.forEach(response =&gt; alert(`$&#123;response.url&#125;:$&#123;response.status&#125;`)); return responses; &#125;); 实现容错的并发异步任务Promise.all 方法本身不具备容错性，即一旦有一个异步任务错误便立即返回错误信息。但是，有时候我们希望的结果是这样的：返回一个数组，包含处理成功的异步任务结果和处理失败的异步任务的错误信息。为了实现这一点，需要使用 catch 捕获错误，让错误不被抛出，同时让错误继续往下传递：123456789101112const urls = [ 'https://api.github.com/users/iliakan', 'https://api.github.com/users/remy', 'http://no-such-url'];Promise.all(urls.map(url =&gt; fetch(url).catch(error =&gt; error))) .then(responses =&gt; &#123; // 返回结果的数组包含以下 3 项 // [object Response], [object Response], TypeError: Failed to fetch responses.forEach(response =&gt; alert(response)); &#125;); Promise.race与 Promise.all 类似，不同点在于，Promise.race 不会等待所有异步任务完成，而是只要其中一个完成或者出错，就立即返回处理结果或者错误对象，忽略掉后续的结果或者错误。这点与它的名字 race （赛跑）相契合。12345Promise.race([ new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error("Whoops!")), 2000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))]).then(alert); // 1 Promisify一些第三方库的遗留代码仍然使用基于回调的方式处理异步，而 Promise 更加方便好用，所以需要一种方式，将接受回调函数作为参数的函数转化为返回值为 Promise 实例的函数。一个典型的例子是 setTimeout() 函数：1setTimeout(() =&gt; alert("At least 3 seconds passed"), 3000); 在之前的一篇有关错误处理的博文中讲到，try...catch 结构无法捕获 setTimeout() 函数内的错误，而这一点正是基于回调的 setTimeout() 函数备受指责的原因。12345678try &#123; setTimeout(() =&gt; &#123; throw new Error("error in setTimeout"); // 脚本在这行直接挂掉了 &#125;, 0);&#125; catch (error) &#123; // 无法捕获错误，因为抛出错误时已经离开了 try...catch 结构体 alert("this line will not be printed");&#125; 让我们使用 Promise 封装它：123const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));// 使用wait(3000).then(() =&gt; alert("At least 3 seconds passed")).catch(failureCallback); 一个更加具体的加载脚本的例子：12345678910111213141516171819202122232425262728293031// 使用 Promise 封装基于回调处理异步的代码// 回调const loadScript = function (src, callback) &#123; const script = document.createElement("script"); script.src = src; script.onload = () =&gt; callback(null, script); script.onerror = () =&gt; callback(new Error(`Load script error for $&#123;src&#125;`)); document.head.append(script);&#125;;// 使用loadScript("path/script.js", (error, result) =&gt; &#123; if (error) alert(error) else alert(result);&#125;)// promisifyconst loadScriptPromise = function (src) &#123; return new Promise((resolve, reject) =&gt; &#123; loadScript(src, (error, result) =&gt; &#123; if (error) reject(error) else resolve(result) &#125;); &#125;)&#125;;// 使用loadScriptPromise("path/script.js").then(res =&gt; alert(res)); 鉴于这是一个常见的需求，可以将其抽象成一个单独的函数 promisify：123456789101112131415161718192021222324const promisify = function (f) &#123; const wrapper = function (...args) &#123; return new Promise((resolve, reject) =&gt; &#123; // 定制 f 的回调函数 const callback = function (error, result) &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(result); &#125; &#125; // 将定制的回调函数添加到 f 参数的末尾 args.push(callback); f.apply(this, args); &#125;) &#125;; return wrapper;&#125;;// 使用const loadScriptPromise = promisify(loadScript);loadScriptPromise("https://api.github.com/users/cddbysj") .then(res =&gt; alert(res)) .catch(err =&gt; alert(err)); 上面的代码存在一个不足，只能接受形式为 (err, result) =&gt; {...} 的回调函数，即回调只能接受两个参数，一个代表错误，另一个代表结果。如果遇到类似(err, result1, result2, ...) =&gt; {...} 这样的回调函数则无法正常运行。针对这一问题的改进如下：12345678910111213141516171819202122232425262728293031323334// 回调const loadScript = function (src, callback) &#123; const script = document.createElement("script"); script.src = src; script.onload = () =&gt; callback(null, script, "test1", "test2"); script.onerror = () =&gt; callback(new Error(`Load script error for $&#123;src&#125;`)); document.head.append(script);&#125;;// promisifyconst promisify = function (f) &#123; const wrapper = function (...args) &#123; return new Promise((resolve, reject) =&gt; &#123; const callback = function (error, ...result) &#123; if (error) &#123; reject(error); &#125; else &#123; resolve(result.length === 1 ? result[0] : result); // (*) &#125; &#125;; args.push(callback); f.apply(this, args); &#125;); &#125;; return wrapper;&#125;;// 使用const loadScriptPromise = promisify(loadScript);loadScriptPromise("https://api.github.com/users/cddbysj") .then(res =&gt; alert(res)) // [script, "test1", "test2"] .catch(err =&gt; alert(err)); 参考链接及外部资料JavaScript.info - promise-basics Using promise - MDN Promise - MDN]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：错误处理]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[通常，对于 JavaScript 脚本而言，如果运行脚本时出现错误会挂掉，即引擎会在错误代码处停下来，不会继续执行后续代码，而是将错误信息打印到控制台。比如：1234let a = 1;console.log(b); (*)console.log(a);// Uncaught ReferenceError: b is not defined 上面的代码中，执行到 (*) 这一行便会停下来，将错误信息打印到控制台。 try…catch 结构但是，有一种语法结构 try...catch 允许我们捕获错误并作出相应的处理，这样脚本在出现错误时不会挂掉，而是执行我们设定的错误处理代码。我们来看两个例子：123456789101112131415try &#123; alert('Start of try runs'); // (1) &lt;-- // ...no errors here alert('End of try runs'); // (2) &lt;--&#125; catch(err) &#123; alert('Catch is ignored, because there are no errors'); // (3)&#125;alert("...Then the execution continues"); 上面的代码中，因为 try 语句块没有错误，所以 catch 语句块内的代码会被忽略，不会执行。 123456789101112131415try &#123; alert('Start of try runs'); // (1) &lt;-- lalala; // error, variable is not defined! alert('End of try (never reached)'); // (2)&#125; catch(err) &#123; alert(`Error has occured!`); // (3) &lt;--&#125;alert("...Then the execution continues"); 上面的代码中，由于 try 语句块内存在错误：变量未定义，所以 try 语句块内这一行之后的代码都不会执行，直接跳转到 catch 语句块内执行错误处理代码。 try…catch 只能捕获运行时错误所谓运行时错误 runtime-error，是指有效的 JavaScript 代码，即 JavaScript 引擎可以正确解析的代码。对于一个 JavaScript 脚本，引擎首先会解析它，接着执行它。如果出现解析时错误，通常是语法错误，引擎会直接报错，因为引擎这时无法读懂代码，自然地，try..catch 结构不可能捕获到解析错误。比如：12345try &#123; &#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&#125; catch(e) &#123; alert("The engine can't understand this code, it's invalid");&#125; try…catch 是同步执行的在诸如定时器 setTimeout 等异步代码中发生错误，try...catch 结构无法捕获错误。比如：1234567try &#123; setTimeout(function() &#123; noSuchVariable; // script will die here &#125;, 1000);&#125; catch (e) &#123; alert( "won't work" );&#125; 原因在于，setTimeout 的回调函数在执行时，引擎实际上已经离开了 try...catch 结构体。要捕获类似这样的错误，需要这样做：1234567setTimeout(function() &#123; try &#123; noSuchVariable; // try..catch handles the error! &#125; catch (e) &#123; alert( "error is caught here!"); &#125;&#125;) 错误对象当发生运行时错误时，引擎会创建一个错误对象，里面包含了有关这次错误的信息。该错误对象会被当作参数传递给 catch 语句：1234567891011try &#123; lalala; // error, variable is not defined!&#125; catch(err) &#123; // &lt;-- the "error object", could use another word instead of err alert(err.name); // ReferenceError alert(err.message); // lalala is not defined alert(err.stack); // ReferenceError: lalala is not defined at ... // Can also show an error as a whole // The error is converted to string as "name: message" alert(err); // ReferenceError: lalala is not defined&#125; 错误对象主要有 2 个属性： name 错误的名称，对于未定义的变量而言，是引用错误 ReferenceError。 message 有关错误详情的文本信息。 还有一个非标准但是被广泛采用的属性： stack 主要用作调试，包含了导致错误的调用栈跟踪。 实例让我们来看一个实际的例子：解析从服务器获取的 JSON 数据。正常的情况下，应该是这样的：1234567const json = '&#123;"name":"John", "age": 30&#125;'; // data from the serverconst user = JSON.parse(json); // convert the text representation to JS object// now user is an object with properties from the stringalert( user.name ); // Johnalert( user.age ); // 30 JSON 格式错误但是实际情况往往复杂多变，首先考虑一种情况，假如 JSON 数据不合法（格式错误，无法被正确解析），那么脚本运行到解析 JSON 数据时将会直接挂掉。这显然不是我们想要的结果，这也会让用户非常困惑。我们可以使用 try...catch 来进行错误处理：12345678910111213const json = "&#123; bad json &#125;";try &#123; let user = JSON.parse(json); // &lt;-- when an error occurs... alert( user.name ); // doesn't work&#125; catch (e) &#123; // ...the execution jumps here alert( "Our apologies, the data has errors, we'll try to request it one more time." ); alert( e.name ); alert( e.message );&#125; 抛出错误再考虑另一种情况：JSON 格式是对的，但是不包含我们需要的字段，在这里是 name 字段：12345678910const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; let user = JSON.parse(json); // &lt;-- no errors alert( user.name ); // no name!&#125; catch (e) &#123; alert( "doesn't execute" );&#125; 对于这种情况，我们可以使用 throw 操作符来抛出错误：123456789101112131415const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); // (*) &#125; alert( user.name );&#125; catch(e) &#123; alert( "JSON Error: " + e.message ); // JSON Error: Incomplete data: no name&#125; 重新抛出错误接着考虑更复杂的情况，除了 JSON 数据字段缺失的错误，假如 try 语句块内还有其他的错误，比如未定义的变量，如何在 catch 语句块内处理这种情况？接着上面的例子：1234567891011121314151617const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors lalala; // (*) undefined variable if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); // &#125; alert( user.name );&#125; catch(e) &#123; alert( "JSON Error: " + e.message ); // JSON Error: lalala is not defined&#125; 上面代码标有 (*) 的一行有一个未定义的变量，于是引擎会创建错误对象并跳转到 catch 语句块。需要明确的一点是，catch 会从 try 中捕获所有的错误。对于类似上面的例子，解决思路很简单：catch 语句块应该只处理它知道的错误并重新抛出其他错误。 这一过程大致如下： catch 会捕获 try 内的所有错误。 在 catch 语句块内，我们通过错误对象的 name 属性来分析错误。 只处理我们知道如何处理的错误，重新抛出其他错误。 针对上面的提到的同时存在未定义变量错误和 JSON 语法错误，我们只需要处理 JSON 语法错误，而将其他错误重新抛出：123456789101112131415161718192021const json = '&#123; "age": 30 &#125;'; // incomplete datatry &#123; const user = JSON.parse(json); // &lt;-- no errors lalala; // (*) undefined variable if (!user.name) &#123; throw new SyntaxError("Incomplete data: no name"); &#125; alert( user.name );&#125; catch(e) &#123; if (e.name === 'SyntaxError) &#123; alert( "JSON Error: " + e.message ); &#125; else &#123; throw e; // rethrow (*) &#125;&#125; 上面代码中，try...catch 只处理了它关心的 JSON 语法错误，而将其他错误重新抛出。那么其他错误最终到哪里去了呢？ 两种可能：如果外部代码没有使用 try...catch 来捕获错误，那么会导致脚本挂掉；如果外部代码使用了 try...catch 结构，则会捕获重新抛出的错误。如下面代码所示：12345678910111213141516171819function readData() &#123; const json = '&#123; "age": 30 &#125;'; try &#123; // ... blabla(); // error! &#125; catch (e) &#123; // ... if (e.name != 'SyntaxError') &#123; throw e; // rethrow (don't know how to deal with it) &#125; &#125;&#125;try &#123; readData();&#125; catch (e) &#123; alert( "External catch got: " + e ); // caught it!&#125; 上面的代码中，内层的 try...catch 只处理了语法错误，其他的错误都由外层的 try...catch 来处理。 注意事项 在 try...catch...finally 语句块内声明的变量只在该语句块没可见。 123456789101112131415161718192021222324let num = +prompt("Enter a positive integer number?", 35)let diff, result; // 注意这里变量都声明在 try...catch...finally 语句块之外function fib(n) &#123; if (n &lt; 0 || Math.trunc(n) != n) &#123; throw new Error("Must not be negative, and also an integer."); &#125; return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);&#125;let start = Date.now();try &#123; result = fib(num);&#125; catch (e) &#123; result = 0;&#125; finally &#123; diff = Date.now() - start;&#125;alert(result || "error occured");alert( `execution took $&#123;diff&#125;ms` ); finally 语句块总是会执行，即使 try 语句块内有显式的返回： 12345678910111213function func() &#123; try &#123; return 1; &#125; catch (e) &#123; /* ... */ &#125; finally &#123; alert( "finally" ); &#125;&#125;alert( func() ); // first works alert from finally, and then this one 全局捕获错误有一个不属于语言规范，但是各大浏览器都实现了的全局捕获错误的回调函数 window.onerror。它的主要作用不是为了让脚本可以继续执行，而是通常用作错误报告，即将错误信息发送给开发者。在页面中插入下面的脚本，即可实现错误报告的效果：123456789101112&lt;script&gt; window.onerror = function(message, url, line, col, error) &#123; const err = `$&#123;message&#125;\n At $&#123;line&#125;:$&#123;col&#125; of $&#123;url&#125;`; sendToDevelop(err); // 发送给开发者 &#125;; function readData() &#123; badFunc(); // 此处发生错误 &#125; readData();&lt;/script&gt; 定制和扩展错误在实际开发中，语言内置的几个标准错误类，比如 Error，SyntaxError，TypeError，ReferenceError 等，可能不足以满足我们在特定情况下的需要。比如在进行网络请求操作时我们可能需要 HttpError，在进行数据库操作时我们可能需要 DbError，对于搜索操作可能需要 NotFoundError 等。我们可以通过继承通用错误类 Error 来定制我们需要的错误类，这被认为是最佳实践。有以下优点： 可以继承 message，name，stack 这些基础的错误属性。 可以使用 inctanceof 运算符来判断错误类型。 便于之后的多级错误类型继承的形成。 当然，对于不同的错误类，我们可以添加额外所需的属性，比如对于 HttpError，可以添加 statusCode 属性，它的值可能是 404，500 等。 扩展错误实例让我们来看一个读取 JSON 格式的用户数据的例子。假定我们期望的用户数据是这样的：1const json = `&#123; "name": "John", "age": 30 &#125;`; 先做一点铺垫，内置的通用错误类 Error 的伪代码可能是这样的：12345678// The "pseudocode" for the built-in Error class defined by JavaScript itselfclass Error &#123; constructor(message) &#123; this.message = message; this.name = "Error"; // (different names for different built-in error classes) this.stack = &lt;nested calls&gt;; // non-standard, but most environments support it &#125;&#125; 为了将 JSON 数据字段缺失的错误单独处理，我们定制一个单独的 ValidationError 错误类：12345678910111213141516171819class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "ValidationError" &#125;&#125;// 模拟一个错误const test = function() &#123; throw new ValidationError("Whoops!");&#125;try &#123; test();&#125; catch(err) &#123; alert(err.message); // Whoops! alert(err.name); // ValidationError alert(err.stack); // a list of nested calls with line numbers for each&#125; 接着我们将它用在读取用户数据的例子上：123456789101112131415161718192021222324252627282930313233343536class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "Validation"; &#125;&#125;// Usageconst readUser = function (json) &#123; const user = JSON.parse(json); if (!user.name) &#123; throw new ValidationError("no field: name"); &#125; if (!user.age) &#123; throw new ValidationError("no field: age"); &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;// Working example with try..catchtry &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof ValidationError) &#123; console.log(`Invalid data: $&#123;error.message&#125;`); // Invalid data: No field: name &#125; else if (error instanceof SyntaxError) &#123; console.log(`JSON syntax error: $&#123;error.message&#125;`); &#125; else &#123; throw error; // unknown error, rethrow it &#125;&#125; 注意上面代码使用 instanceof 运算符来判断错误类型的做法。 进一步扩展错误类上面的 ValidationError 错误类还是过于通用，我们在它的基础上继续扩展一个更具体的属性缺失错误类 PropertyRequireError:1234567891011121314151617181920212223242526272829303132333435363738394041424344class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = "Validation"; &#125;&#125;class PropertyRequireError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; this.name = "PropertyRequireError"; &#125;&#125;// Usageconst readUser = function (json) &#123; const user = JSON.parse(json); if (!user.name) &#123; throw new PropertyRequireError("name"); &#125; if (!user.age) &#123; throw new PropertyRequireError("age"); &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;// Working example with try..catchtry &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof PropertyRequireError) &#123; console.log(`Invalid data: $&#123;error.message&#125;`); &#125; else if (error instanceof SyntaxError) &#123; console.log(`JSON syntax error: $&#123;error.message&#125;`); &#125; else &#123; throw error; // unknown error, rethrow it &#125;&#125; 现在，我们在抛出属性错误的时候只需要传入缺失的属性就可以了。还有一个地方可以优化，每次扩展一个类都需要设置 this.name = ...，可以增加一个继承的层级来专门完成这个任务：123456789101112131415161718class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = this.constructor.name; &#125;&#125;class ValidationError extends MyError &#123; &#125;class PropertyRequiredError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; &#125;&#125;// name is correctalert( new PropertyRequiredError("field").name ); // PropertyRequiredError 包装异常让我们思考一下，readUser 这个函数的任务是从 JSON 数据读取到我们所需要的用户数据字段。让我们站在 readUser 函数的调用者的角度来思考，我们希望得到的错误信息应该简单清晰，是一个类似 ReadError 这样的错误类。至于错误的具体细节应该封装在这个错误类内部，可能是 JSON 格式错误，可能是属性缺失错误，以及将来可能出现的其他错误。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class MyError extends Error &#123; constructor(message) &#123; super(message); this.name = this.constructor.name; &#125;&#125;class ReadError extends MyError &#123; constructor(message, cause) &#123; super(message); this.cause = cause; &#125;&#125;class ValidationError extends MyError &#123; constructor(message) &#123; super(message); &#125;&#125;class PropertyRequireError extends ValidationError &#123; constructor(property) &#123; super(`No property: $&#123;property&#125;`); this.property = property; &#125;&#125;// 验证用户数据是否缺失属性const validateUser = function (user) &#123; if (!user.name) &#123; throw new PropertyRequireError("name"); &#125; if (!user.age) &#123; throw new PropertyRequireError("age"); &#125;&#125;const readUser = function (json) &#123; let user; try &#123; user = JSON.parse(json); &#125; catch (error) &#123; if (error instanceof SyntaxError) &#123; throw new ReadError("SyntaxError", error); &#125; else &#123; throw error; &#125; &#125; try &#123; validateUser(user); &#125; catch (error) &#123; if (error instanceof ValidationError) &#123; throw new ReadError("ValidationError", error); &#125; else &#123; throw error; &#125; &#125; return user;&#125;const json = `&#123; "age": 29 &#125;`;try &#123; readUser(json);&#125; catch (error) &#123; if (error instanceof ReadError) &#123; // readUser 调用者关心的错误 console.log(error); // 原始错误信息 console.log(error.cause); &#125; else &#123; throw error; &#125;&#125; 上面代码所使用的方式叫做包装异常 Wrapping Exceptions，是一种在面向对象编程中广泛使用的技巧。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：面向对象之混入]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%B7%B7%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在 JavaScript 中，基于原型的继承是不支持多继承的。但是，在有些时候我们希望有类似的机制。一个非常的典型的例子是事件。有很多的对象，都应该含有对事件处理的方法。而这些针对事件处理的方法不适合被放在原型链中。在 JavaScript 中，实现混入mixin的方式非常简单：将这些方法放在一个对象中，然后通过 Object.assign 将该对象内的方法添加到类中。 实例：事件混入许多对象的一个重要特性是对事件的处理。下面的代码，通过混入的方式扩展了类的行为。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//事件混入：const eventMixin = &#123; /** * 订阅事件 * @param &#123;String&#125; eventName 订阅的事件名称 * @param &#123;Function&#125; handler 订阅的事件处理的回调函数 */ on(eventName, handler) &#123; if (!this._eventHandlers) &#123; this._eventHandlers = &#123;&#125;; &#125; if (!this._eventHandlers[eventName]) &#123; this._eventHandlers[eventName] = []; &#125; this._eventHandlers[eventName].push(handler); &#125;, /** * 取消订阅事件 * @param &#123;String&#125; eventName 要取消订阅的事件名称 * @param &#123;Function&#125; handler 要取消订阅的事件处理回调函数 */ off(eventName, handler) &#123; const handlers = this._eventHandlers &amp;&amp; this._eventHandlers[eventName]; if (!handlers) return; for (let i = 0; i &lt; handlers.length; i++) &#123; if (handlers[i] === handler) &#123; handlers.splice(i--, 1); &#125; &#125; &#125;, /** * 触发事件 * @param &#123;String&#125; eventName 事件名称 * @param &#123;any&#125; args 事件处理回调函数的参数 */ trigger(eventName, ...args) &#123; if (!this._eventHandlers || !this._eventHandlers[eventName]) &#123; return; &#125; this._eventHandlers[eventName].forEach(handler =&gt; handler.apply(this, args)); &#125;&#125;;class Menu &#123; choose(value) &#123; this.trigger("select", value); &#125;&#125;// 将事件混入 Menu 对象的原型Object.assign(Menu.prototype, eventMixin);const menu = new Menu();// 订阅 select 事件menu.on("select", value =&gt; alert(value));// 触发 select 事件menu.choose("apple");]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记：class语法糖]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aclass%20%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
    <content type="text"><![CDATA[在前面一篇原型与继承的学习笔记中，最后使用基于原型的范式实现了继承。而 ES6 引入的 class 关键字则提供了更加漂亮的语法，与 Java 等语言有点类似。还是以 Rabbit 继承 Animal 为例，使用 class 关键字的写法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Animal &#123; constructor(name, speed) &#123; this.name = name; this.speed = speed; &#125; // 静态方法是从属于 class 本身的，而非其原型。静态属性同理。 // 等同于： // Animale.compare = function(animalA, animalB) &#123; ... &#125; static compare(animalA, animalB) &#123; return animalA.speed - animalB.speed; &#125; // 成员方法是从属于 class 的原型的 // 等同于： // Animal.prototype.run = function(speed) &#123; ... &#125; run(speed) &#123; this.speed += speed; console.log(`$&#123;this.name&#125; run with speed $&#123;this.speed&#125;`); &#125; stop() &#123; this.speed = 0; console.log(`$&#123;this.name&#125; stopped`); &#125;&#125;class Rabbit extends Animal &#123; constructor(name, speed, earLength) &#123; super(name, speed); // 必须使用 super 调用父级构造器，然后才能访问 this this.earLength = earLength; &#125; hide() &#123; console.log(`$&#123;this.name&#125; hide`); &#125; stop() &#123; // 通过 super.method() 可以调用父类的方法 super.stop(); this.hide(); &#125;&#125;console.log(typeof Animal); // functionconsole.log(typeof Rabbit); // function 需要注意的几点： class 只是语法糖，在语言层面并未引入新的基本单元，从 typeof Animal 的结果 function 可以看到，本质上依然是函数。 子类的构造器 constructor 在访问 this 之前必须先调用父类构造器，即调用 super(...)。 为了更多地复用代码，在子类中可以使用 super.method() 调用父类的方法。 声明的成员方法 run，stop， hide 都是定义在其原型上。以 stop 方法为例，等同于： Animal.prototype = function () {...}。 声明的静态方法则是定义在 class 函数本身上，而非其原型上。 extends 关键字实际上做了以下工作： 将 Rabbit.prototype 的原型设为 Animal.prototype，使得 Rabbit 的实例可以继承 Animal 的实例属性 将 Rabbit 的原型设为 Animal，使得 Rabbit 本身可以继承 Animal 的静态属性 class 内声明的方法之间没有逗号 ,。 静态属性与实例属性在 JavaScript 中，结合 class 关键字，用类似 Java 中面向对象的思想来理解静态属性与实例属性。静态属性是挂载在 class 本身上的，而实例属性是挂载在原型 prototype 上的。我们以内置的 Object 和 Date 这两个对象为例来说明，如下图所示： 从上图可以清晰的看到：Object 和 Date 两者本身是不存在继承关系的，它们只是通过彼此的原型实现继承关系，仅此而已。 Object 的静态属性 Object.name Object.length Object.prototype Object.assign Object.getOwnPropertyDescriptor Object.getOwnPropertyDescriptors Object.getOwnPropertyNames Object.getOwnPropertySymbols Object.is Object.preventExtensions Object.seal Object.create Object.defineProperties Object.defineProperty Object.freeze Object.getPrototypeOf Object.setPrototypeOf Object.isExtensible Object.isFrozen Object.isSealed Object.keys Object.entries Object.values Object 的实例属性 constructor __defineGetter__ __defineSetter__ hasOwnProperty __lookupGetter__ __lookupSetter__ isPrototypeOf propertyIsEnumerable toString valueOf __proto__ toLocaleString Date 的静态属性 Date.length Date.name Date.prototype Date.now Date.parse Date.UTC Date 的实例属性 constructor toString toDateString toTimeString toISOString toUTCString toGMTString getDate setDate getDay getFullYear setFullYear getHours setHours getMilliseconds setMilliseconds getMinutes setMinutes getMonth setMonth getSeconds setSeconds getTime setTime getTimezoneOffset getUTCDate setUTCDate getUTCDay getUTCFullYear setUTCFullYear getUTCHours setUTCHours getUTCMilliseconds setUTCMilliseconds getUTCMinutes setUTCMinutes getUTCMonth setUTCMonth getUTCSeconds setUTCSeconds valueOf getYear setYear toJSON toLocaleString toLocaleDateString toLocaleTimeString. Symbol.toPrimitive. instanceof 运算符instanceof 运算符的语法如下：1obj instanceof Class 这一运算符的本质其实是判断 Class.prototype 是否在 obj 对象的原型链上。除此之外，对于那些部署了 Symbol.hasInstance 静态方法的类，还要额外考虑。obj instanceof Class 这一算法的工作过程大致如下： 如果某个类部署了 Symbol.hasInstance 静态方法，那么直接使用该方法。比如下面这样： 123456789// assume anything that canEat is an animalclass Animal &#123; static [Symbol.hasInstance](obj) &#123; if (obj.canEat) return true; &#125;&#125;let obj = &#123; canEat: true &#125;;alert(obj instanceof Animal); // true: Animal[Symbol.hasInstance](obj) is called 如果某个类没有部署 Symbol.hasInstance 静态方法（大多数类都没有部署）。那么开始检查这个类的原型链，看 Class.prototype 是否等于原型链上的某个原型，即做如下比较： 1234obj.__proto__ === Class.prototypeobj.__proto__.__proto__ === Class.prototypeobj.__proto__.__proto__.__proto__ === Class.prototype... 还是以 Rabbit 继承 Animal 为例，来看看 instanceof 的工作过程：1234567class Animal &#123;&#125;class Rabbit extends Animal &#123;&#125;let rabbit = new Rabbit();alert(rabbit instanceof Animal); // true// rabbit.__proto__ === Rabbit.prototype// rabbit.__proto__.__proto__ === Animal.prototype (match!) 上面的代码中，rabbit 实例的原型链是这样的：1rabbit -&gt; Rabbit.prototpye -&gt; Animal.prototype -&gt; Object.prototype -&gt; null rabbit instanceof Animal 执行的操作是在上面的原型链中查找，看 Animal.prototype 是否出现在原型链中，如果是则返回 true，否则返回 false。 类型检查在 JavaScript 中，主要有 3 种方法可以用来做类型检查： typeof 主要用于检查基本数据类型，返回一个说明了所属类型的字符串。比如： 1alert(typeof 1); // number {}.toString 用于检查基本数据类型，内置对象，以及部署了 Symbol.toStringTag 属性的对象。可以看做是增强版的 typeof 。示例： 1234567891011121314151617181920// 对于基本数据类型let s = Object.prototype.toString;alert( s.call(123) ); // [object Number]alert( s.call(null) ); // [object Null]alert( s.call(alert) ); // [object Function]// 对于部署了 Symbol.toStringTag 的对象let user = &#123; [Symbol.toStringTag]: "User"&#125;;alert( &#123;&#125;.toString.call(user) ); // [object User]// 对于特定环境的内置对象和类alert( window[Symbol.toStringTag]); // windowalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequestalert( &#123;&#125;.toString.call(window) ); // [object Window]alert( &#123;&#125;.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest] instanceof 用于对检查对象数据类型，尤其用于检查对象继承关系。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红木知识]]></title>
    <url>%2Fpassages%2F%E7%BA%A2%E6%9C%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[红木知识问答，现在开始： 1、红色的木材就是红木吗？ 红色的木材不一定都是红木，红木心材的材色也不全是红色的。《红木》标准中共列出 8 类（紫檀木类、花梨木类、香枝木类、黑酸枝木类、红酸枝木类、乌木类、条纹乌木类和鸡翅木类），隶属于 5 属（紫檀属、黄檀属、柿属、崖豆属及铁刀木属），红木指的是这红木指的是这 5 属 8 类的心材。 2、红檀香属于红木吗？ 红檀香学名香脂木豆，归于香脂木豆属，心材红褐色至紫红褐色，结构甚细而均，木材具有香气。但是红檀香不属于《红木》标准中规定的 5 属 8 类 33 种木材，所以不属于红木范畴。 3、中国人为什么喜欢红木？ 历史性：中国古典家具有千余年的悠久历史。明清家具是我国家具发展的巅峰，经典明清代家具用材讲究，主要是采用降香黄檀（即黄花梨）、紫檀、酸枝、花梨木等珍贵木材。民族性：中国人自古以来对艺术品的审美追求较之西方人则更注重艺术品载体本身的质量。而载体质量的优劣往往又与稀有、名贵、美观、光润等视觉、触觉、乃至味觉等人所能全方位感受认知的价值有关。中国人自古以来有爱木、爱玉的传统，喜欢回归自然。思想性：明清家具是刻在红木上的文化，反映了中国人的“儒家之道”，“稳重、平和”，“天人合一”和“天圆地方”的理念。同时每件家具都具有美好的寓意的图案，通过雕刻来表达。雕刻主要有人物、山水、花鸟、历史故事、吉祥符号等形式。科学性：结构严谨，设计合理，符合人体工程学，如椅子背“S”曲线，让人坐着舒服。由于木材很硬重，基本无法使用钉子，所以产生了根据硬木特性产生的一系列制作工艺和表现形式。艺术性：从家具的线条和结构与精美的木材纹理与花纹，与中国的水墨画和书法的线条艺术吻合，符合中国人的审美情趣，每件红木制品具有变化莫测的唯一性自然美。实用性：红木家具为人类生活所必须的用品。 总之，中国人对红木文化有很深的情缘，因为她是中华民族文化的象征，大到购置各种红木家具，小至各种小的工艺品，如小盒、挂件、手串，表示人们喜爱红木，喜爱中华文化；崇拜自然，回归自然；有文化，有身份地位的象征。 摘录自:中国林业科学院木材工业研究所网站]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
        <tag>红木</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木材的特点]]></title>
    <url>%2Fpassages%2F%E6%9C%A8%E6%9D%90%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[木材为古老而又年轻的绿色环保材料，广泛应用于小到牙签、筷子，大到家具及室内装饰，与我们的生活密切相关。尤其是当前日益火爆的建材市场上，木材作为重要的建筑材料，对人体健康有着直接重要影响，更得到人们的十分关注，所以研究木材对人体健康的保健功效十分必要。木材作为一种生物材料，经研究，较常用的砖、石、水泥、金属、塑料有如下主要优异的住室功效： 视觉功效木材纹理美观，色泽丰富，又能有效地吸收对人体眼睛有害的紫外线，因此使人视觉舒服、健康。 触觉功效人与木材接触时，四季温度相近，在木地板上行走时，软硬适当，又富有弹性，木材均给人以良好的触觉。 听觉功效木材为天然的多孔性材料，吸声、隔音性能良好。因此，用木质材料装饰的住宅，回声小，隔音效果佳，给人以舒适的安静感。 嗅觉功效多种木材经常散发出令人欢快的特殊芳香。经试验，这些芳香可产生对人体健康的保健功效。例如：冷杉，可舒解肌肉疼痛，使人产生温暖感受；柏木，能镇痛，并能镇静神经、松弛精神；樟木，抗痉挛，又具有兴奋作用；桉木，有激励精神的作用；檀香木，有镇静神经、抗抑郁的功效。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家具木材指南之实木篇]]></title>
    <url>%2Fpassages%2F%E5%AE%B6%E5%85%B7%E6%9C%A8%E6%9D%90%E6%8C%87%E5%8D%97%E4%B9%8B%E5%AE%9E%E6%9C%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[初识木材树木是地球上既宝贵又神奇的资源。通过一系列精心设计，去繁就简的工序，重获新生的木材成为了我们家中的家具。他们陪伴我们和家人一起生活，一同成长，随着时间推移，记录着生活留下的痕迹，成为世上专属你的家具。 钟情实木家具的人，多是喜欢实木的原始素材质感，浑然天成的纹理，温润窝心的感觉，或是欣赏榫卯结构的精湛工艺，在选购前，对木材的特性先有个基本认知，可以帮助我们买到心头好。 同时也要了解，木材是多孔性的有机体，特别是只用木蜡油作表面处理的，存在一定的呼吸性，会随环境的湿度和温度而变化，冷缩热胀以及实木家具不同部位的收缩及膨胀程度不同，会令家具产生开裂及变形。只要是天然的木材均是如此，但请放心，轻微的裂纹及局部变形不会影响家具整体的强度和结构。 另外，天然原木有一些不可避免的的天然瑕疵，包括独特的木纹，木色的变化，树眼，结疤，深色矿物线，斑纹，细小洞孔等等。由多块实木板组成的家具，木板与木板之间必然存在颜色及木纹的差异。 扫盲小贴士实木木材一块原木，或多块实木拼接，非压制而成。 实木家具全实木，或绝大部份是实木，小量其他物料（胶水、五金件）作辅助。 实木家具较贴皮和人造板好这样说其实不公允。不过实木的确贵很多，其大自然气息和质感亦难以模彷。 木蜡油涂层与传统漆油涂层木蜡油: 天然健康环保，保留木材原有质感，可自行作局部修复，局限是防水力较差，易有水印。传统漆油: 把木材完全密封，表面较滑，保护性及防水力较高，缺点是失去原木质感，对于刮花等用户难以自行修复。 原木色与染色原色: 纯天然，随机的，如碰撞擦花，痕迹不明显。染色: 选择多，可做到颜色平均，可遮盖木材天然瑕疵。刮花痕迹很明显。 实木家具实木或原木家具有两类： 整块木板都是由一块原木制成。 由多块原木拼接而成，市面上绝大多数实木家具都是这样制成的。 为何要拼接？一整大块的木材供应有限。面积越大，其天然瑕疵一般会越多。由多块木板组成的大板，如果工艺良好，开裂的概率会较一整大块原木为低。 上图展示木材最天然的状态，没有染色，没有涂上任何涂层，由左至右分别是：黑胡桃木，红橡木，樱桃木，榉木及白蜡木。加上涂层后一般会变深色。 非实木类泛指人造板，胶合板（夹板），密度板，纤维板，颗粒板，刨花板等。 在人造板表面贴上彷木皮或真木皮，坊间称为贴皮或饰面（Veneer）。 在相对较便宜的实木上，贴上较贵重的真木皮。例如在桦木上贴上胡桃木皮，有些说法认为这还是实木，站于生产商角度是其道理，但是对于消费者来说，这是相当易于混淆的。当商家声称一张餐桌的木材是胡桃木，又说是实木，那消费者会很自然地理解为整张餐桌是胡桃木实木制，但原来只是胡桃木皮。所以为了减少误会，不把这些归纳为实木类。 表面涂层用于木器表面的涂料 (又称涂层，涂装，涂饰) 有很多，可粗略地分为油漆 (Varnish / Lacquer)及木蜡油 (Wax Oil)。 油漆即以石化物料为基材的化学涂料，种类及名称众多，如 PU 漆，PE 漆，NC 漆等。上漆后的家具表面会有一层透明漆膜，完全将木材密封。漆膜的厚度视乎油漆种类而定，如 NC 硝基漆的漆膜相对较薄。但有些很夸张的，就像有一层厚厚的透明硬胶把木材覆盖。 使用油漆的好处是保护性强，耐磨，防水性高，日常打理较易。缺点是再触摸不到木材肌理，降低原有触感。油漆会随着时间老化，如龟裂或起泡，修补时要把整个区域的涂料完全磨掉，很难作局部修补。 木蜡油即以天然植物制成的环保涂料，主要成份包括亚痳籽油，向日葵油，棕榈蜡等等。其中油的成份会渗透木材内部起滋润作用。蜡的成份与木材的纤维牢固结合，可轻度阻止液体渗入，略为増加表面硬度和光滑度。涂在木器上，不会形成漆膜，用者仍然可以触摸到木材本身，表面散发柔和自然光泽，更能展现木材的天然美感。对使用者非常健康，亦易于修复轻微刮花。其限制是，只适用于实木上，无遮丑功能，不会大幅度地增加木材的耐磨性。因木材可自由呼吸，外界环境温度可直接影响含水率，木材出现变形及开裂的机会会略高于传统油漆。随着人们对环保愈来愈重视，更崇尚大自然，木蜡油的使用在近几年愈来愈流行。比如德国品牌 OSMO 及比利时品牌 BIOHOUSE。 常见木材最常见用于制作实木家具的木材，包括松木，桦木及橡胶木，其成本相对较低。 品质较佳价格较高的，包括胡桃木，橡木，樱桃木，榉木，柚木，白蜡木等等。 这些木材性质各有不同，例如胡桃木很名贵 (供参考，北美胡桃木价格可以比松木贵 6 - 9 倍)，榉木及樱桃木较细滑等，不过在一般家用层面来说，分别是有但不至于很大，反而用户对木材的感觉才重要。另外，美国和德国是全球众多木材出产大国中，森林管理水平最高的两个国家，林木蓄量持续增长，应予以支持。 榉木清新活泼，色浅柔和，木纹细且长，触感十分光滑。欧洲最重要的出口木材之一，其中以德国的为佳。 橡木坚毅谦厚气息，色泽淡雅，鲜明山形纹，手感亲切自然，能确实感受到木纹的肌理。红橡，木髓线较细。白橡，跟白色是没有关系的，实物色是偏黄的，常用于葡萄酒桶。 胡桃木气质高贵，风度翩翩，色深而优雅，木纹呈抛物线，清晰别致，富有层次感，触感介于榉木与橡木之间，细腻饱满。又名黑胡桃木，最名贵的常用木材之一，不同地区出产的分别很大，北美的公认最好。 樱桃木它独特的微红色，羞涩中流露出一份温暖和喜悦，犹如恋爱中的女士。樱桃木制的家具在外国较流行，美国出产。 白蜡木其鲜明均匀的纹路，予以十分粗犷豪迈的感觉，纵使手感还没有橡木般原始。色淡，浅棕至乳白。坚韧而富弹性。与中国东北及俄罗斯的水曲柳很相似，美国的较贵。 常见木材价格旨在提供一个初步的概念，十分粗略的比较： 相对便宜: 松木，橡胶木，桐木，桦木，楸木，杉木 相对较贵: 榉木，榆木，柚木，水曲柳，白蜡木，红橡木，白橡木，樱桃木 相对昂贵: 胡桃木，花梨木，黑檀木 非实木一定便宜很多？不一定。家具的价格有时和是否用实木没有太直接的关系。比如有些日本或者欧洲大品牌，用人造夹板或贴木皮，卖的价格比其他小品牌的实木家具高好多。 榉木一定比橡木便宜？其实两者的原木材成本相差并不太大，而由于榉木木材的利用率一般较高，所以变相地榉木家具的售价会便宜一点。 实例：橡木餐桌右图中的餐桌是一家大型日本家具公司的橡木餐桌，木蜡油涂层，售价约一万五千元。这家公司所卖的产品一向品质优良，这里借这个大品牌的餐桌做个例子，说明实木家具的几个特质： 树结 树结及纹理等天然特质是树木的一部份，正如图中的橡木餐桌有不少天然树结。 拼板 木匠会挑选优质实木切割拼接，制作成我们常见的实木家具。拼接有其好处，例如依然会受热胀冷缩的影响，但稳定性相对已较高。使用一整块不经切割的大木板是非常少见的。 木色 木材天然颜色犹如人的皮肤，要找到两个肤色一样的很困难，就算是同一个人，脸部与颈部的肤色可能已很不同，木材亦如是。另外，橡木原色多是这样的，偏黄。有时我们看到一些很浅接近白色的木家具，需要仔细判断，有可能是人造板 / 贴木皮 / 染了色的。 木材树种名称在中国，实木家具市场非常混乱。首先从实木的木材名称上来说，非常混乱。这里我根据之前的一篇有关我国木材名称的三大相关标准的博文，以 《中国主要木材流通商品名称》 为准，整理了市场上常见木材的名称及其对应的树种和流通商品名。需要注意的是，下面列出的木材名字是以《中国主要木材流通商品名称》这一国标的名字为准。比如市面上所说的硬枫木，这是该木材的流通商品名，其正式名称为硬槭木。每种木材下面附带了一段知乎用户 逸杯酒 对该木材的概述。 Top2 级，消费级实木家具里面能遇到的最好最贵的材料，从各个方面来说，都和后面级别的木料有明显的区别，名副其实的名贵木材。 花梨 / 大果紫檀 木材名称：花梨树种中文名：越柬紫檀、安达曼紫檀、印度紫檀、大果紫檀、囊状紫檀、鸟足紫檀、刺猬紫檀树种拉丁名：Pterocarpus.macrocarpus 等商品名：Padauk ambila流通商品名：花梨木科 别：Fabaceae 蝶形花科材色及气干密度（g/cm³）：心材黄褐、红褐至紫红褐色。具深色条纹，边材浅黄色。气干密度大于 0.76产 地：东南亚、非洲等 目前我们在消费家具市场上能遇到最多的国标红木，比他更好一些的奥氏黄檀（白酸枝）、交趾黄檀（红酸枝）可能就需要去专门的红木渠道才能遇到，算作收藏级的产品了。大果紫檀木性稳定，花纹美丽，价格也比较高，因为红木一般是按重量计价，而且没有分级规范，大多是根据货品一货一价，笼统地说现在大果紫檀每吨在 20000 以上，换算成立方价格也在 16000 以上，做成家具比如一桌六椅，差不多是 18000 往上。市面上的大果紫檀基本还是以制作传统形制的家具为多，这样的家具，料是一方面，工可能更重要，一件工料俱全的红木家具，即使是放一件在家里点缀，也是极好的选择。 黑核桃 / 黑胡桃 木材名称：黑核桃树种中文名：黑核桃树种拉丁名：Juglans spp.J.nigra商品名：Black walnut流通商品名：黑胡桃科别：Juglandaceae 核桃科材色及密度：心材紫褐至黑褐色，具黑色条纹，边材窄，黄白色。气干密度 0.56~0.67产地：美国、加拿大、法国、意大利等 黑胡桃是西方世界传统的顶级用材，目前在国内也可以说是风头无二，特点是绚烂的花纹和温暖的色泽，同时还具有出众的稳定性，密度也比较适中，从各方面来说，都是完美的家具用材。北美材的特点就是非常规范，会从级别、厚度、林场、长度四个维度（有些还会加上宽度）来决定木材的品质和价格。具体来说，级别从上到下分为 FAS、1com、2com，品级决定成品家具的瑕疵水平和拼板宽度，其中 FAS 级的成品以少量瑕疵或者无瑕疵的 10cm 以上拼版为主，1com 以少量瑕疵或者无瑕疵的 4-6cm 左右拼版为主，2com 几乎不可避免的在成品上留有大量瑕疵。北美材厚度以英制记，一般用的比较多的是 4/4 也就是一英寸料，产出的成品大概是 2.2-2.3cm，更厚的木料不仅用料更多，而且单位体积的单价也会迅速增加，大部分商家都会采用多层拼接的工艺来生产。黑胡桃的林场基本分为四个档次，MidwestWalnut 的黑胡桃（俗称三撇黑胡桃）地位超然是第一档，Hartzell（俗称哈索）等算是第二档，其他的美国林场直接处理的成品锯材为第三档，进口原木国内切分处理的是第四档。林场影响的更多的是 NHLA 标准中难以被量化的花纹，颜色和光泽，每一档的价差可能在 10% 以上。长度决定的是大件家具的花纹完整性，是一段一段的，还是可以一起连起来的，这个指标比较奢侈了。 C9 级，少数几种接近 Top2 级别的木料，相对于 Top2 来说，他们往往不够全面，或者有一些弱点，但同时也有自己的显著特点，甚至一些专业有不弱 Top2 的品质。 樱桃木 木材名称：樱桃木树种中文名：甜樱桃、黑樱桃树种拉丁名：Prunus spp.商品名：Sweet cherry, Black cherry流通商品名：樱桃木科别：Rosaceae 蔷薇科材色及气干密度（g/cm³）：甜樱桃：心材红褐至褐色，久转红色，边材暗红色，易蓝变。气干密度 0.63黑樱桃：心材暗红褐色，边材白色，宽 3~4cm。气干密度 0.58产地：法国、意大利、美国、加拿大等 樱桃和黑胡桃可以称为北美家具木材的双壁，但是就像北乔峰南慕容一样，后面这个基本还是要低半档。樱桃木的特点是手感极其细腻，类似于细织物的感觉，木材特别稳定，几乎是常用材中最稳定的一种，花纹非常柔和优雅，一直深受追捧。但樱桃同时富含矿物线，有大量的小结疤，白皮也比较严重，色差比较大，同时，樱桃软，容易磕碰，时间长了使用痕迹也比较多，不太适合对外观完美程度比较高的人。 和黑胡桃一样，樱桃木的价格也是从品级，厚度、林场、长度来衡量，但是这里蹦出来一个叫 Gutchess 的林场，这个林场以提供顶级樱桃木和白蜡木著称，它觉得 NHLA 的 FAS 级还不足以描述自己樱桃的牛掰，于是又把 FAS 级细分成了 6 个级别，其中最高的，叫做 F&amp;BP 级。目前，4/4 厚度，Gutchess 的 F&amp;BP 级，7 英尺以上长度的樱桃，大概是 9000 出头。更多的普通 FAS 级樱桃木差不多是 ￥ 8000/m³。樱桃也是在阳光下变色最快的木材之一，夏天的阳光直射情况下，初期可以看到每天都在明显变红。 硬槭木 / 硬枫木 木材名称：硬槭木树种中文名：黑槭、糖槭树种拉丁名：Acer spp. A.nigrum, A.saccharum商品名：Hard maple流通商品名：硬枫木科别：Aceraceae 槭树科材色及气干密度（g/cm³）：心材乳白至淡红棕色，边材色浅。气干密度 0.70产地：俄罗斯、北美、欧洲、朝鲜 硬枫比樱桃更贵一些。但是要注意的是，除了极少几个品牌，你们在普通家具市场看到的枫木，都不是硬枫。从外观上说，可以把硬枫理解成白色的樱桃木，同样优雅的花纹，同样高的稳定性，而且硬度更高一些，在国内目前还算是小众的家具用材，硬枫的市场细节我并不是很了解，前几天专门询了一下价，4/4，FAS 级大概在 ￥ 10000/m³ 出头。如果喜欢打桌球的话，硬枫是美式桌球杆最好的材料。 白栎 / 白橡 木材名称：白栎树种中文名：美洲白栎、二色栎、加州白栎树种拉丁名：Quercus.spp. Q.alba, Q.bicolor, Q.lyrata商品名：White oak流通商品名：白橡科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材灰褐色，边材灰白色带褐色。气干密度 0.63~0.79产 地：俄罗斯、北美、朝鲜、欧洲 白橡木的故事基本就够写一篇了。在西方传统中白橡木的地位非常高，我们可以在各种文学作品、名胜古迹看到橡木。甚至，英国女王马车的皇冠（实际是白栎中的夏栎）和美国总统白宫办公桌都是白橡制作的。但同时，白橡家具在国内的价格又很低，我们在淘宝上 2、3 千块，可能就能买到一张白橡的床，为什么会这样？从渊源上讲，国内最初是韩国人 90 年代在山东开厂做白橡木家具，利用白橡木在欧美的传统地位加上国内的低加工成本，出口欧美低端市场。那个年代的 Made in China 都懂的，确实可以通过各种手段把成本做到极低，08 年以后，大量当地的代工厂把产能转向国内，所以一上来就把定位、品质和价格都压的非常低，这是第一方面。同时，“白橡”在定义上并不足够明确，一般我们说的白橡是指北美的白栎（Quercus alba），但是从广义上来说，白橡也可以是产于东北亚的蒙古栎（Quercus mongolica）也就是俗称的柞木，后者的价格会便宜非常多，而且涂装以后，两者区分也很困难，也造成了大量低价蒙古栎进入市场，把成本做的更低，你还并不能说人家就是假货。最后还有臭名昭著的橡胶木，很多橡胶木卖家直接把橡胶木叫做白橡，或者橡木，更进一步摧毁了白橡的市场形象。一个在欧美被追捧了数百年的高档家具用材，就这样在国内被做毁了。故事讲完，我们来说正经北美白橡的特点。一般认为北美白橡是所有白栎木中品质最高的，富含侵填物，极耐水耐腐蚀，几乎不会有虫害，材质坚硬，相对于红橡，又能细腻，花纹更内敛一些。顶级的白橡在透明涂装以后，是一种温润的淡黄色，非常自然耐看，被现代日式作为正色大量使用。比如在三里屯，畏研吾设计的瑜舍酒店，就大量使用了白橡木作为主要元素。橡木的缺点是木质不够稳定，而且形变力量非常大，制作白橡家具，要尽量避免限制形变，而是通过预留余量，让木材自由伸缩。同时白橡木色差相对比较大，出材困难，如果选料控制不佳，很容易出来乱七八糟的面板。美国几乎所有的木材公司都有白橡木的产品，除了 NHLA 分级标准对瑕疵的控制以外，白橡木好坏最大的区别就是色泽，越好的白橡颜色越纯，而普通品级的白橡会更多的在花纹间出现青色和灰色的部分。Augusta 和 Matson 的白橡一般认为拥有更高的品质，前段时间，FAS 级 4/4 的 Augusta 白橡报价居然超过了 9300/m³，压了 Gutchess 的 F&amp;BP 樱桃木一头，目前回落以后也在 8600 左右。其他普通品牌的更多在 7000 多到 8000 出头的区间。 白栎 / 白橡 木材名称：白栎树种中文名：欧洲栎树种拉丁名：Q.robur商品名：White oak流通商品名：白橡科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材灰褐色，边材灰白色带褐色。气干密度 0.63~0.79产 地：俄罗斯、北美、朝鲜、欧洲 小鞋木豆 / 斑马木 / 乌金木 木材名称：小鞋木豆树种中文名：小鞋木豆树种拉丁名：Microberlinia spp. M.brazzavillensis商品名：Zebrawood流通商品名：斑马木、乌金木科 别：Caesalpiniaceae 苏木科材色及气干密度（g/cm³）：心材浅褐色，具深浅相间黑褐色条纹，边材白色，宽 8cm~10cm。气干密度 0.73~0.80产 地：加蓬、喀麦隆等 乌金木很厉害，作为一个非洲产的非红木类散孔材，居然冲到了 C9 的档次，在他身后，985 和 211 里面也几乎找不到这样的木材。我先解释一下散孔材，我们从小认识的木材都是有年轮的，每一年一个圆圈，形成一个一个的同心圆，木材切开以后，这些同心圆，也就构成了木材上那些细细的抛物线，或者叫山形纹。但并不是所有的木材都是这样，只有环孔材和半环孔材才有明显的年轮，散孔材是没有的，所以切开以后也没有明显的细细的抛物线花纹，更多的是大块大块的色斑——就像斑马的纹路一样。乌金木更早在木材市场就叫斑马木，一直卖的不算好，改叫乌金木以后忽然就火遍了大江南北，价格一路往上，目前虽然有所回调，每立方价格也在 9000 以上，压了传统高档材樱桃和白橡一头。乌金的成功开了一个坏头，从那以后，非洲材东南亚材都不好好叫自己的名字了，各种金丝，黄金之类的名称开始泛滥，不过目前还没见哪个复制了乌金的成功。客观来说，乌金木光泽绚烂，材质干净，少见结疤瑕疵，目前市场接受度很高，价格也足够高，缺点是木质不太稳定，容易开裂，甚至在加工过程中，就容易因为内应力爆裂，对工艺要求比较高。 985 级，标准的高档材，虽然称不上名贵，当也是实木家具中的佼佼者，物理性质通常比较优秀，而且都具有优美的花纹，一般都是温带阔叶材。 白蜡木 木材名称：白蜡木树种中文名：美洲白蜡木树种拉丁名：Fraxinus spp. F.americana商品名：Ash流通商品名：白蜡木科 别：Oleaceae 木犀科材色及气干密度（g/cm³）：心材浅暗灰褐色，边材黄白色，宽 1~2cm，有酸臭气味，蜡质感强。气干密度 0.60~0.72产 地：加拿大、美国等 白蜡木是所很有特点的高校，首先他所在的城市特别好，收益于北美材良好的分级处理水平，这个产地的木料，自动就比别的地方高半档。综合实力上，白蜡木并不出众，这里我又要说一个边材和芯材的概念，绝大部分木材，靠近树心的局域和靠近树皮的区域，材质颜色差别很大，分别叫芯材和边材，一般来说，芯材比较深范围比较大，边材比较浅范围很小，实际中主要使用芯材，比如黑胡桃，比如樱桃，都一样。白蜡不是，白蜡浅色边材范围很大，是主要的使用部分，但是芯材是在内部，又很难去掉，这就造成了白蜡都是芯材边材混用，色差非常明显，出来的外观实在算不上好看。但是，这个学校有一个非常牛的专业，也就是 Gutchess 公司提供的 F&amp;B 级材（国内俗称特选白，是 Gutchess 公司对 FAS 级白蜡再细分四个档次以后最高的品级），这种材料在加工中几乎完全去掉了芯材，最后提供的成品，拥有几乎所有实木中最小色差。传说中的王牌专业就是这种。Gutchess 的 F&amp;B 材辨识度非常高，你看白蜡家具外表面几乎都是纯净的浅色就是了，其他林场的白蜡，一定有大块的深色斑痕。白蜡本身的物理性质中规中矩，木质相对粗一点，但是切面却又特别光滑，花纹特别大气硬朗，喜欢的很喜欢，也有很多人接受不了。价格上，4/4 的 Gitchess F&amp;B 白蜡的价格大概在 6900 左右，其他的林场，基本也就是 6000 出头这样。 红栎 / 红橡 木材名称：红栎树种中文名：美洲白栎树种拉丁名：Quercus.spp. Q.rubru商品名：Red oak流通商品名：红橡科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材暗红褐色，具深色条纹，边材近白色，宽 4cm~6cm。气干密度 0.66~0.77产 地：法国、土耳其、美国、加拿大等 红橡一直是作为白橡的替代材使用的。在前面已经说到白橡原料成本高，成品价格低，再加上色差比较大，出材率低，对家具制造商来说，不是一个好的选择，所以在 10 年前后，很多家具商就转头做那时候还很便宜的红橡。抛开这个以外，红橡也是一种非常理想的家具用材，北美材处理分级水准都比较高，红橡相对白橡色差小，瑕疵少。材质也同样比较坚硬，花纹更大更粗犷一点，虽然缺少侵填物，没有白橡的防水性能，但是作为家具其实也没什么影响。缺点可能是颜色偏红偏暖一些，调调稍微差了一筹。红橡由于本身品质比较均衡，也没有那种公认比较顶级的林场，目前 4/4 的 FAS 级材，价格基本也就是 6000 多一些，和普通白蜡类似，低于白蜡的王牌专业。另外我想说一句，市场上传说的“白橡不白，红橡不红”，前半句倒是没有太大问题，白橡确实是偏黄色更多一些，但是红橡明显相对更红，这个只要见过实物的人应该都能感受到。 211 级，这个级别里我们能够看到很多传统家具用材，之所以传统，很大程度上就是因为他们的物理性能比较适合制作家具使用，长时间里都被人们接受。这个级别里的一些木材和 985 的木料亲缘关系很近，只是因为产地问题品质略差一点，也很像那些同源不同城的高校一样。 水曲柳 木材名称：水曲柳树种中文名：水曲柳树种拉丁名：Fraxinus spp. F.mandshurica商品名：Ash流通商品名：水曲柳科 别：Oleaceae 木犀科材色及气干密度（g/cm³）：心材褐或浅栗褐色，边材黄白或黄褐色，宽 2cm。气干密度 0.68产 地：东北、华北、陕等 水曲柳和白蜡的性能高度接近，而且价格上涨迅速，目前好的水曲柳价格也已经到了 5000 多，和普通白蜡木相比，可能就是差一个产地，一个分级处理水平了。 扩展阅读：别再拿水曲柳当白蜡卖了 白栎 / 蒙古栎 / 橡木 木材名称：白栎树种中文名：柞木树种拉丁名：Q.mohgolica商品名：Mongolian oak流通商品名：橡木、蒙古栎科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材褐至暗褐色，有时带略黄，边材淡黄色带褐，宽 2cm。气干密度 0.63~0.79产 地：俄罗斯、朝鲜、蒙古等 首先要强调，这里说的白栎是主要产于俄罗斯和蒙古的柞木，大家在市场上听到的所谓欧洲橡木可能大多数是这种，而非欧洲橡木。真正的欧洲橡木，欧洲栎（Quercus rabur）产于西欧，又以卢浮栎、夏栎最为知名。简单说，蒙古栎的外观，性质和美国白橡都非常接近，很多会直接冒充美国白橡使用，区别是瑕疵多一些，所以板宽会窄一些，花纹间的灰色，青色填充物更多，颜色更深更暗一点，不过老实说，很多时候我也分不出来。除此以外，栎木类一般形变都比较大，好的白橡红橡成品锯材在美国经过非常严格的烘干处理，相对还好，蒙古栎很多都是从俄罗斯进口原木，国内处理，这方面做的还是差一些，后期问题可能会更大一些。北京西北郊的阳台山山脚附近有大量的槲栎、蒙古栎，喜欢爬山的朋友应该都是见过的。 榆木 / 青榆 / 黄榆 木材名称：榆木树种中文名：裂叶榆、大果榆树种拉丁名：Ulmus spp. U.laciniata, U.marcocarpa商品名：Elm流通商品名：青榆、黄榆科 别：Ulmaceae 榆科材色及气干密度（g/cm³）：心材黄褐至浅红褐色，边材浅黄至黄褐色。气干密度 0.54~0.66产 地：东北、华北、西北、青、甘、鲁、豫等 说榆木，就绕不开“老榆木”的概念，我们经常可以听到商家说，“别人家的榆木容易裂，我们家的是老榆木，都是旧房子几十年的房梁拆下来的，不会裂”。这话对不对？我们分成两部分说：有没有人真的拿拆房梁的老榆木做家具，不是老榆木是不是就真的容易裂。第一，有，我们现在仍然能够在传统家具作坊看到使用老榆木作为原材料，但是，如果是一个现代工业品牌，这个说法就扯淡了，靠拆老房子出来的那点料，根本不可能作为一个规模企业的稳定供应渠道，实际上目前市面上的规模企业，几乎都是使用的俄罗斯进口榆木。第二，不对，榆木因为自然干燥困难，过去只能通过几年，十几年的放置让他缓慢干燥，这样就可以减轻变形，也就老榆木不变形的说法的由来。但是实际上，在现代烘干工艺面前，榆木并不算什么特别难干燥的木料，合格处理的“新”榆木，完全可以作为合格的家具用材使用。同时，俄罗斯进口的“新”榆木，因为树径更大，普遍拥有更好的纹理，更小的色差，更纯净的颜色，甚至可以说也是一种理想的家具用材。 水青冈 / 欧洲山毛榉 木材名称：水青冈树种中文名：欧洲水青冈树种拉丁名：Fagus.spp F.sylvatica商品名：European beech流通商品名：欧洲山毛榉科 别：Fagaceae 壳斗科材色及气干密度（g/cm³）：心材浅黄褐色带微红，久转浅红褐色，边材白色，宽 2cm。气干密度 0.67~0.72产 地：法国、德国、比利时、美国等 也叫山毛榉，或者叫欧洲榉木，是一种壳斗科的木料，亲缘关系更接近橡木，我们可以在上面看到类似橡木的细小木射线。山毛榉的木材相对于橡木更加细腻一些，瑕疵更少，色差更小，但是花纹也更浅一些，几乎看不出来，做出来的家具没有那么好看，所以也要便宜很多。目前从德国和罗马尼亚进口的山毛榉价格大概在 4800-5100。物理性质上，山毛榉没有橡木那么爱裂，但是更爱翘曲形变，所以在制作的过程中，也要注意采用合理的结构和工艺。和蒙古栎一样，北京西郊阳台山山脚也有大量的山毛榉混植，挂的牌子是水青冈，秋天他们的果实会落的满地都是。 亚花梨 / 非洲紫檀 木材名称：亚花梨树种中文名：非洲紫檀树种拉丁名：P.soyauxii商品名：African padauk流通商品名：非洲紫檀科 别：Fabaceae 蝶形花科材色及气干密度（g/cm³）：心材黄褐、红褐至紫红褐色。边材蓝白色，宽 5cm~8cm 气，具波痕，略有香气。气干密度 0.50~0.72产 地：莫桑比克、坦桑尼亚、加蓬、喀麦隆等 实际上，市面上现在都直接叫非洲花梨，有些甚至直接叫花梨木了，不属于国标红木，但是也还可以，档次和榆木差不多，一般用来做低端的传统造型家具。 桤木 / 美国赤杨 / 赤桦 / 北美桤木 / 南美樱桃木 木材名称：桤木树种中文名：桤木树种拉丁名：Alnus spp.商品名：Alder流通商品名：科 别：Betulaceae 桦木科材色及气干密度（g/cm³）：木材乳黄至浅黄褐色。气干密度约 0.65产 地：北美 赤杨和黄杨是北美进口的阔叶林中价格最低的两种，其中，赤杨主要的用途就是仿冒樱桃木。赤杨的手感和花纹与樱桃非常相似，几乎可以乱真，密度略低，但是也还接近，主要区别在颜色和矿物线上，但是经过有色漆的涂装也都可以掩盖过去。如果存心造假，除非极有经验，否则很难分辨。即使被揭穿以后，很多商家也会说这是南美樱桃木搪塞过去。同时，南美樱桃木也可能是指另一种仿冒樱桃木的木材，这个会在后面介绍，国内木材名的混乱也可见一斑。 美国黄杨 / 北美鹅掌楸备注：此木材未在《中国主要木材流通商品名称》 WB/T1038-2008 标准上找到，对该木材的信息均引自知乎用户。 树种中文名：北美鹅掌楸树种拉丁名：Liriodendron tulipifera商品名：Yellow poplar科 别：Magnoliaceae 木兰科产 地：北美 得益于北美高水准的木材分级处理工艺，鹅掌楸这种传统主要做辅料的木料，现在使用的场景也越来越多了，而且价格不低。但老实说，鹅掌楸密度实在有些太低，强度也不太好，作为主材使用，物理性质还是稍差一些的。鹅掌楸本身色差也比较大，花纹很浅，外观不算好看，主要还是涂上深色漆做美式家具使用。 楸木 / 核桃楸 / 胡桃楸楸木是我们经常在家具市场听到的一个名词，但是也是最乱的一种。就跟柞木不是柞木一样，家具市场上的楸木并不是楸木： 树种中文名：楸木 / 梓木树种拉丁名：Catalpa spp. C.ovata duclouxii Dode商品名：梓树流通商品名：梓桐木科别：Bignoniaceae 紫葳科材色及气干密度（g/cm³）：心材深灰褐色，边材灰黄褐色。气干密度 0.47产地：滇、川、鄂、黔、闽、陕 理论上，家具市场上的楸木实际是核桃楸，这个： 树种中文名：核桃楸树种拉丁名：Juglans spp. J.mandshurica商品名：Walnut流通商品名：楸木科别：Juglandaceae 核桃科材色及气干密度（g/cm³）：木材红褐或粟褐色，具紫色条纹，久转巧克力色，边材前黄褐色或浅粟褐色。气干密度 0.52产地：东北各省、河北、陕西 真正的胡桃楸是非常好的家具用材，物理性质与黑胡桃类似，花纹也非常接近，只是缺少黑胡桃的光泽，同时颜色不是栗褐色或者紫褐色而是浅灰黄色。但是实际上我只在两家非常高端的家具品牌看到过真正的胡桃楸。市面上绝大多数的“胡桃楸”，其实是后面会讲到的各种东南亚进口的散孔材，XX 胡桃这种。普通消费者来说，听到“胡桃楸”，就当做是最后这种情况考虑就可以了。那么真的胡桃楸都去哪了呢——染成栗褐色冒充黑胡桃去了，因为质感外观都与黑胡桃高度接近，染色后的胡桃楸迷惑度很高。 普通本科，市面上最大量的实木家具落在这个级别，撑起了实木家具的大半个江山，他们通常是来自非洲南美和东南亚的散孔材，但是作为家具使用，其实也是很具有性价比的选择。这个级别的木料通常不会直接使用自己的本名出现在市场上，他们很热衷于给自己改名字，通常都是加上华丽的形容词再去抱一个名贵木材的大腿。而且名称还会经常变化，很容易就把人搞晕了。这类木材的特点是缺少细的清晰的抛物线花纹，多是粗且散乱的色斑，很多木材在涂装以后还会有亮亮的光泽。这个级别内的木材互相之间辨识度不高，很多时候甚至名字都会混用，价格基本也都在 2000 多到 4000 多的区间内，所以下面的部分我会写的比较简略，有特点的说特点，没特点就直接略过了。 印咖木 / 菠萝格 木材名称：印咖木树种中文名：印咖木树种拉丁名：Itsia spp. I.bijuga商品名：Merbau kwila流通商品名：菠萝格科 别：Caesalpiniaceae 苏木科材色及气干密度（g/cm³）：心材褐至暗红褐色，边材浅黄白色，含硫磺色沉积物。气干密度 0.80产 地：马来西亚、印尼、巴新、斐济 、所罗门群岛等 这种木材做大板桌或者地板比较多，很少用在家具上。 奥克榄 / 红檀木 / 奥古曼 树种中文名：奥克榄树种拉丁名：Aucoumea spp. A.Klaineana商品名：Okoume科 别：Burseraceae 橄榄科材色及气干密度（g/cm³）：心材橙红至浅红褐色，边材窄，灰白色。气干密度 0.48产 地：加蓬、喀麦隆、赤道几内亚等 也会叫做红胡桃，奥古曼的密度实在有点低，强度还不如松木，其实不太适合作为家具主材使用。 硬合欢 / 大叶合欢 木材名称：硬合欢树种中文名：大叶合欢树种拉丁名：Albizia spp. A.lebbek商品名：Kokko科 别：Mimosaceae 含羞草科材色及气干密度（g/cm³）：心材黑褐色，边材色浅。气干密度约 0.68~0.82产 地：东南亚 橡胶木 木材名称：橡胶木树种中文名：橡胶树树种拉丁名：Hevea spp. H.brasiliensis商品名：Rubber wood流通商品名：橡胶木科 别：Euphorbiaceae 大戟科材色及气干密度（g/cm³）：木材乳黄至浅黄褐色。气干密度约 0.65产 地：马来西亚、印尼、缅甸、越南、亚马逊等 关于橡胶木各种材料上已经够多了，一般认为橡胶木的稳定性不太好，所以绝大部分情况下会以指接板的形式使用。这里主要谈市面上关于橡胶木的两种说法。首先是卖家经常会说橡胶木是热带材，防水，所以特别适合浴室柜。荒谬，热带材和防水没有任何关系，橡胶木防水的说法，很大程度上是因为他经常自称橡木，而白橡木确实是有出众的防水能力的，但是这个能力和橡胶木没有任何关系。另一个说法是说，橡胶木都是用药水泡出来的，所以污染很大，实际上他们翻出来的所谓橡胶木泡药水的材料，是使用硼砂溶液对橡胶木进行杀虫反腐的过程，这个过程几乎所有的木材都会经历，上至 TOP2 也不例外，不会产生任何有机挥发物，和污染没有毛线关系。实际上市面上橡胶木产品往往污染很大，并不是橡胶木本身的问题，而是因为橡胶木定位低，价格便宜，所以配用的油漆通常都很差，又因为用在卫生间等潮湿区域，油漆又会刷的很厚，最后污染自然就大了。 专科院校，实木家具的有益补充，一般是作为辅料或者临时简易家具用料使用，很少直接作为成品主材。 桦木 木材名称：桦木树种中文名：高加索桦木树种拉丁名：Betula spp. B.medwediewii商品名：Birch bereza流通商品名：桦木科 别：Betulaceae 桦木科材色及气干密度（g/cm³）：木材黄白色略带褐，有淡红褐色假心材。气干密度 0.55~0.67产 地：俄罗斯等 桦木家具我们可能只有在宜家才能看到，再就是做软包沙发的内框了，材质脆，容易开裂，但是桦木的外观和樱桃木非常接近（另一个经常用来仿冒樱桃的美国赤杨也是桦木科），所以要小心那些便宜的离谱的“樱桃木”家具，很可能是桦木仿冒的。 泡桐 木材名称：泡桐树种中文名：泡桐树种拉丁名：Paulownia spp. P.fortunei.商品名：Paulownia流通商品名：泡桐科 别：Scrophulariaceae 玄参科材色及气干密度（g/cm³）：木材浅灰至浅灰红褐色，新材有奇臭气味。气干密度 0.24产 地：黄河流域西至秦岭 应该是我们能接触到的最便宜最轻最疏松的木材，因为过于疏松，吸水率也比较高，夏天下雨的情况下，容易有霉变黑斑，一般来说，不太建议使用。 硬松木 / 马尾松 / 松木 木材名称：硬松木树种中文名：马尾松树种拉丁名：Pinus spp. P.massioniana商品名：Hard pine流通商品名：松木（本松）科 别：Pineaceae 松科材色及气干密度（g/cm³）：心材红褐色，边材黄褐或浅红褐色，易蓝变，具油性感，有松脂香气。气干密度 0.44~0.64产 地：南方各省 硬松木 / 樟子松 木材名称：硬松木树种中文名：樟子松树种拉丁名：Pinus spp. P.syvestris商品名：Hard pine流通商品名：樟子松科 别：Pineaceae 松科材色及气干密度（g/cm³）：心材浅红褐色，边材窄，浅黄褐色，易蓝变，具树脂圈，有松脂香气。气干密度 0.44~0.47产 地：大兴安岭、内蒙古等 硬松木 / 云南松 / 青松 木材名称：硬松木树种中文名：马尾松树种拉丁名：Pinus spp. P.yunnanensis商品名：Hard pine流通商品名：青松科 别：Pineaceae 松科材色及气干密度（g/cm³）：心材浅红褐色，边材黄褐色，易蓝变，有松脂香气。气干密度 0.44~0.62产 地：云、贵、川、桂等 其他，暂未分类 水青冈 / 山毛榉 木材名称：水青冈树种中文名：水青冈树种拉丁名：Fagus spp. F.longipetiolata商品名：Beech流通商品名：山毛榉科 别：TFagaceae 壳斗科材色及气干密度（g/cm³）：心材红褐色，边材黄褐至浅红褐色，有时渐变。气干密度 0.78产 地：滇、鄂、川、陕、豫等 榉木 / 大叶榉 木材名称：榉木树种中文名：榉树树种拉丁名：Zelkova spp. Z.schneideriana商品名：Elm流通商品名：大叶榉科 别：Ulmaceae 榆科材色及气干密度（g/cm³）：心材暗褐至浅栗褐色，边材黄褐色，有微苦味。气干密度 0.79产 地：秦岭、长江流域中下游、闽、桂、滇 杉木 木材名称：杉木树种中文名：杉木树种拉丁名：Cunninghamia spp. C.lanceolata商品名：Chinese fir流通商品名：杉木、杉树科 别：Taxodiaceae 杉科材色及气干密度（g/cm³）：木材浅栗褐或浅灰红褐色，边材浅黄褐或浅灰褐色微红，有浓郁杉木香气。气干密度 0.31~0.41产 地：南方各省 参考链接 现在实木家具价格排序和优缺点？ - 知乎 中国木材网 提供各种木材的实时报价 美国工程木材协会 提供工程木材方面的信息 craft wood products 做的很漂亮的一个有关木制品设计的网站 my harmony 一家来自香港的家具商 中国林业科学院木材工业研究所网站 如何购买实木复合地板 《中国人造板》杂志 网站现在已经没有运营了 木材的特点 关于中国主要木材的三大相关标准 如何选择家具的木材 youtube 上的一个木匠 家具木材科普 - HowStuffWorks 几种适合现代家具的实心木材 阅木 数据和资料并不准确，对木材的分级更是匪夷所思，比如橡胶木和白橡木分级完全一样。网页界面做的可以，需自行甄别，适度参考。]]></content>
      <tags>
        <tag>木材</tag>
        <tag>百科知识</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：原型与继承]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型每个 JavaScript 中的对象都有一个特殊的内部隐藏属性 [[prototype]]，它要么指向 null，要么指向另一个对象，我们称之为原型。当我们从一个对象上读取某个属性，如果在对象本身上没有找到，那么 JavaScript 引擎会尝试从它的原型中去寻找。 原型属性 [[prototype]] 虽然是内部隐藏的属性，但是有一些方法可以获取到它。 __proto__其中之一是 __proto__，但是 __proto__ 并不完全等同于原型，只是由于历史原因，各个浏览器包括 NodeJS 都部署了这一属性，实际开发中应该使用 ES 规范中的更现代的设置原型的方法，后面会提到。考虑如下代码：12345678910111213// 代码片段 1const animal = &#123; eats: true&#125;;const rabbit = &#123; jumps: true&#125;;rabbit.__proto__ = animal;console.log(rabbit.jumps); // trueconsole.log(rabbit.eats); // true rabbit 对象本身没有 eats 属性，但是因为让它的原型指向了 animal 对象，这时我们可以说 animal 是 rabbit 的原型。所以引擎会在 rabbit 没有某个属性时从其原型 animal 上获取。 因此，我们可以将许多有用，但是更加通用的属性放到抽象程度更高的对象中，显然，在这里是 animal：123456789101112131415// 代码片段 2const animal = &#123; eats: true, walk() &#123; alert("Animal walk"); &#125;&#125;;const rabbit = &#123; jumps: true, __proto__: animal&#125;;// walk is taken from the prototyperabbit.walk(); // Animal walk 现在 rabbit 通过原型，继承了 animal 的共同属性 eats 和 walk。原型链 prototype chain 还可以更长：123456789101112131415161718192021// 代码片段 3const animal = &#123; eats: true, walk() &#123; alert("Animal walk"); &#125;&#125;;const rabbit = &#123; jumps: true, __proto__: animal&#125;;const longEar = &#123; earLength: 10, __proto__: rabbit&#125;;// walk is taken from the prototype chainlongEar.walk(); // Animal walkalert(longEar.jumps); // true (from rabbit) 现在，按照抽象程度由低到高形成了一条原型链：longEar -&gt; rabbit -&gt; animal。 原型链的限制对于原型链来说主要由下面 3 条限制： 原型链不能构成环，否则引擎将会抛出错误，在上面的例子中，即不能再将 animal 的原型指向 longEar。 __proto__ 的值类型要么是 null，要么是 Object，即另一个对象。所有基本类型的值会被忽略。 一个对象只能有一个原型，即不能继承两个父级。 this 的值当对象调用原型的方法时，this 的值是指代原型还是对象本身呢？下面的代码清晰的说明了这一问题：123456789101112131415161718192021const user = &#123; name: "John", surname: "Smith", get fullname() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set fullname(value) &#123; [this.name, this.surname] = value.split(" "); &#125;&#125;;const admin = &#123; name: "Norah", surname: "Jones", isAdmin: true, __proto__: user&#125;;console.log(admin.fullname); // Nora Jonesadmin.fullname = "Michael Jackson";console.log(admin.fullname); // Michael Jackson 不管某个方法是在对象本身上，还是在其原型上，this 永远指向 . 运算符前面的对象。 F.prototype我们知道，对象除了可以使用字面量创建，还可以使用 new F() 形式的构造函数来创建。请注意，构造函数本质上依然是函数，JavaScript 中的每个函数都具有一个特殊的 prototype 属性。默认情况下，它是一个仅包含 constructor 属性的对象（不包括每个对象的隐藏属性 [[prototype]]，因为函数也是对象），其中 constructor 指向函数本身：1234const F = function () &#123; &#125;;console.log(F.prototype); // &#123; constructor: f &#125;console.log(F.prototype.constructor === F); // true 如果我们让 F.prototype 指向一个对象，那么在使用 new 操作符调用构造函数 F 时，新创建的实例的原型 [[prototype]] 都将被指向这个对象。示例：12345678910111213141516const animal = &#123; eats: true&#125;;const Rabbit = function(name) &#123; this.name = name;&#125;;Rabbit.prototype = animal; // 设置所有 Rabbit 创建的实例的原型为 animalRabbit.prototype.construtor = Rabbit; // 修正 Rabbit 原型的 constructor 的指向 (*)const rabbit = new Rabbit('white rabbit');console.log(rabbit.eats); // trueconsole.log(rabbit.__proto__ === animal); // trueconsole.log(rabbit.constructor === Rabbit); // true 上面的代码中，另一个需要注意的问题是 F.prototype.constructor 的值。改变构造函数 F.prototype 的默认指向，如果接下来（之前创建的实例不会受到影响）使用到其新创建的实例的 construtor 属性，会导致意想不到的错误。拿上面的例子来说，如果没有 (*) 这一行代码，rabbit.constructor 的值将会指向 animal，显然这在人意料之外，也不合理。所以，普遍的共识是：不要依赖 constructor 这一属性，因为它能被任意修改。 有时候，我们需要使用某个实例的构造函数来创建一个实例，但是却不知道它的构造函数。这时可以这样做，但是需要小心：1234567const User = function(name) &#123; this.name = name;&#125;;const user = new User('Bill');const user2 = new user.constructor('Sunny');alert(user2.name); // Sunny 上面的代码可以如正常运行，因为构造函数 User 的 prototype 的指向是默认的，指向其自身。假如修改一下代码，改变其指向：12345678const User = function(name) &#123; this.name = name;&#125;User.prototype = &#123;&#125;;const user = new User('Bill');const user2 = new user.constructor('Sunny'); // (*)alert(user2.name); // undifined 我们来看看 (*) 这一行发生了什么： 首先引擎会在 user 对象上查找 constructor 属性，没有找到。 接着引擎会沿着原型链查找，user 的原型是 User.prototype，它是一个空对象 {}，没有找到。 空对象 {} 的原型是 Object.prototype，而 Object.prototype.constructor === Object。所以实际执行的是 new Object(&#39;Sunny&#39;)，而内置的对象构造函数会忽略所有参数，所以得到如上结果。 Object.prototype让我们来看下面的代码：12const obj = &#123;&#125;;alert(obj); // [object Object] 为什么会有以上的输出？我们定义的对象是空的，是哪里来的代码生成了 [object Object] 这样的字符串信息？答案是内置的 toString 方法。通过字面量创建对象等同于使用对象构造函数 new Object()。而 Object 构造函数就像所有函数一样，也有一个 prototype 属性，它指向了一个很大的对象，上面部署了 constructor, toString, valueOf 等一系列所有对象通用的方法和属性。 以下代码可以检查上面所说：1234const obj = &#123;&#125;;alert(obj.__proto__ === Object.prototype); // true// obj.toString === obj.__proto__.toString == Object.prototype.toString 另外，Object.prototype 这个内置的原型的 [[prototype]] 指向了谁呢？答案是 null:1alert(Object.prototype.__proto__); // null 其他抽象程度稍低的一些内置对象，比如 Function，Array，Date 等，也部署了一些方法在其原型上。这样每一个函数实例，数组实例或者日期实例，都可以使用一些内置于其原型上的方法了。这样设计的目的非常利于节省内存。下面这张图局部地说明了这种关系。 我们可以手动地验证一下：12345678910const arr = [1, 2, 3];alert(arr.__proto__ === Array.prototype); // truealert(arr.__proto__.__proto__ === Object.prototype); // truealert(arr.__proto__.__proto__.__proto__); // nullconst f = function() &#123;&#125;;alert(f.__proto__ === Function.prototype); // truealert(f.__proto__.__proto__ === Object.prototype); // true 基本类型的原型对于 String, Number, Boolean 这 3 种基本类型而言，当访问它们的属性时，会使用内置的构造函数（比如 Number()）创建一个临时的封装对象，然后访问这个临时封装对象原型上的属性或者方法，访问完成后临时对象就消失了，这一过程对我们来说都是不可见的。 对于 null 和 undefined 而言，不会有自动创建临时封装对象这一过程，因为它们没有可用的属性或者方法，也就没有内置的原型。 设置原型的现代方法我们应该只考虑以下 3 种现代的设置原型的方法： Object.create(proto[, descriptors]) - 以给定的 proto 作为原型，创建一个新的空对象，descriptors 是可选参数，代表属性描述符。 Object.getPrototypeOf(obj) - 返回对象的原型。 Object.setPrototypeOf(obj, proto) - 将 obj 的原型设为 proto。 让我们用更标准、现代的方法改写前面的例子：1234567891011121314const animal = &#123; eats: true&#125;;const rabbit = Object.create(animal, &#123; jumps: &#123; value: true &#125;&#125;);alert(rabbit.eats); // truealert(Object.getPrototypeOf(rabbit) === animal); // trueObject.setPrototypeof(rabbit, &#123;&#125;); // 改变 rabbit 的原型，使其原型为一个空对象 使用原型方法进行浅拷贝123const origin = &#123;...&#125;;const clone = Object.create(Object.getPrototypeOf(origin), Object.getOwnPropertyDescriptors(origin)); 上面的代码，以源对象的原型为原型，加上源对象的所有属性描述符选项，复制了所有源对象的属性，不管是可枚举属性还是不可枚举属性，数据属性还是访问属性，也包括了 Symbol 属性；同时有着相同的原型。 让我们看一个详细的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 源对象const origin = Object.create(null, &#123; 'name': &#123; value: 'Sheldon', writable: true, enumerable: true, configurable: true &#125;, 'surname': &#123; value: 'Cooper', writable: true, enumerable: true, configurable: true &#125;, 'fullname': &#123; get() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set(value) &#123; [this.name, this.surname] = value.split(' '); &#125; &#125;, [Symbol('id')]: &#123; value: 9527, writable: false, configurable: true, enumerable: true &#125;, 'toString': &#123; value: function () &#123; return 'custom toString!' &#125;, writable: true, enumerable: false, configurable: true &#125;&#125;)// 浅拷贝const clone = Object.create(Object.getPrototypeOf(origin), Object.getOwnPropertyDescriptors(origin));// 可枚举属性和 Symbol 属性复制成功console.log(clone); // &#123; name: 'Sheldon', surname: 'Cooper', [Symbol(id)]: 9527 &#125;// 不可枚举属性复制成功console.log(clone.toString()); // custom toString!// 访问属性复制成功console.log(clone.fullname); // Sheldon Cooper// 原型复制成功console.log(Object.getPrototypeOf(clone) === null); // true 上面代码的源对象是一个出于演示目的而定制的，包含了可枚举属性和不可枚举属性，数据属性和访问属性，以及 Symbol 属性，从最后的打印结果可以看到，拷贝对象全部成功地复制了过来。 不要轻易在初始化更改原型设置以上面的代码为例，如果我们在一开始让 rabbit 以 animal 为原型，接下来不要轻易更改 rabbit 的原型，因为引擎会对已有的原型继承做很多属性读取之类的优化，更改原型会破坏这些已有的优化，导致运行速度变慢。 纯字典对象假设我们想要实现一个纯字典对象，即包含一切合法字符串为键的键值对，使用通常的字面量对象会有一个问题：有一个特殊的字符串 __proto__ 无法如预期般奏效。123456const dictionary = &#123; '__proto__': 'some value'&#125;;alert(dictionary.__proto__); // [object Object]alert(dictionary.__proto__ === Object.prototype); // true 上面的属性读取无法得到预期的 some value 结果，因为通常字面量创建的对象，默认原型是 Object.prototype ，而因为历史原因 __proto__ 这一特殊属性被当做访问原型的途径。如果将其赋值为基本类型值，赋值操作将会被忽略。 如何解决上面的问题？有两种方式： 使用 Map，通常这是更加推荐的做法。 使用 Object.create(null) 从所有原型的顶端 null 继承，这样创建的对象是一个真正的纯对象，不会包含一般对象内置的 toString，valueOf，__proto__ 等属性。 属性遍历方法比较 Object.keys(obj) / Object.values(obj) / Object.entries(obj) – 返回一个包含对象自身的可枚举字符串属性的键 / 值 / 键值对的数组。不包含继承属性，不包含 Symbol 属性。 Object.getOwnPropertySymbols(obj) – 返回一个包含自身所有 Symbol 属性的数组。 Object.getOwnPropertyNames(obj) – 返回一个包含自身所有字符串属性的数组。 Reflect.ownKeys(obj) – 返回一个包含自身所有属性的数组。 obj.hasOwnProperty(key) - 如果自身（非继承）包含该属性，返回真。 for...in 循环 - 遍历所有可枚举的字符串属性，包括自身属性和继承属性。不包括不可枚举属性，不包括 Symbol 属性。 基于原型实现继承虽然 ES6 引入了 class 关键字，但那只是一种语法糖。JavaScript 中继承的实现本质上是基于原型的。原型继承的实现参考以下代码：12345678910111213141516171819202122232425262728function Animal(name) &#123; this.name = name;&#125;Animal.prototype.eat = function () &#123; console.log(`$&#123;this.name&#125; eats`);&#125;;Animal.prototype.walk = function () &#123; console.log(`$&#123;this.name&#125; walks`);&#125;;function Rabbit(name) &#123; this.name = name;&#125;Rabbit.prototype.walk = function () &#123; console.log(`$&#123;this.name&#125; bounces`);&#125;;// 让 Rabbit 继承 AnimalObject.setPrototypeOf(Rabbit.prototype, Animal.prototype);// 或者这样写： Rabbit.prototype = Object.create(Animal.prototype);// 不推荐写法： Rabbit.prototype.__proto__ = Object.prototypeconst rabbit = new Rabbit('white rabbit');rabbit.walk(); // white rabbit bouncesrabbit.eat(); // white rabbit eats]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 学习笔记：对象的属性描述符]]></title>
    <url>%2Fpassages%2FJavaScript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 中的对象属性，并不只是简单的键值对，通过属性描述符 property descriptor ，我们可以更加灵活的配置对象属性以控制属性的行为，包括是否可枚举、是否可写、是否可配置，实现更强大的功能。实际上，对于对象而言，一共有 2 种属性： 数据属性 data property 访问属性 accessor property 数据属性通常我们见到的属性都是这样的：12345// 代码片段 1const user = &#123; name: 'Sheldon', age: 29&#125;; 上面的 name 和 age 都是数据属性。 访问属性还有另一种形式，比如：123456789101112131415// 代码片段 2const user = &#123; name: 'Bill', surname: 'Gates', get fullname() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set fullname(value) &#123; [this.name, this.surname] = value.split(','); &#125;&#125;;user.fullname // Bill Gatesuser.fullname = 'Sheldon Cooper';user.name // Sheldon 上面的 name 和 surname 是数据属性，fullname 则是访问属性。即凡是使用 get prop() 或者 set prop() 定义的属性，都是访问属性，不再是数据属性。 数据属性的描述符对于数据属性而言，其描述符由 4 个 flag 组成： value 属性的值 writable 是否可写 enumerable 是否可枚举，在类似 for...in 遍历中是否忽略 configurable 是否可配置，即是否可以编辑描述符的 flag 对于使用字面量声明的对象属性而言，除了 value 之外的 3 个 flag 的默认值都为 true。使用 Object.getOwnPropertyDescriptor(obj, prop) 方法可以获取对象上某属性的描述符。比如获取上面代码片段 1 中 user 对象 name 属性的描述符：12345678// 代码片段 3const descriptor = Object.getOwnPropertyDescriptor(user, 'name');// &#123;// "value": "Sheldon",// "writable": true,// "enumerable": true,// "configurable": true// &#125; 如果想要精确地控制属性的行为，使用 Object.defineProperty(obj, prop, descriptor) 方法。使用这种方式，如果属性的某个 flag 没有显式指定，则默认值将是 false 。123456789101112131415// 代码片段 4const user = &#123;&#125;;Object.defineProperty(user, 'name', &#123; value: 'Sheldon', writable: true&#125;)const descriptor = Object.getOwnPropertyDescriptor(user, 'name');console.log(JSON.stringify(descriptor, null, 2));// &#123;// "value": "Sheldon",// "writable": true,// "enumerable": false,// "configurable": false// &#125; 可以看到，除了显式指定的 writable ，其他未指定的 flag 的都是默认为 false。 可枚举性描述符的 enumerable 属性，称为“可枚举性”，如果该属性为 false，就表示某些操作会忽略当前属性。目前，有四个操作会忽略 enumerable 为 false 的属性。 for...in 循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。 可配置性描述符的 configurable 属性，表示该属性的 flag 是否可配置，一旦设为 false 不可逆。用的很少。 访问属性的描述符访问属性的描述符不同于数据属性的描述符，没有 value 和 writable 这 2 个 flag，多了 get 和 set，所以一个访问属性的描述符可能有如下组成： get – 无参数函数，当属性被读取时被调用 set – 单参数函数，当属性被设置时被调用 enumerable – 与数据属性一致 configurable – 与数据属性一致 访问属性的 getter/setter 可以直接使用字面量声明（如上面的代码片段 2 所示），也可以使用 Object.defineProperty，如下：1234567891011121314// 代码片段 5const user = &#123; name: 'Bill', surname: 'Gates'&#125;;Object.defineProperty(user, 'fullname', &#123; get() &#123; return `$&#123;this.name&#125; $&#123;this.surname&#125;`; &#125;, set(value) &#123; [this.name, this.surname] = value.split(','); &#125;&#125;) getter/setter 应用使用 get 和 set 访问属性描述符，我们可以更加灵活控制属性的读写行为。比如对于 user 对象而言，可以限制 name 的长度：12345678910111213// 代码片段 6const user = &#123; get name() &#123; return this._name; &#125;, set name(value) &#123; if (value.length &gt; 4) &#123; alert('用户名长度不能超过 4 位'); return; &#125; this._name = value; // 这里使用 this._name 是一种广泛的通用约定 &#125;&#125; 数据属性或访问属性需要注意的是，一个属性要么是数据属性，要么是访问属性，不能两者皆是。相应地，如果同时给属性设置 value 和 get 这 2 个 flag 会报错。123456789// 代码片段 7// Error: Invalid property descriptor. Cannot both specify accessors and a value or writable attributeObject.defineProperty(&#123;&#125;, 'prop', &#123; get() &#123; return 1 &#125;, value: 1&#125;); 参考链接 ES6 入门 - 阮一峰 Modern Javascript Tutorial]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么 0.1 + 0.2 !== 0.3]]></title>
    <url>%2Fpassages%2F%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3%2F</url>
    <content type="text"><![CDATA[JavaScript 中的数字以 64 位浮点数的格式表示，遵从IEEE 754-1985这一用二进制表示数字的工业标准。其中的 52 位用于分数部分，即存储精度；11 位用于指数部分，即表示小数点的位置；1 位用于符号位，表示正负。如下图所示： 对于 64 位双精度数字而言，维基百科上给出了如下信息： Width: 64 bits Range at full precision: ±2.23×10e308 to ±1.80×10e308 Precision: Approximately 16 decimal digits 即在保证精度不丢失的前提下，64 位浮点数最多能表示 16 位的十进制数，超出这一限制则导致精度丢失。回到标题抛出的问题：0.1 + 0.2 !== 0.3，我们可以试着运行以下代码：123456console.log(0.1.toFixed(16));// 0.1000000000000000console.log(0.1.toFixed(17));// 0.10000000000000001console.log(0.1.toFixed(20));// 0.10000000000000000555 这进一步说明超过 16 位的十进制数，使用 64 位浮点数的二进制表示会产生精度丢失。与此同时，我们注意到：十进制数 0.1 是无法用二进制来精确表示的，这正如 1 / 3 无法在十进制下用有限位数来精确表示，是一样的道理。这里引出了一个问题，什么样的数字在十进制下无法精确表示？什么样的数字在二进制下无法精确表示？ 个人对进制的思考进制即进位计数制，十进制即逢十进一，二进制即逢二进一，N 进制即逢 N 进一；从相反的一面来看，N 也是基数，即在 N 进制下如果要产生小数，便是用 N 为基数去分割。为了方便说明，这里以十进制为例。在十进制下，要产生可以精确表示的小数就是用基数 10 去分割，所以 1 / 10 是可以精确表示的，又由于 10 本身并非素数，可以由 2 x 5 得来，所以十进制下，只有分母表述成如下方式的小数才能精确表示：122**x * 5**y// x 和 y 为 非负整数 考虑常见的 1 / 2 到 1 / 10:1234567891 / 2 -&gt; 2**1 * 5**01 / 3 -&gt; fail1 / 4 -&gt; 2**2 * 5**01 / 5 -&gt; 2**0 * 5**11 / 6 -&gt; fail1 / 7 -&gt; fail1 / 8 -&gt; 2**3 * 5**01 / 9 -&gt; fail1 / 10 -&gt; 2**1 * 5**1 引申到二进制的环境下，只有分母表述成如下方式的二进制小数才能精确表示：122**x// x 为非负整数 所以对于十进制数 0.1, 0.2, 0.3都无法用二进制来精确表示，当两个数字求和时，它们丢失的精度会加起来，这便是 0.1 + 0.2 !== 0.3 的原因。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>精度丢失</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Bash 常用命令集锦]]></title>
    <url>%2Fpassages%2FGit%20Bash%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[Git Bash 是将 GNU 开源软件下的命令移植到了 Windows 下面。同时不仅可以使用大部分常用的 linux shell 命令，也集成了部分 Windows 下的命令。比如显示当前目录下的文件和文件夹，ls以及dir都是可用的。下面列出了我在 linux shell 下的常用命令。 路径查找和切换1234567891011121314151617181920212223242526pwd# print working directory, 打印当前工作目录ls# list,查看当前目录下的文件，不包括隐藏文件，仅显示文件名称ls -a# list all, 查看当前目录下的所有文件，包括隐藏文件ll(ls -l)# 查看当前目录下的文件详细信息，包括时间、读写权限等cd &lt;path&gt;# change directory, 改变目录，后面尖括号内是目标目录的路径cd# 当不加参数时，跳转到设定的默认启动目录cd ~# 在 Linux 下面，~ 表示当前用户账户的根目录cd ..# 跳转到上一级目录cd ./project/static# 跳转到当前目录的下一级目录project/static 文件操作类123456789101112131415161718192021222324252627rm path/to/file.ext# remove,删除 path/to 目录下的 file.ext 文件，注意： rm 命令只能用于删除文件rm -r path/to/folder# 删除 path/to/folder 文件夹， -r 必须要加，表示 recursive,即递归的删除rm -rf path/to/folder# rm -r -f path/to/folder# 删除 path/to/folder 文件夹，-f 表示 force，即强制删除mv path/to/file.ext different/path/file.ext# move,移动文件mv old-filename.ext new-filename.ext# mv 命令同样可以用来重命名文件cp file-to-copy.ext# copy,复制文件mkdir new-folder# make directory,新建文件夹touch file.ext# 新建文件，默认在当前目录touch path/to/file.ext# 在指定的目录下新建文件 产生输入类12345678echo text-will-be-echo# echo 的意思是回音，这条指令相当于打开了一条读写流echo text-will-be-written-to-file &gt; file.ext# 将内容写入到文件中，后面写入的内容将覆盖之前的内容echo text-will-be-written-to-file &gt;&gt; file.ext# 将内容写入到文件中，后面写入的内容将追加到之前的内容末尾 产生输出类1234567cat file.ext# 查看文件内容，一次性显示全部内容。less file.ext# 查看文件内容，显示当前命令行窗口可以展示的内容。# 接着每按下一次 回车键 ，继续显示一行信息。# 按下空格键显示下一页信息，按下 b 键显示上一页信息，按下 q 键退出显示。 网络类1234curl name=bill&amp;age=18 https://example.com:8080# 发送 GET 请求到 https://example.com:8080,第二个参数是可选的 GET 请求参数curl -d name=bill&amp;age=18 https://example.com:8080# 发送 POST 请求到 https://example.com:8080,这里的 -d 表示的 POST 请求,第三个参数是可选的 POST 请求参数 增强开发体验类123456789101112131415clear# 清屏alias# 别名，相当于给一个命令设置快捷方式。比如 alias ll='ls -l' Tab 键位# 神奇的键位，在命令行主要用作自动补全，比如自动补全路径Arrow 键位# 命令行保存了你之前输入过的命令，上下箭头分别向前和向后显示你输入过的命令Ctrl 键位# Ctrl + A 将光标定位到当前行的开头， Ctrl + E 将光标定位到当前行的末尾# 在 Windows下，你也可以用 Home键 和 End键 实现相同功能 其他参考链接Linux Commands 集合]]></content>
      <tags>
        <tag>Git Bash</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['=='与'===']]></title>
    <url>%2Fpassages%2F%E2%80%98%3D%3D%E2%80%99%E4%B8%8E'%3D%3D%3D'%2F</url>
    <content type="text"><![CDATA[JavaScript中有两个用于判断两个值相等的符号：== 和 === 。分两种情况来考虑：基本数据类型和对象。 基本数据类型对于基本数据类型而言，=== 直接比较两个基本数据类型的值是否相等，不做类型转换，== 会试图进行类型转换再比较。123456789101112131415const s1 = '1';const s2 = '1';const n1 = 1;const n2 = 1.0;const b = true;console.log(s1 === s2); // trueconsole.log(s1 === n1); // falseconsole.log(s1 == n1); // trueconsole.log(n1 === n2); // trueconsole.log(n1 === b); // falseconsole.log(s1 == b); // trueconsole.log(n1 == b); // true 对象对于对象而言， == 和 === 效果完全一样，都是用于判断两个对象是否是同一个对象。1234567const o1 = &#123;&#125;;const o2 = &#123;&#125;;const o3 = o1; // 此时 o1 和 o3 指向堆内存中的同一个对象console.log(o1 == o2); // falseconsole.log(o1 === o2); // falseconsole.log(o1 === o3); // true 总结对于对象而言，== 和 === 效果是一样的，而且是比较两个对象变量是否指向内存中的同一块区域。对于基本数据类型而言，== 在面对两个不同类型的数据时，会试图进行类型转换再比较，而===则不会，直接比较值是否相等。 图片测试]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>宽松相等与严格相等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的求值策略]]></title>
    <url>%2Fpassages%2FJavaScript%20%E4%B8%AD%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[计算机科学中有个概念，叫做求值策略 Evaluation Strategy。它决定了变量之间，函数的实参与形参之间，值是如何传递的。求值策略主要有以下两种：按值传递和按引用传递。 按值传递与按引用传递 按值传递（call by value）是最常用的求值策略，函数的形参是被调用时函数实参的副本，修改函数的形参不会影响实参。 按引用传递（call by reference）是另一种求值策略，函数的形参是被调用时函数实参的隐式引用，不再是函数实参的副本，修改函数的形参会相应地影响到实参，因为函数实参传递给函数形参是引用本身。 按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的 BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。首先明确一点，在 JavaScript 中，不存在按引用传递。那么，是不是 JavaScript 中，变量之间，函数形参与实参之间都是按值传递呢？这是一个有些争议的问题，可以近似认为，JavaScript 中的值都是按值传递。下面分基本类型的值和引用类型的值两种情况来看。 基本类型的值对于基本类型的值，情况非常简单清晰，考虑以下代码： 12345678// 示例1let name = 'Bill'const f = function(name) &#123; name = 'Sunny'&#125;f(name)console.log(name) // Bill 上面代码说明，基本类型按照值传递，函数实参只是函数形参的一个副本。也就是说，函数被调用时，引擎会分配一块新的内存来存放从函数实参复制来的函数形参，所以接下来函数内部对形参所做的所有操作都是基于这块新的内存，函数实参自然不会受到影响。 引用类型的值对于引用类型的值，也就是对象，情况有些不一样。考虑以下代码： 12345678910// 示例2let user = &#123; name: 'Bill'&#125;const f = function(user) &#123; user.name = 'Sunny'&#125;f(user)console.log(user.name) // Sunny 上面的代码说明，传入的对象 user 被函数 f 改变了，那么是否说明对于引用类型的值，是按照引用传递的吗？再考虑以下代码： 12345678910111213// 示例3let user = &#123; name: 'Bill'&#125;const f = function(user) &#123; user = &#123; name: 'Sunny' &#125; // user = null, 结果一样&#125;f(user)console.log(user.name) // Bill 如果 JavaScript 中的对象确实是按引用传递，传入的对象 user 的指向将被改变，那么上面代码最后一行应该打印 Sunny 。然而，实际打印出的仍然是 Bill ，这说明 JavaScript 中对象的值也不是按照引用传递的。事实上，对于对象而言，JavaScript 中函数实参传递给函数形参的是对象地址的一个副本，此时函数实参和形参都指向内存中同一块区域。所以在示例 2 中，修改 user.name 的值才会影响到原 user 对象。 总结对于这种求值策略，一种观点认为本质上仍然是按值传递，另一种观点认为是按共享传递。叫什么术语其实不重要，重要是理解其内在机制，即调用函数传参时，函数实参传递给函数形参的，是对象的内存地址的副本，既不是按值传递的对象副本，也不是按引用传递的内存地址本身。 参考链接Evaluation Strategy Call by value Call by reference Call by sharing http://dmitrysoshnikov.com/-Evaluation Strategy http://www.cnblogs.com/bosnma/p/4256108.html]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>求值策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源政策与跨域问题]]></title>
    <url>%2Fpassages%2F%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同源政策与跨域问题什么是浏览器的同源政策？维基百科对同源政策的定义。简单来说，为了保护用户的数据安全，浏览器规定，对于不同源的网页，它们之间以下的资源交互行为是被禁止的： 持久化数据无法获取，包括 Cookie, LocakStorage, IndexDB DOM 无法获取 AJAX 请求不能发送 仔细想想，以上3种行为对于用户安全来说，都是非常危险的。持久化数据通常含有用户的身份信息、登录态信息；至于 DOM 和 AJAX 这两者的权限都可能导致网页被植入恶意代码。 同源的严格定义如果说两个网页同源，是指以下 3 个部分都相同： 协议 主机 端口 举例来说，http://www.example.com/dir/page.html 这个网址，协议是 http://，域名是 www.example.com，端口是 80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 不受同源政策限制的资源交互行为需要明确的一点是，同源政策对于 HTML 标签是没有限制的，这使得网页可以从远程服务器获取资源文件，主要有以下标签： script 标签用来获取远程脚本文件，JSONP 跨域方式就是利用了这一点 link 标签用来获取远程 CSS 文件 image 标签用来获取远程图片文件 audio 标签用来获取远程音频文件 video 标签用来获取远程视频文件 如何规避同源政策来实现数据获取？在实际开发中，需要突破同源政策的限制来获取数据，主要是在使用 AJAX 向非同源服务器发送请求的场合。主要使用下面的几种方式来规避同源政策获取数据： 跨域资源共享 JSONP 服务器代理转发 跨文档通信 Cross-document messaging。这是 HTML5 为了解决跨文档通信引入的新 API：window.postMessage，但是这种方式能获取的内容是作了严格限制的，原因仍然是出于安全考虑。 WebSocket 跨域资源共享即Cross-Origin Resource Sharing。这是一个很大的话题，而且基本由后端实现 CORS 的支持，详情见参考链接 3 和 4，两篇文章讲的非常清晰。 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。123foo(&#123; "ip": "8.8.8.8"&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。此外， JSONP 的方式仅限于 GET 方法的网络请求。 架设代理服务器，转发请求架设一个同源的服务器，浏览器向该同源服务器发送 AJAX 请求，再由该服务器转发请求到外部非同源服务器。 跨文档通信WebSocket参考链接 同源政策及其规避方法 Same-origin policy 跨域资源共享 CORS 详解 - 阮一峰 CORS - MDN]]></content>
      <tags>
        <tag>浏览器</tag>
        <tag>同源政策</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活美学大师的 5 个锦囊]]></title>
    <url>%2Fpassages%2F%E7%94%9F%E6%B4%BB%E7%BE%8E%E5%AD%A6%E5%A4%A7%E5%B8%88%E7%9A%84%205%20%E4%B8%AA%E9%94%A6%E5%9B%8A%2F</url>
    <content type="text"><![CDATA[生活美学大师的 5 个锦囊，让你告别无趣的生活. 给事物排名的乐趣 每年给自己的屋子做点改变 第二天感恩 附身的魔力 看看大街上的镜子 给身边的事物排名不仅可以提升生活的乐趣，还能提升你的观察能力，总结分析能力。这种做法不是为了争强好胜，而是为了给生活加点调料，增加乐趣。比如，你可以尝试自己的排名。身边的十大美食，十大书籍，十大电影，十大当地景点等。 每年给自己的屋子做点改变在阳台上加一盆自己喜爱的盆栽也是一点改变. 第二天感恩第二天感恩是一个泛指，别人给你推荐了一本好书，或者旅行回来给你带了点小零食，在过了几天或一段时间后，你觉得不错甚至受益匪浅，那么要把这份美好的心情和感激告诉别人。这同时可以增加我们自己的生活乐趣，维持一种好的社交氛围。 附身的魔力有一个人以前一直害怕坐飞机，后来每次坐飞机都将自己想象成飞行员，以此来克服恐惧心理。 看看大街上的镜子在街上，通过车窗玻璃，商场镜子等，不时的照照镜子，给自己一个正面、积极的心理暗示。 书籍：《非常非常好》作者：松浦弥太郎]]></content>
      <tags>
        <tag>生活</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass 快速入门]]></title>
    <url>%2Fpassages%2FSass%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Sass快速入门What is Sass?Sass 是 CSS 的一个扩展，它使得 CSS 的使用更加优雅和强大 Why Sass?Sass 的以下特性使得 Sass 成为一个成熟、稳定、强大的 CSS 扩展语言解析器。 变量变量声明在 Sass 中，使用 $ 前缀符号来表明这是一个变量。同时，变量是存在作用域的。123456789101112$highlight-color: #f90;nav &#123; $width: 100px; width: $width; color: $highlight-color;&#125;/* 编译后 */nav &#123; width: 100px; color: #f90;&#125; 变量引用变量可以引用另一个变量1234$highlight-color: #f90;.selected &#123; bodrer: 1px solid $highlight-color;&#125; CSS规则嵌套选择器嵌套123456789101112131415/* sass */#content &#123; background: #555; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background: #eee &#125;&#125;/* 编译后 */#content &#123; background: #555 &#125;#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background: #eee &#125; 父选择器的标识符&amp;Sass 提供父选择器的标识符 &amp; 主要是为了解决例如 :hover 等伪类的特殊情况。考虑下面这个情况：12345678article a &#123; color: blue; :hover &#123; color: red &#125;&#125;/* 编译后，这与我们预期不符 */article a &#123; color: blue &#125;article a :hover &#123; color: red &#125; 使用父选择器的标识符 &amp; 可以解决这个情况，&amp; 指代父选择器本身。12345678article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125;/* 编译后 */article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 群组选择器的嵌套1234567891011/* sass */.container &#123; h1, h2, h3 &#123; margin-bottom: .8em &#125;&#125;nav, aside &#123; a &#123; color: blue &#125;&#125;/* 编译后的css */.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125;nav a, aside a &#123; color: blue &#125; 属性嵌套123456789101112131415/* sass */nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125;/* 编译后的css */nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125; 属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。 导入在原生 CSS 中，有一个不常用的特性是 @import 规则，它允许在 .css 文件中导入其他的 .css 文件，但是这种导入的运行机制是：只有当执行到@import 语句时，浏览器才会去下载指定导入的 .css 文件，这导致页面加载起来会特别慢。 Sass 中实现的 @import 规则在生成 .css 文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个 CSS 文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。 嵌套导入12345678/* blue-theme.scss文件 */aside &#123; color: blue; background: white;&#125;/* base.css文件 */.blue-theme &#123; @import "blue-theme" &#125; 静默注释CSS 的标准注释会被保存在网页内，大多数时候这不是我们想要的结果。Sass 提供了另一种类似 C 语言风格的注释，称之为静默注释，因为这类注释不会被保存在网页内，即浏览网页的用户看不到它们。123456body &#123; color: #999; /* 这是CSS的标准注释 */ background: white; // 这是Sass提供的静默注释&#125; 混合器mixinSass 提供了混合器来实现多组样式规则的复用。比如下面定义了一个简单的混合器，目的是添加跨浏览器的圆角边框。12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后你可以使用 @include 来使用混合器：1234567891011121314.notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass 最终生成：.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 何时使用混合器利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式（严谨的描述是：几条样式规则），那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。 判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个简洁的名字来描述这些属性修饰的样式，比如 rounded-corners, fancy-font, 或者 no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。 混合器在某些方面跟 CSS 类选择器很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在 html 文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述 html 元素的含义而不是 html 元素的外观。而另一方面，混合器是展示性的描述，用来描述一条 CSS 规则应用之后会产生怎样的效果。 在之前的例子中，.notice 是一个有语义的类名。如果一个 html 元素有一个 notice 的类名，就表明了这个 html 元素的用途：向用户展示提醒信息。rounded-corners 混合器是展示性的，它描述了包含它的 CSS 规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用可以写出整洁的 HTML和 CSS，因为使用语义化的类名也可以帮你避免重复使用混合器。为了保持你的 HTML 和 CSS 的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 有时候仅仅把属性放在混合器中还远远不够，可喜的是，Sass 同样允许你把 CSS 规则放在混合器中。 混合器中的 CSS 规则混合器中不仅可以包含属性，也可以包含 CSS 规则，即包含选择器和选择器中的属性：123456789101112131415161718192021222324252627// 定义一个混合器@mixin no-bullets &#123; list-style: none; li &#123; list-style-type: none; list-style-image: none; margin-left: 0; &#125;&#125;// 引用这个混合器ul.plain &#123; color: #444; @include no-bullets;&#125;// 编译后的 cssul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-type: none; list-style-image: none; margin-left: 0;&#125; 给混合器传参数，定制样式当 @include 混合器时，参数其实就是可以赋值给 CSS 属性值的变量。如果你写过 JavaScript，这种方式跟 JavaScrip t的 function 很像：1234567891011121314151617@mixin link-colors ($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;// 引入混合器a &#123; @include link-colors(blue, red, green);&#125;// 编译后的CSSa &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 给混合器设置默认参数值为了在 @include 混合器时不必传入所有的参数值，可以给参数指定一个默认值。这个默认值可以是任何有效的 CSS 属性值，甚至是其他参数的引用。比如：1234567891011121314151617181920212223242526272829303132// 定义指定参数默认值的混合器// 类似JavaScript中的函数@mixin link-colors ( $normal, $hover: $normal, $visited: gray )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125;// 引用混合器a &#123; @include link-colors(red);&#125;// 编译后的CSSa &#123; color: red;&#125;a:hover &#123; color: red;&#125;a:visited &#123; color: gray;&#125; 选择器的继承选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过 @extend 语法实现，如下代码:123456789.error &#123; border: 1px red; background-color: #fdd;&#125;.serious-error &#123; extend .error; border-width: 3px;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于写日记]]></title>
    <url>%2Fpassages%2F%E5%85%B3%E4%BA%8E%E5%86%99%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘录一篇关于写日志的文章。 写日记是可以加快你的个人成长速度的最简单而又最强大的工具之一。把你头脑中的想法写出来，能让你得到不这样做所无法获得另一种看待事物的视角。 超越你的思维极限虽然你的大脑可以同时处理许多信息，但你清醒地思考时却做不到。思绪是一个接着一个出现的，是一个序列。一个想法激发下一个想法，如此往复。有时这些序列会产生一些分支，但它们仍然受时间线的限制，在任何给定的时刻，你都追随着这些分支思绪中的一个。这些思绪序列都有一个开始，一个发展，和一个结束，当你陷在一个思绪系列中重复回想这些想法时，要想理清思路是近乎不可能的。 在这个方面，写日记便能给你提供巨大的便利。写日记可以让你从思维序列中解放出来，让你以一个鸟瞰你的想法的视角去审视你的想法。当把你的序列思维复制在一种有形的介质中，你就可以回过头来以一个旁观者的身份回顾这些想法。但当你在复制这些想法时，你仍处于第一人称模式之中。而当你回顾它们的时候，你就能以客观的而非主观的视角看待它们。这种客观的视角，再加上你从主观视角中学到的东西，能让你更进一步地看清你所面对的处境。 写日记的其他好处下面是写日记的另外 3 种好处： 解决棘手的问题当你陷在一种主观的，第一人称的视角时，一些问题是很难得以解决的。只有当你将情景复制下来，然后从一个旁观者的角度重新审视问题时，解决方案才能变得清晰明了。有时问题的解决方法是如此显而易见，以至于连你自己也会为自己当初没有及时想到而感到震惊。 理清思路当你思绪混乱，不知该做什么的时候，是非常适合写日记的。你该辞职还是创业？你该和你的现任男/女朋友结婚吗？当你把这些问题写下来，然后再去思考，你对事情就会更有把握。 见证你的进步翻出几年前写的日记，看看自己这几年来取得的实质性的进步，是一件无比美妙的事。当你感到沮丧，看不到对明天的希望时，就翻出你在几年前写的日记——这能彻底改变你的观点。即便在你感觉自己似乎在原地踏步的时候，这也能帮助你意识到你其实正在进步、正在改变。 虽然一些人写日记用来记录生活中的一些事情，但我一般都不写这样的日记，而且我甚至很少回头去看过去写的日记。对我来说，写日记主要是一个解决问题的工具，一种帮助我面对复杂的问题时理清思路的方法。我每月平均会写 5-10 篇日记，我通常会以一个提问或一个我想要解决的问题开始一篇新的日记。然后我就会去探索解决问题的可能方案。有时这些问题是非常简单的，如“下一篇文章我该选择什么主题？”其它时候我会探索更广泛的内容，如“2015 我想去哪里？为了做到这一点我现在就要开始/停止去做的事情有哪些？”有时我会天马行空地写下所有可能的解决方案；有时我会写下一个问题，然后从不同的角度思考它，希望更全面地理解这个问题。例如，我会问自己，“爱因斯坦会怎样解决这个问题？达·芬奇？”或者，我会问自己，“这个问题的积极面是什么？我要怎么做就可以不必解决这个问题？这个问题的最优解决方案一定要具备什么？” 我发现，像这样的练习是非常有价值的。当我想尝试解决一个问题的时候，如果它是一个简单的问题，我通常只要好好思索一番就能够解决它；但面对更加复杂的问题时，大多数想要把问题想明白的尝试都以失败告终。要么我根本就没有找到一个满意的解决方案，要么我对这个问题缺乏全面的理解而对我找到的解决方法没有把握，或者有的时候我找到了一个满意的解决方法，但睡了一个晚上之后再去看它时却觉得它不那么可行。所以在面对那些重大的、复杂的问题的时候，我不会光在脑子里思考，我会把它们写下来。思维往往会定型，我们的大脑总有一种想要下定论的趋势；例如，我们总是按照事物的模式对其进行分类，来达到简化问题的目的。但是，有的时候我们不可以过早的将一个问题简化为我们以前解决的某个问题，我们还要考虑产生这个问题的新的因素，这是非常重要的。例如，如果你管理着一个公司，发现你们的销售业绩有暂时下降的趋势，像这样的问题以前也发生过，也被你们解决过，但你仍然有必要考虑引发这个问题的新的因素，而不是套用过去的解决方法。 将问题写在纸上加以探索，我就可以避免定性思维，而且这也能让我更容易地发现存在于可能的解决方案中的尚未被考虑到的因素。当我在纸上从某一个特地的角度探索某一个问题，写完之后我就可以先放下它，然后从另一个角度去考察它。因为我把它们都写在纸上，而且又是从不同的角度去思考的，所以我总是可以非常容易地看到这个问题的各个侧面，这能帮助我作出明智的决定。所以从本质上来说，写日记帮助我克服了思维上的局限性，允许我更全面地考察待解决的问题。 一些问题超出了我们所能理解的范围，我们只能够对这些问题的一小部分进行思索。我们的大脑非常强大，但我们的心智在处理多个并发的想法时仍然显得很有局限性。例如，你可以闭上眼睛然后想象一棵苹果树，但你可以从一百个不同的角度同时想象出这棵苹果树的样子吗？即便是一个非常简单问题，如“晚餐吃什么？”也足以让我们犹豫一番。要想作出一个最好的决定，我们就必须把所有我们可能会在晚餐时吃的食物都考虑一遍，并对它们的口味、营养价值、价格等进行排序。面对这个相对而言非常简单的决定，我们可能会有三至四个选择，然后再从中选择最好的一个。但假如我们所面对的是一个更加重大，能带来更深远影响的决定，那我们对我们所作出的决定是否接近于最优决定抱有信心就显得更加重要了。生活中充满了这样的选择。我该选择哪一条职业道路？我该在哪里生活？我该离婚还是保持这段不快乐的婚姻？这些都是可以改变人生的决定。你当然可以随意地、不假思索作出一个决定，但你一定是承担后果的那一个人。 即便是写日记也无法克服我们心智上的主要极限——系统地思考成千上万种可能的解决方案——但写日记至少是我们朝着正确的方向迈出的一小步。我们仍然要把我们制定决策时的大部分工作交给我们的潜意识，直觉和情绪。但我们进行这个练习——将纸或电脑屏幕作为我们的意识的延伸——的次数越多，我们就可以更清晰、更有把握地确定最适合我们的决定。而且从长期来看，坚持锻炼我们的心智并作出更清醒的决定，我们就能够收获更美好的结果。 写日志要遵守的条件写日记必须遵守的三个条件 ：一是坚持，尤其开始时每天都写，来不及就第二天补写，绝不偷懒，这样才能形成为习惯。二是感悟，感触要仔细写，努力寻找确切的表达，绝不马虎，绝不敷衍。三是坦诚，不给人看，这样在写日记时才能坦然面对自己，句句都写真心话。]]></content>
      <tags>
        <tag>百科知识</tag>
        <tag>生活</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活要有不较劲的智慧]]></title>
    <url>%2Fpassages%2F%E7%94%9F%E6%B4%BB%E8%A6%81%E6%9C%89%E4%B8%8D%E8%BE%83%E5%8A%B2%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[昨天，在网易云音乐的电台上听到一篇周国平的文章，《生活要有不较劲的智慧》，觉得很有意思。其中很多观点我也深以为然。 他提出了一个也许并不新奇的观点：人生的三大意义。我想这兴许不是他独创，古今中外，无数哲人可能都思考过类似的问题。人生的第一重意义：世俗的意义，即幸福。人生的第二重意义：精神的意义，即道德。人生的第三重意义：也是终极意义，即死亡。 昨天的这篇文章里，周国平主要谈了人生的第一重意义：幸福。在世俗的生活里，人的一切行为都指向一个目标—幸福。那么，什么是幸福？两种观点，快乐主义和完善主义。 快乐主义，追求身体无痛苦，灵魂无烦恼。中国的道家就接近于快乐主义。这种观点认为，幸福本应当是简单纯粹的，身体和灵魂都应保持简单，拥有持久的活力。庄子的《养生》和《逍遥游》都表达了类似的人生态度。 完善主义，讲究世俗生活应追求简单，而精神世界要保持丰富。即提倡后天培养属于自己的精神家园，孔子的思想是接近完善主义的代表。 说起自己的幸福，周国平回忆道：他的人生中，有两段时光最是幸福。一是刚进大学时，少年人情窦初开，周围有许多漂亮的女同学，只要有一个女同学对他微笑，他晚上回去都要写上不少情书，这是初尝幸福的滋味；二是初为人父，女儿出生的时候。 听完这段，我不由自主的回忆起自己这近三十载人生，有哪段时光让我尝到了幸福的滋味呢？细想下来，大致和周国平的两段时光一致。我想，像我这种性格偏内向，农村出生的男孩子，说起幸福的时光，大致也是这两段时期吧。我这么说，主要是出于精神生活的考量，而非物质生活。幸福是需要人的主观意识去感知的，农村的内向孩子，大多心智晚熟，物质匮乏本身倒无大碍，但是由此导致的精神生活的缺位，却大大影响了孩子的意识觉醒。所以，回忆起童年的时光，要说基本无忧无虑，我没有异议，但是说到幸福，我却不以为然。童年对于我，只是一段意识尚未完全觉醒，懵懂，简单的时光，与幸福无关。 情窦初开的年纪，那种男女间懵懂的情愫，是荷尔蒙带来的幸福。近而立之年，主观意识已经觉醒，初为人父的我，真切地尝到了幸福的滋味。我的宝贝女儿窈窈，到今天已经 58 天了。她的一颦一笑都那么可爱，惹人怜爱。这个新生命牵动着全家人的神经。 上面谈到的是感知到的幸福，那么如何追求幸福呢？简单来说，觅得一个相爱的伴侣，组成一个和谐温馨的家庭，有三两个真挚的好友，做自己喜欢做的事业，过着不至于奢侈但还算富足的日子，这便足矣。然而，以上几点都不是那么容易达成。相爱的伴侣不仅需要机缘，需要你自身有进取心，有变得优秀的潜力和决心，还需要你修身养性，与人为善，有生活的智慧。不然，你如何承诺你的伴侣共建一个美好的家庭呢？你又如何吸引到真挚、优秀的良师益友呢？可见，首先要修炼好自身。至于事业，有一句话说的切中要害，让自己的能力在一个领域里得到最好的施展，那这个领域就是你的事业。]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习编程的心态辅导]]></title>
    <url>%2Fpassages%2F%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BF%83%E6%80%81%E8%BE%85%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[当你选择学习编程，你的业余时间都会被它所占据，随着学习曲线逐渐变陡，你会感到枯燥、迷茫、自卑以及脑汁耗竭的痛苦。这是非常正常的。许多人在学习一门新技术时，都会遇到类似问题。对此，我个人的解决办法有： 找点乐子当你看完基础语法，对继续往下挖掘感到枯燥时，别勉强自己，翻翻书本，找一些有趣的练习题练练手，或者编写、修改一些简单有趣的小项目，跟你朋友讲你学到的新内容，给自己找点成就感。 专注在当前的学习目标上没有技术背景的人，学习编程容易被复杂的技术体系吓到，网上经常会出现“一定要读这本书”、“最好先有 XX 基础再看这篇教程”之类的警告，结果常会出现这种情况：本来你只打算学编写网页 ，结果却开始苦读《精通正则表达式》。 别担心，你无需掌握所有分支，很多时候，你只要知道在需要某个知识点时，能从这类教程中找到对应用法即可。 习惯无知无论学习什么，往往越深入就觉得自己无知。这并不是坏事，它能让你保持谦虚，但千万不要被吓得不敢继续前进。 觉得写出来的代码不忍直视？正常，因为你看过的例子和学到的知识增进了你的眼界，但编程技能和思想需要在练习中成长，所以千万不要因此而自卑，继续尝试，相信自己。 注意休息人的认知能力是会随着时间流逝而耗竭的，别逞能，站起来走动走动，呼吸一下新鲜空气吧！]]></content>
      <tags>
        <tag>学习方法</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出差及旅游注意事项]]></title>
    <url>%2Fpassages%2F%E5%87%BA%E5%B7%AE%E5%8F%8A%E6%97%85%E6%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[以下是我在若干次出差及旅游亲身经历中简单归纳出的一些建议: 防被坑类 不要住在火车站和高铁站附近的酒店或者宾馆。这些酒店由于地理位置有优势，通常高价低质，服务差。 在旅游区，不要做任何没有第三方担保的交易。 不要相信任何口头承诺，因为合同都不一定能执行，更遑论口头承诺。 景区的导游、出差地点的出租车司机带你去的饭馆和特产店等，极大可能存在利益关系。 生活细节类 提前了解景区或者目的地未来几天的天气，根据需要带好：防晒霜、保湿露、花露水。 带几个袋子，用于收纳穿过的衣服和袜子。 带一个有盖子的水杯，如果是冬天可以带保温杯。]]></content>
      <tags>
        <tag>设计</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
